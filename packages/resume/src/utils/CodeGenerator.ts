import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { ShareMemConfig, TemplateOptions } from '../types';

export class CodeGenerator {
  private templatesDir: string;

  constructor() {
    // Templates directory is at package root level
    this.templatesDir = join(__dirname, '..', '..', 'templates');
  }

  /**
   * Read template file and replace variables
   */
  private readTemplate(cliType: string, variables: Record<string, string>): string {
    const templatePath = join(this.templatesDir, `${cliType}-integration.template.js`);
    
    // Check if template file exists
    if (!require('fs').existsSync(templatePath)) {
      throw new Error(`Template file not found: ${templatePath}`);
    }

    let template = require('fs').readFileSync(templatePath, 'utf8');

    // Replace all {{VARIABLE}} placeholders
    for (const [key, value] of Object.entries(variables)) {
      const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      template = template.replace(placeholder, value);
    }

    return template;
  }

  /**
   * Generate integration code for specific CLI
   */
  async generateIntegration(cliType: string, projectPath: string, config: ShareMemConfig): Promise<void> {
    let code: string;

    try {
      // Try to use template file first (new approach)
      // Determine command name based on CLI type
      const needsSlashPrefix = ['claude', 'codebuddy'].includes(cliType.toLowerCase());
      const commandName = needsSlashPrefix ? '/stigmergy-resume' : 'stigmergy-resume';

      code = this.readTemplate(cliType, {
        COMMAND_NAME: commandName,
        VERSION: config.version,
        PROJECT_PATH: projectPath,
        HOME_DIR: require('os').homedir()
      });
      console.log(`ï¿½?Using template file for ${cliType}`);
    } catch (error) {
      // Fallback to old method generators if template file doesn't exist
      console.log(`ï¿½?Template file not found for ${cliType}, using fallback generator`);
      
      const templates = {
        claude: this.generateClaudeTemplate,
        gemini: this.generateGeminiTemplate,
        qwen: this.generateQwenTemplate,
        iflow: this.generateIFlowTemplate,
        codebuddy: this.generateCodeBuddyTemplate,
        qodercli: this.generateQoderCLITemplate,
        codex: this.generateCodexTemplate,
        kode: this.generateKodeTemplate
      };

      const generator = templates[cliType as keyof typeof templates];
      if (!generator) {
        throw new Error(`Unsupported CLI type: ${cliType}`);
      }

      const templateOptions: TemplateOptions = {
        cliType,
        projectPath,
        config
      };

      code = generator.call(this, templateOptions);
    }

    const integrationPath = this.getIntegrationPath(cliType, projectPath);

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    mkdirSync(join(integrationPath, '..'), { recursive: true });

    // å†™å…¥é›†æˆä»£ç 
    writeFileSync(integrationPath, code);
  }

  /**
   * è·å–é›†æˆä»£ç è·¯å¾„
   */
  private getIntegrationPath(cliType: string, projectPath: string): string {
    const paths = {
      claude: join(projectPath, '.claude', 'hooks', 'resumesession-history.js'),
      gemini: join(projectPath, '.gemini', 'extensions', 'resumesession-history.js'),
      qwen: join(projectPath, '.qwen', 'plugins', 'resumesession-history.js'),
      iflow: join(projectPath, 'stigmergy', 'commands', 'history.js'),
      codebuddy: join(projectPath, '.codebuddy', 'integrations', 'resumesession.js'),
      qodercli: join(projectPath, '.qodercli', 'extensions', 'history.js'),
      codex: join(projectPath, '.codex', 'plugins', 'resumesession-history.js'),
      kode: join(projectPath, '.kode', 'agents', 'resumesession-history.js')
    };

    return paths[cliType as keyof typeof paths] || join(projectPath, '.resumesession', `${cliType}-integration.js`);
  }

  /**
   * Claude CLI é›†æˆæ¨¡æ¿
   */
  private generateClaudeTemplate(options: TemplateOptions): string {
    const { projectPath, config } = options;

    return `// Claude CLI ResumeSession Integration
// Auto-generated by ResumeSession v${config.version}
// Project: ${projectPath}

const { spawn, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

/**
 * å¤„ç† /history å‘½ä»¤
 */
async function handleHistoryCommand(input, context) {
  try {
    console.log('ğŸ” Searching cross-CLI history...');

    // æ„å»ºæŸ¥è¯¢å‘½ä»¤
    const query = buildQuery(input);

    // æ‰§è¡Œè·¨CLIä¼šè¯æ‰«æ
    const sessions = await scanProjectSessions(query, context);

    // æ ¼å¼åŒ–ç»“ï¿½?    const response = formatResponse(sessions, query, context);

    return {
      response,
      suggestions: generateSuggestions(sessions, query)
    };
  } catch (error) {
    console.error('History command error:', error);
    return {
      response: \`ï¿½?å†å²æŸ¥è¯¢å¤±è´¥: \${error.message}\`,
      suggestions: ['/history --help']
    };
  }
}

/**
 * æ„å»ºæŸ¥è¯¢å‚æ•°
 */
function buildQuery(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(/^\\/history\\s*/i, '').trim();
  const parts = cleanInput.split(/\\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();

    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format' && i + 1 < parts.length) {
      const format = parts[++i]?.toLowerCase();
      if (['summary', 'timeline', 'detailed', 'context'].includes(format)) {
        options.format = format;
      }
    } else if (part === '--today') {
      options.timeRange = 'today';
    } else if (part === '--week') {
      options.timeRange = 'week';
    } else if (part === '--month') {
      options.timeRange = 'month';
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

/**
 * æ‰«æé¡¹ç›®ä¼šè¯
 */
async function scanProjectSessions(query, context) {
  // Create history query instance and execute
  const historyQuery = new HistoryQuery();
  const result = await historyQuery.queryHistory(query, '${projectPath}');
  // For compatibility, return sessions directly for filtering by the old formatResponse function
  // But we'll need to adapt the result structure to match expected format
  return []; // This function is now handled by HistoryQuery, returning empty as the main logic is in queryHistory
}

/**
 * æ ¼å¼åŒ–å“ï¿½? */
function formatResponse(sessions, query, context) {
  if (sessions.length === 0) {
    return \`ğŸ“­ å½“å‰é¡¹ç›®æš‚æ— å†å²ä¼šè¯\\n\\nğŸ’¡ **æç¤º:**\\nï¿½?å°è¯•: /history --search <å…³é”®ï¿½?\\nï¿½?æ£€ï¿½? å…¶ä»–CLIå·¥å…·æ˜¯å¦æœ‰ä¼šè¯æ–‡ä»¶\`;
  }

  switch (query.format) {
    case 'timeline':
      return formatTimeline(sessions);
    case 'detailed':
      return formatDetailed(sessions);
    case 'context':
      return formatContext(sessions[0]);
    default:
      return formatSummary(sessions, context);
  }
}

/**
 * æ ¼å¼åŒ–æ‘˜è¦è§†ï¿½? */
function formatSummary(sessions, context) {
  let response = \`ğŸ“ **é¡¹ç›®å†å²ä¼šè¯**\\n\\nğŸ“Š å…±æ‰¾ï¿½?\${sessions.length} ä¸ªä¼šè¯\\n\\n\`;

  // æŒ‰CLIåˆ†ç»„
  const byCLI = {};
  sessions.forEach(session => {
    if (!byCLI[session.cliType]) byCLI[session.cliType] = [];
    byCLI[session.cliType].push(session);
  });

  Object.entries(byCLI).forEach(([cli, cliSessions]) => {
    const icon = cli === 'claude' ? 'ğŸŸ¢' : 'ğŸ”µ';
    response += \`\${icon} **\${cli.toUpperCase()}** (\${cliSessions.length}ï¿½?\\n\`;

    cliSessions.slice(0, 3).forEach((session, i) => {
      const date = formatDate(session.updatedAt);
      const title = session.title.substring(0, 50);
      response += \`   \${i + 1}. \${title}...\n\`;
      response += \`      ğŸ“… \${date} ï¿½?ğŸ’¬ \${session.messageCount}æ¡æ¶ˆæ¯\\n\`;
    });

    if (cliSessions.length > 3) {
      response += \`   ... è¿˜æœ‰ \${cliSessions.length - 3} ä¸ªä¼šè¯\\n\`;
    }
    response += '\\n';
  });

  response += \`ğŸ’¡ **ä½¿ç”¨æ–¹æ³•:**\\n\`;
  response += \`ï¿½?'/history --cli <å·¥å…·>' - æŸ¥çœ‹ç‰¹å®šCLI\\n\`;
  response += \`ï¿½?'/history --search <å…³é”®ï¿½?' - æœç´¢å†…å®¹\\n\`;
  response += \`ï¿½?'/history --format timeline' - æ—¶é—´çº¿è§†å›¾\`;

  return response;
}

/**
 * æ ¼å¼åŒ–æ—¶é—´çº¿è§†å›¾
 */
function formatTimeline(sessions) {
  let response = \`ï¿½?**æ—¶é—´çº¿è§†ï¿½?*\\n\\n\`;

  sessions.forEach((session, index) => {
    const date = formatDate(session.updatedAt);
    const cliIcon = getCLIIcon(session.cliType);

    response += \`\${index + 1}. \${cliIcon} \${session.title}\\n\`;
    response += \`   ğŸ“… \${date} ï¿½?ğŸ’¬ \${session.messageCount}æ¡æ¶ˆæ¯\\n\`;
    response += \`   ğŸ”‘ \${session.cliType}:\${session.sessionId}\\n\\n\`;
  });

  return response;
}

/**
 * æ ¼å¼åŒ–è¯¦ç»†è§†ï¿½? */
function formatDetailed(sessions) {
  let response = \`ğŸ“‹ **è¯¦ç»†è§†å›¾**\\n\\n\`;

  sessions.forEach((session, index) => {
    const cliIcon = getCLIIcon(session.cliType);
    const date = session.updatedAt.toLocaleString();

    response += \`\${index + 1}. \${cliIcon} **\${session.title}**\\n\`;
    response += \`   ğŸ“… \${date}\\n\`;
    response += \`   ğŸ”§ CLI: \${session.cliType}\\n\`;
    response += \`   ğŸ’¬ æ¶ˆæ¯ï¿½? \${session.messageCount}\\n\`;
    response += \`   ğŸ†” ä¼šè¯ID: '\${session.sessionId}'\\n\\n\`;
  });

  return response;
}

/**
 * æ ¼å¼åŒ–ä¸Šä¸‹æ–‡è§†å›¾
 */
function formatContext(session) {
  if (!session) {
    return \`ğŸ“­ æš‚æ— å¯æ¢å¤çš„ä¸Šä¸‹æ–‡ã€‚\`;
  }

  let response = \`ğŸ”„ **ä¸Šä¸‹æ–‡æ¢ï¿½?*\\n\\n\`;
  response += \`ğŸ“… ä¼šè¯æ—¶é—´: \${session.updatedAt.toLocaleString()}\\n\`;
  response += \`ğŸ”§ æ¥æºCLI: \${session.cliType}\\n\`;
  response += \`ğŸ’¬ æ¶ˆæ¯ï¿½? \${session.messageCount}\\n\`;
  response += \`ğŸ†” ä¼šè¯ID: \${session.sessionId}\\n\\n\`;
  response += \`---\\n\\n\`;
  response += \`**ä¸Šæ¬¡è®¨è®ºå†…å®¹:**\\n\`;
  response += session.content.substring(0, 500);
  if (session.content.length > 500) {
    response += \`...\`;
  }

  return response;
}

/**
 * æ ¼å¼åŒ–æ—¥ï¿½? */
function formatDate(date) {
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const days = Math.floor(diff / (24 * 60 * 60 * 1000));

  if (days === 0) {
    return date.toLocaleTimeString();
  } else if (days === 1) {
    return 'æ˜¨å¤©';
  } else if (days < 7) {
    return \`\${days}å¤©å‰\`;
  } else if (days < 30) {
    return \`\${Math.floor(days / 7)}å‘¨å‰\`;
  } else {
    return \`\${Math.floor(days / 30)}ä¸ªæœˆå‰\`;
  }
}

/**
 * è·å–CLIå›¾æ ‡
 */
function getCLIIcon(cliType) {
  const icons = {
    'claude': 'ğŸŸ¢',
    'gemini': 'ğŸ”µ',
    'qwen': 'ğŸŸ¡',
    'iflow': 'ğŸ”´',
    'codebuddy': 'ğŸŸ£',
    'codex': 'ğŸŸª',
    'qodercli': 'ğŸŸ '
  };
  return icons[cliType] || 'ğŸ”¹';
}

/**
 * ç”Ÿæˆå»ºè®®
 */
function generateSuggestions(sessions, query) {
  const suggestions = [];

  if (sessions.length > 0) {
    suggestions.push('/history --format context');
    suggestions.push('/history --format timeline');

    if (sessions[0].cliType) {
      suggestions.push(\`/history --cli \${sessions[0].cliType}\`);
    }
  }

  suggestions.push('/history --search "react"');
  suggestions.push('/history --today');

  return suggestions.slice(0, 5);
}

// å¯¼å‡ºå¤„ç†ï¿½?module.exports = {
  handleHistoryCommand
};

// æ³¨å†Œåˆ°Claude CLI
if (typeof global !== 'undefined' && global.claudeCLI) {
  global.claudeCLI.addSlashCommand('/history', handleHistoryCommand);
}
`;
  }

  /**
   * Gemini CLI é›†æˆæ¨¡æ¿
   */
  private generateGeminiTemplate(options: TemplateOptions): string {
    const { projectPath, config } = options;

    // Embed the core functionality directly in the generated file
    return `// Gemini CLI ResumeSession Integration
// Auto-generated by ResumeSession v${config.version}
// Project: ${projectPath}

const fs = require('fs');
const path = require('path');
const os = require('os');

// Embedded ResumeSession Core Functionality

class SessionScanner {
  scanSessions(cliType, sessionsPath, projectPath) {
    const sessions = [];

    if (!sessionsPath || !projectPath) {
      return sessions;
    }

    try {
      if (!fs.existsSync(sessionsPath)) {
        return sessions;
      }

      const files = fs.readdirSync(sessionsPath);
      for (const file of files) {
        if (file.endsWith('.json') || file.endsWith('.session')) {
          try {
            const filePath = path.join(sessionsPath, file);
            const content = fs.readFileSync(filePath, 'utf8');
            const sessionData = JSON.parse(content);

            // Check if session belongs to current project
            if (this.isProjectSession(sessionData, projectPath)) {
              sessions.push({
                cliType,
                sessionId: sessionData.id || sessionData.sessionId || file.replace(/\\.(json|session)$/, ''),
                title: sessionData.title || sessionData.topic || 'Untitled',
                content: this.extractContent(sessionData),
                updatedAt: new Date(sessionData.updatedAt || sessionData.timestamp || fs.statSync(filePath).mtime),
                messageCount: sessionData.messageCount || this.countMessages(sessionData),
                projectPath
              });
            }
          } catch (error) {
            // Skip invalid files, continue with others
            console.warn(\`Warning: Could not parse session file \${file}:\`, error.message);
          }
        }
      }
    } catch (error) {
      console.warn(\`Warning: Could not scan \${cliType} sessions at \${sessionsPath}:\`, error.message);
    }

    return sessions;
  }

  scanAllCLISessions(projectPath) {
    const allSessions = [];
    const cliPaths = this.getCLISessionPaths();

    for (const [cliType, sessionsPath] of Object.entries(cliPaths)) {
      const sessions = this.scanSessions(cliType, sessionsPath, projectPath);
      allSessions.push(...sessions);
    }

    return allSessions;
  }

  getCLISessionPaths() {
    const homeDir = os.homedir();

    return {
      claude: path.join(homeDir, '.claude', 'sessions'),
      gemini: path.join(homeDir, '.gemini', 'sessions'),
      qwen: path.join(homeDir, '.qwen', 'sessions'),
      iflow: path.join(homeDir, '.iflow', 'stigmergy', 'sessions'),
      codebuddy: path.join(homeDir, '.codebuddy', 'sessions'),
      qodercli: path.join(homeDir, '.qodercli', 'sessions'),
      codex: path.join(homeDir, '.codex', 'sessions')
    };
  }

  isProjectSession(session, projectPath) {
    const sessionProject = session.projectPath || session.workingDirectory;
    if (!sessionProject) return true; // If no project path specified, assume it belongs

    return sessionProject === projectPath ||
           sessionProject.startsWith(projectPath) ||
           projectPath.startsWith(sessionProject);
  }

  extractContent(sessionData) {
    if (sessionData.content) {
      return sessionData.content;
    }

    if (sessionData.messages) {
      return sessionData.messages
        .map(msg => msg.content || msg.text || '')
        .join(' ');
    }

    if (Array.isArray(sessionData)) {
      return sessionData
        .map(item => item.content || item.text || '')
        .join(' ');
    }

    return '';
  }

  countMessages(sessionData) {
    if (sessionData.messages) {
      return Array.isArray(sessionData.messages) ? sessionData.messages.length : 0;
    }

    if (Array.isArray(sessionData)) {
      return sessionData.length;
    }

    return 0;
  }
}

class SessionFilter {
  filterByCLI(sessions, cliType) {
    if (!cliType) return sessions;
    return sessions.filter(session => session.cliType === cliType);
  }

  filterBySearch(sessions, searchTerm) {
    if (!searchTerm) return sessions;

    const lowerSearch = searchTerm.toLowerCase();
    return sessions.filter(session =>
      session.title.toLowerCase().includes(lowerSearch) ||
      session.content.toLowerCase().includes(lowerSearch)
    );
  }

  filterByDateRange(sessions, timeRange = 'all') {
    if (timeRange === 'all') return sessions;

    const now = new Date();
    return sessions.filter(session => {
      const sessionDate = new Date(session.updatedAt);

      switch (timeRange) {
        case 'today':
          return sessionDate.toDateString() === now.toDateString();
        case 'week':
          const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          return sessionDate >= weekAgo;
        case 'month':
          const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          return sessionDate >= monthAgo;
        default:
          return true;
      }
    });
  }

  sortByDate(sessions) {
    return [...sessions].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
  }

  filterByProject(sessions, projectPath) {
    return sessions.filter(session => session.projectPath === projectPath);
  }

  applyFilters(sessions, options, projectPath) {
    let filteredSessions = [...sessions];

    // Apply project filter
    filteredSessions = this.filterByProject(filteredSessions, projectPath);

    // Apply CLI filter
    if (options.cli) {
      filteredSessions = this.filterByCLI(filteredSessions, options.cli);
    }

    // Apply search filter
    if (options.search) {
      filteredSessions = this.filterBySearch(filteredSessions, options.search);
    }

    // Apply date range filter
    if (options.timeRange) {
      filteredSessions = this.filterByDateRange(filteredSessions, options.timeRange);
    }

    // Sort by date (newest first)
    filteredSessions = this.sortByDate(filteredSessions);

    // Apply limit
    if (options.limit && options.limit > 0) {
      filteredSessions = filteredSessions.slice(0, options.limit);
    }

    return filteredSessions;
  }
}

class HistoryFormatter {
  formatSummary(sessions, context) {
    if (sessions.length === 0) {
      return \`ostringstream å½“å‰é¡¹ç›®æš‚æ— å†å²ä¼šè¯\\n\\nğŸ’¡ **æç¤º:** å°è¯•: /history --search <å…³é”®ï¿½? æŸ¥æ‰¾å…¶ä»–CLIå·¥å…·çš„ä¼šè¯\`;
    }

    let response = \`ğŸ“ **é¡¹ç›®å†å²ä¼šè¯**\\n\\nğŸ“Š å…±æ‰¾ï¿½?\${sessions.length} ä¸ªä¼šè¯\\n\\n\`;

    // Group by CLI
    const byCLI = {};
    sessions.forEach(session => {
      if (!byCLI[session.cliType]) byCLI[session.cliType] = [];
      byCLI[session.cliType].push(session);
    });

    Object.entries(byCLI).forEach(([cli, cliSessions]) => {
      const icon = this.getCLIIcon(cli);
      response += \`\${icon} **\${cli.toUpperCase()}** (\${cliSessions.length}ï¿½?\\n\`;

      cliSessions.slice(0, 3).forEach((session, i) => {
        const date = this.formatDate(session.updatedAt);
        const title = session.title.substring(0, 50);
        response += \`   \${i + 1}. \${title}...\\n\`;
        response += \`      ğŸ“… \${date} ï¿½?ğŸ’¬ \${session.messageCount}æ¡æ¶ˆæ¯\\n\`;
      });

      if (cliSessions.length > 3) {
        response += \`   ... è¿˜æœ‰ \${cliSessions.length - 3} ä¸ªä¼šè¯\\n\`;
      }
      response += '\\n';
    });

    response += \`ğŸ’¡ **ä½¿ç”¨æ–¹æ³•:**\\n\`;
    response += \`ï¿½?'/history --cli <å·¥å…·>' - æŸ¥çœ‹ç‰¹å®šCLI\\n\`;
    response += \`ï¿½?'/history --search <å…³é”®ï¿½?' - æœç´¢å†…å®¹\\n\`;
    response += \`ï¿½?'/history --format timeline' - æ—¶é—´çº¿è§†å›¾\`;

    return response;
  }

  formatTimeline(sessions) {
    if (sessions.length === 0) {
      return 'ostringstream æš‚æ— ä¼šè¯æ—¶é—´çº¿ï¿½?;
    }

    let response = \`ï¿½?**æ—¶é—´çº¿è§†ï¿½?*\\n\\n\`;

    sessions.forEach((session, index) => {
      const date = this.formatDate(session.updatedAt);
      const cliIcon = this.getCLIIcon(session.cliType);

      response += \`\${index + 1}. \${cliIcon} \${session.title}\\n\`;
      response += \`   ğŸ“… \${date} ï¿½?ğŸ’¬ \${session.messageCount}æ¡æ¶ˆæ¯\\n\`;
      response += \`   ğŸ”‘ \${session.cliType}:\${session.sessionId}\\n\\n\`;
    });

    return response;
  }

  formatDetailed(sessions) {
    if (sessions.length === 0) {
      return 'ostringstream æš‚æ— è¯¦ç»†ä¼šè¯ä¿¡æ¯ï¿½?;
    }

    let response = \`ğŸ“‹ **è¯¦ç»†è§†å›¾**\\n\\n\`;

    sessions.forEach((session, index) => {
      const cliIcon = this.getCLIIcon(session.cliType);
      const date = session.updatedAt.toLocaleString();

      response += \`\${index + 1}. \${cliIcon} **\${session.title}**\\n\`;
      response += \`   ğŸ“… \${date}\\n\`;
      response += \`   ğŸ”§ CLI: \${session.cliType}\\n\`;
      response += \`   ğŸ’¬ æ¶ˆæ¯ï¿½? \${session.messageCount}\\n\`;
      response += \`   ğŸ†” ä¼šè¯ID: '\${session.sessionId}'\\n\\n\`;
    });

    return response;
  }

  formatContext(session) {
    if (!session) {
      return \`ostringstream æš‚æ— å¯æ¢å¤çš„ä¸Šä¸‹æ–‡ã€‚\`;
    }

    let response = \`ğŸ”„ **ä¸Šä¸‹æ–‡æ¢ï¿½?*\\n\\n\`;
    response += \`ğŸ“… ä¼šè¯æ—¶é—´: \${session.updatedAt.toLocaleString()}\\n\`;
    response += \`ğŸ”§ æ¥æºCLI: \${session.cliType}\\n\`;
    response += \`ğŸ’¬ æ¶ˆæ¯ï¿½? \${session.messageCount}\\n\`;
    response += \`ğŸ†” ä¼šè¯ID: \${session.sessionId}\\n\\n\`;
    response += \`---\\n\\n\`;
    response += \`**ä¸Šæ¬¡è®¨è®ºå†…å®¹:**\\n\`;
    response += session.content.substring(0, 500);
    if (session.content.length > 500) {
      response += \`...\`;
    }

    return response;
  }

  getCLIIcon(cliType) {
    const icons = {
      'claude': 'ğŸŸ¢',
      'gemini': 'ğŸ”µ',
      'qwen': 'ğŸŸ¡',
      'iflow': 'ğŸ”´',
      'codebuddy': 'ğŸŸ£',
      'codex': 'ğŸŸª',
      'qodercli': 'ğŸŸ '
    };
    return icons[cliType] || 'ğŸ”¹';
  }

  formatDate(date) {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const days = Math.floor(diff / (24 * 60 * 60 * 1000));

    if (days === 0) {
      return date.toLocaleTimeString();
    } else if (days === 1) {
      return 'æ˜¨å¤©';
    } else if (days < 7) {
      return \`\${days}å¤©å‰\`;
    } else if (days < 30) {
      return \`\${Math.floor(days / 7)}å‘¨å‰\`;
    } else {
      return \`\${Math.floor(days / 30)}ä¸ªæœˆå‰\`;
    }
  }
}

class HistoryQuery {
  constructor() {
    this.scanner = new SessionScanner();
    this.filter = new SessionFilter();
    this.formatter = new HistoryFormatter();
  }

  queryHistory(options, projectPath) {
    try {
      // Scan all CLI sessions
      const allSessions = this.scanner.scanAllCLISessions(projectPath);

      // Apply filters
      const filteredSessions = this.filter.applyFilters(allSessions, options, projectPath);

      // Format response based on format option
      let response;
      switch (options.format) {
        case 'timeline':
          response = this.formatter.formatTimeline(filteredSessions);
          break;
        case 'detailed':
          response = this.formatter.formatDetailed(filteredSessions);
          break;
        case 'context':
          response = this.formatter.formatContext(filteredSessions[0] || null);
          break;
        case 'summary':
        default:
          response = this.formatter.formatSummary(filteredSessions);
          break;
      }

      // Generate suggestions
      const suggestions = this.generateSuggestions(filteredSessions, options);

      return {
        response,
        suggestions
      };
    } catch (error) {
      return {
        response: \`ï¿½?å†å²æŸ¥è¯¢å¤±è´¥: \${error.message}\`,
        suggestions: ['/history --help']
      };
    }
  }

  generateSuggestions(sessions, query) {
    const suggestions = [];

    if (sessions.length > 0) {
      suggestions.push('/history --format context');
      suggestions.push('/history --format timeline');

      if (sessions[0]?.cliType) {
        suggestions.push(\`/history --cli \${sessions[0].cliType}\`);
      }
    }

    suggestions.push('/history --search "react"');
    suggestions.push('/history --today');

    return suggestions.slice(0, 5);
  }
}

class GeminiHistoryHandler {
  constructor() {
    this.historyQuery = new HistoryQuery();
  }

  async handleCommand(input, session) {
    if (!input.startsWith('/history')) return null;

    try {
      // Build query options from input
      const options = this.buildQuery(input);

      const result = await this.historyQuery.queryHistory(options, '${projectPath}');

      return {
        text: result.response,
        continue: true,
        suggestions: result.suggestions
      };
    } catch (error) {
      return {
        text: \`ï¿½?History command failed: \${error.message}\`,
        continue: true,
        suggestions: []
      };
    }
  }

  buildQuery(input) {
    const options = {
      limit: 10,
      format: 'summary',
      timeRange: 'all',
      cli: null,
      search: null
    };

    const cleanInput = input.replace(/^\\/history\\s*/i, '').trim();
    const parts = cleanInput.split(/\\s+/).filter(p => p.length > 0);

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i].toLowerCase();

      if (part === '--cli' && i + 1 < parts.length) {
        options.cli = parts[++i];
      } else if (part === '--search' && i + 1 < parts.length) {
        options.search = parts[++i];
      } else if (part === '--limit' && i + 1 < parts.length) {
        options.limit = parseInt(parts[++i]);
      } else if (part === '--format' && i + 1 < parts.length) {
        const format = parts[++i]?.toLowerCase();
        if (['summary', 'timeline', 'detailed', 'context'].includes(format)) {
          options.format = format;
        }
      } else if (part === '--today') {
        options.timeRange = 'today';
      } else if (part === '--week') {
        options.timeRange = 'week';
      } else if (part === '--month') {
        options.timeRange = 'month';
      } else if (!part.startsWith('--') && !options.search) {
        options.search = part;
      }
    }

    return options;
  }
}
`;
  }

  /**
   * Qwen CLI é›†æˆæ¨¡æ¿
   */
  private generateQwenTemplate(options: TemplateOptions): string {
    return `// Qwen CLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const qwenHistory = {
  async processSlashCommand(input, context) {
    if (!input.startsWith('/history')) return null;

    // å®ç°ä¸Claudeç±»ä¼¼çš„é€»è¾‘
    return {
      response: 'ğŸ” Qwen CLI ResumeSession history integration...',
      suggestions: ['/history --help']
    };
  }
};

if (typeof qwenCLI !== 'undefined') {
  qwenCLI.addSlashCommand('history', qwenHistory.processSlashCommand);
}

module.exports = qwenHistory;
`;
  }

  /**
   * IFlow CLI é›†æˆæ¨¡æ¿
   */
  private generateIFlowTemplate(options: TemplateOptions): string {
    return `// IFlow CLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const stigmergy = require('stigmergy-cli');

const historyCommand = {
  name: 'history',
  description: 'Show cross-CLI project history',
  async execute(args, workflow) {
    // å®ç°historyå‘½ä»¤é€»è¾‘
    return 'ğŸ” IFlow CLI ResumeSession history integration...';
  }
};

// æ³¨å†Œåˆ°stigmergy
if (stigmergy) {
  stigmergy.addCommand(historyCommand);
}

module.exports = historyCommand;
`;
  }

  /**
   * CodeBuddy CLI é›†æˆæ¨¡æ¿
   */
  private generateCodeBuddyTemplate(options: TemplateOptions): string {
    return `// CodeBuddy CLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const codebuddyHistory = {
  async handleSlashCommand(input, context) {
    if (!input.startsWith('/history')) return null;

    // å®ç°historyé€»è¾‘
    return {
      text: 'ğŸ” CodeBuddy CLI ResumeSession history integration...',
      suggestions: ['/history --help']
    };
  }
};

if (typeof codebuddy !== 'undefined') {
  codebuddy.addSlashCommand('history', codebuddyHistory.handleSlashCommand);
}

module.exports = codebuddyHistory;
`;
  }

  /**
   * QoderCLI é›†æˆæ¨¡æ¿
   */
  private generateQoderCLITemplate(options: TemplateOptions): string {
    return `// QoderCLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const qoderHistory = {
  name: 'history',
  handler: async (input, context) => {
    if (!input.startsWith('/history')) return null;

    return 'ğŸ” QoderCLI ResumeSession history integration...';
  }
};

if (typeof qoderCLI !== 'undefined') {
  qoderCLI.registerCommand(qoderHistory);
}

module.exports = qoderHistory;
`;
  }

  /**
   * Codex CLI é›†æˆæ¨¡æ¿
   */
  private generateCodexTemplate(options: TemplateOptions): string {
    return `// Codex CLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const codexHistory = {
  processCommand: async (input, session) => {
    if (!input.startsWith('/history')) return null;

    // å®ç°historyé€»è¾‘
    return {
      response: 'ğŸ” Codex CLI ResumeSession history integration...',
      suggestions: ['/history --help']
    };
  }
};

if (typeof codex !== 'undefined') {
  codex.addCommand('history', codexHistory.processCommand);
}

module.exports = codexHistory;
`;
  }

  /**
   * Kode CLI é›†æˆæ¨¡æ¿
   */
  private generateKodeTemplate(options: TemplateOptions): string {
    return `// Kode CLI ResumeSession Integration
// Auto-generated by ResumeSession v${options.config.version}

const kodeHistory = {
  async handleCommand(input, context) {
    if (!input.startsWith('/stigmergy-resume') && !input.startsWith('/history') && !input.startsWith('/resume')) return null;

    // å®ç°historyé€»è¾‘
    return {
      response: 'ğŸ” Kode CLI ResumeSession history integration...',
      suggestions: ['/stigmergy-resume --help']
    };
  }
};

if (typeof kode !== 'undefined') {
  kode.addExtension('history', kodeHistory.handleCommand);
}

module.exports = kodeHistory;
`;
  }
}
