import { CodeGenerator } from '../src/utils/CodeGenerator';
import { existsSync, readFileSync, unlinkSync, mkdirSync, rmdirSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

describe('CodeGenerator Real Environment Tests', () => {
  let codeGenerator: CodeGenerator;
  const testProjectDir = join(homedir(), '.resumesession-codegen-test');
  const testConfig = {
    version: '1.0.0',
    author: 'ResumeSession Test',
    description: 'Test configuration for CodeGenerator'
  };

  beforeAll(async () => {
    codeGenerator = new CodeGenerator();

    // 创建测试项目目录
    if (!existsSync(testProjectDir)) {
      mkdirSync(testProjectDir, { recursive: true });
    }
  });

  afterAll(async () => {
    // 清理测试文件和目录
    const cliTypes = ['claude', 'gemini', 'qwen', 'iflow', 'codebuddy', 'qodercli', 'codex'];
    
    for (const cliType of cliTypes) {
      const integrationPath = getIntegrationPath(cliType, testProjectDir);
      
      if (existsSync(integrationPath)) {
        unlinkSync(integrationPath);
      }

      // 清理目录
      const parentDir = join(integrationPath, '..');
      try {
        if (existsSync(parentDir)) {
          rmdirSync(parentDir);
        }
      } catch (error) {
        // 忽略目录非空错误
      }
    }

    // 清理项目根目录
    try {
      if (existsSync(testProjectDir)) {
        rmdirSync(testProjectDir);
      }
    } catch (error) {
      // 忽略目录非空错误
    }
  });

  function getIntegrationPath(cliType: string, projectPath: string): string {
    const paths = {
      claude: join(projectPath, '.claude', 'hooks', 'resumesession-history.js'),
      gemini: join(projectPath, '.gemini', 'extensions', 'resumesession-history.js'),
      qwen: join(projectPath, '.qwen', 'plugins', 'resumesession-history.js'),
      iflow: join(projectPath, 'stigmergy', 'commands', 'history.js'),
      codebuddy: join(projectPath, '.codebuddy', 'integrations', 'resumesession.js'),
      qodercli: join(projectPath, '.qodercli', 'extensions', 'history.js'),
      codex: join(projectPath, '.codex', 'plugins', 'resumesession-history.js')
    };

    return paths[cliType as keyof typeof paths] || join(projectPath, '.resumesession', `${cliType}-integration.js`);
  }

  describe('generateIntegration', () => {
    it('should generate Claude CLI integration code', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证生成的代码包含必要元素
      expect(content).toContain('Claude CLI ResumeSession Integration');
      expect(content).toContain('Auto-generated by ResumeSession');
      expect(content).toContain(testProjectDir);
      expect(content).toContain('handleHistoryCommand');
      expect(content).toContain('buildQuery');
      expect(content).toContain('formatResponse');
      expect(content).toContain('module.exports');
    });

    it('should generate Gemini CLI integration code', async () => {
      await codeGenerator.generateIntegration('gemini', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('gemini', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证Gemini特定的代码结构
      expect(content).toContain('Gemini CLI ResumeSession Integration');
      expect(content).toContain('GeminiHistoryHandler');
      expect(content).toContain('handleCommand');
      expect(content).toContain('SessionScanner');
      expect(content).toContain('SessionFilter');
      expect(content).toContain('HistoryFormatter');
      expect(content).toContain('HistoryQuery');
    });

    it('should generate IFlow CLI integration code', async () => {
      await codeGenerator.generateIntegration('iflow', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('iflow', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证IFlow特定的代码结构
      expect(content).toContain('IFlow CLI ResumeSession Integration');
      expect(content).toContain('stigmergy-cli');
      expect(content).toContain('addCommand');
      expect(content).toContain('historyCommand');
    });

    it('should generate Qwen CLI integration code', async () => {
      await codeGenerator.generateIntegration('qwen', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('qwen', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证Qwen特定的代码结构
      expect(content).toContain('Qwen CLI ResumeSession Integration');
      expect(content).toContain('qwenHistory');
      expect(content).toContain('processSlashCommand');
      expect(content).toContain('qwenCLI');
    });

    it('should generate CodeBuddy CLI integration code', async () => {
      await codeGenerator.generateIntegration('codebuddy', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('codebuddy', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证CodeBuddy特定的代码结构
      expect(content).toContain('CodeBuddy CLI ResumeSession Integration');
      expect(content).toContain('codebuddyHistory');
      expect(content).toContain('handleSlashCommand');
      expect(content).toContain('codebuddy');
    });

    it('should generate QoderCLI integration code', async () => {
      await codeGenerator.generateIntegration('qodercli', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('qodercli', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证QoderCLI特定的代码结构
      expect(content).toContain('QoderCLI ResumeSession Integration');
      expect(content).toContain('qoderHistory');
      expect(content).toContain('registerCommand');
      expect(content).toContain('qoderCLI');
    });

    it('should generate Codex CLI integration code', async () => {
      await codeGenerator.generateIntegration('codex', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('codex', testProjectDir);
      expect(existsSync(integrationPath)).toBe(true);

      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证Codex特定的代码结构
      expect(content).toContain('Codex CLI ResumeSession Integration');
      expect(content).toContain('codexHistory');
      expect(content).toContain('processCommand');
      expect(content).toContain('codex');
    });

    it('should throw error for unsupported CLI type', async () => {
      await expect(
        codeGenerator.generateIntegration('unsupported-cli', testProjectDir, testConfig)
      ).rejects.toThrow('Unsupported CLI type: unsupported-cli');
    });
  });

  describe('File System Operations', () => {
    it('should create necessary directories', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const hooksDir = join(testProjectDir, '.claude', 'hooks');
      expect(existsSync(hooksDir)).toBe(true);
    });

    it('should handle nested directory creation', async () => {
      await codeGenerator.generateIntegration('iflow', testProjectDir, testConfig);
      
      const commandsDir = join(testProjectDir, 'stigmergy', 'commands');
      expect(existsSync(commandsDir)).toBe(true);
    });

    it('should overwrite existing files', async () => {
      // 第一次生成
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const firstContent = readFileSync(integrationPath, 'utf8');
      
      // 修改配置后再次生成
      const newConfig = { ...testConfig, version: '2.0.0' };
      await codeGenerator.generateIntegration('claude', testProjectDir, newConfig);
      
      const secondContent = readFileSync(integrationPath, 'utf8');
      
      // 验证文件内容已更新
      expect(secondContent).not.toBe(firstContent);
      expect(secondContent).toContain('2.0.0');
    });
  });

  describe('Generated Code Quality', () => {
    it('should generate valid JavaScript syntax', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证JavaScript语法
      expect(() => {
        // 简单的语法检查
        new Function(content);
      }).not.toThrow();
    });

    it('should include proper error handling', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      expect(content).toContain('try');
      expect(content).toContain('catch');
      expect(content).toContain('error');
    });

    it('should include proper module exports', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      expect(content).toContain('module.exports');
    });

    it('should embed configuration information', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      expect(content).toContain(testConfig.version);
      expect(content).toContain(testProjectDir);
    });
  });

  describe('Integration Code Functionality', () => {
    it('should generate Claude integration with complete functionality', async () => {
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证关键功能函数存在
      expect(content).toContain('handleHistoryCommand');
      expect(content).toContain('buildQuery');
      expect(content).toContain('scanProjectSessions');
      expect(content).toContain('formatResponse');
      expect(content).toContain('formatSummary');
      expect(content).toContain('formatTimeline');
      expect(content).toContain('formatDetailed');
      expect(content).toContain('formatContext');
      expect(content).toContain('generateSuggestions');
    });

    it('should generate Gemini integration with embedded core functionality', async () => {
      await codeGenerator.generateIntegration('gemini', testProjectDir, testConfig);
      
      const integrationPath = getIntegrationPath('gemini', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      // 验证嵌入的核心类
      expect(content).toContain('class SessionScanner');
      expect(content).toContain('class SessionFilter');
      expect(content).toContain('class HistoryFormatter');
      expect(content).toContain('class HistoryQuery');
      expect(content).toContain('class GeminiHistoryHandler');
      
      // 验证核心方法
      expect(content).toContain('scanSessions');
      expect(content).toContain('scanAllCLISessions');
      expect(content).toContain('getCLISessionPaths');
      expect(content).toContain('isProjectSession');
      expect(content).toContain('extractContent');
      expect(content).toContain('countMessages');
    });

    it('should generate proper CLI registration code', async () => {
      const cliTypes = ['claude', 'gemini', 'qwen', 'iflow', 'codebuddy', 'qodercli', 'codex'];
      
      for (const cliType of cliTypes) {
        await codeGenerator.generateIntegration(cliType, testProjectDir, testConfig);
        
        const integrationPath = getIntegrationPath(cliType, testProjectDir);
        const content = readFileSync(integrationPath, 'utf8');
        
        // 验证每种CLI的注册方式
        switch (cliType) {
          case 'claude':
            expect(content).toContain('global.claudeCLI.addSlashCommand');
            break;
          case 'gemini':
            expect(content).toContain('geminiCLI.addCommandHandler');
            break;
          case 'qwen':
            expect(content).toContain('qwenCLI.addSlashCommand');
            break;
          case 'iflow':
            expect(content).toContain('stigmergy.addCommand');
            break;
          case 'codebuddy':
            expect(content).toContain('codebuddy.addSlashCommand');
            break;
          case 'qodercli':
            expect(content).toContain('qoderCLI.registerCommand');
            break;
          case 'codex':
            expect(content).toContain('codex.addCommand');
            break;
        }
      }
    });
  });

  describe('Performance Tests', () => {
    it('should generate integration code efficiently', async () => {
      const startTime = Date.now();
      
      await codeGenerator.generateIntegration('claude', testProjectDir, testConfig);
      
      const endTime = Date.now();
      expect(endTime - startTime).toBeLessThan(1000);
    });

    it('should handle multiple generations', async () => {
      const startTime = Date.now();
      
      const promises = [
        codeGenerator.generateIntegration('claude', testProjectDir, testConfig),
        codeGenerator.generateIntegration('gemini', testProjectDir, testConfig),
        codeGenerator.generateIntegration('qwen', testProjectDir, testConfig)
      ];
      
      await Promise.all(promises);
      
      const endTime = Date.now();
      expect(endTime - startTime).toBeLessThan(3000);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid project path gracefully', async () => {
      const invalidPath = '/invalid/path/that/does/not/exist';
      
      // 应该能够创建目录并生成文件
      await expect(
        codeGenerator.generateIntegration('claude', invalidPath, testConfig)
      ).resolves.not.toThrow();
    });

    it('should handle file system permission errors', async () => {
      // 使用只读目录路径（如果存在）
      const readOnlyPath = '/root';
      
      // 应该抛出错误或处理权限问题
      await expect(
        codeGenerator.generateIntegration('claude', readOnlyPath, testConfig)
      ).rejects.toThrow();
    });
  });

  describe('Configuration Integration', () => {
    it('should use configuration in generated code', async () => {
      const customConfig = {
        version: '3.2.1',
        author: 'Custom Author',
        description: 'Custom description',
        customField: 'custom value'
      };
      
      await codeGenerator.generateIntegration('claude', testProjectDir, customConfig);
      
      const integrationPath = getIntegrationPath('claude', testProjectDir);
      const content = readFileSync(integrationPath, 'utf8');
      
      expect(content).toContain(customConfig.version);
      expect(content).toContain(customConfig.author);
    });

    it('should handle empty configuration', async () => {
      const emptyConfig = {};
      
      await expect(
        codeGenerator.generateIntegration('claude', testProjectDir, emptyConfig)
      ).resolves.not.toThrow();
    });
  });
});