// CodeBuddy CLI ResumeSession Integration
// Auto-generated by ResumeSession v1.0.4
// Project: D:\stigmergy-CLI-Multi-Agents

const fs = require('fs');
const path = require('path');
const os = require('os');

// Load shared path configuration
const pathConfigLoader = require(path.join(__dirname, 'path-config-loader.js'));

class SessionScanner {
  scanSessions(cliType, sessionsPath, projectPath) {
    const sessions = [];
    if (!sessionsPath || !projectPath) return sessions;

    try {
      // For CodeBuddy: single history.jsonl file
      if (cliType === 'codebuddy') {
        const historyFile = path.join(sessionsPath, 'history.jsonl');
        if (fs.existsSync(historyFile)) {
          return this.scanCodeBuddyHistory(historyFile, projectPath);
        }
        return sessions;
      }

      if (!fs.existsSync(sessionsPath)) return sessions;
      return this.scanSessionFiles(cliType, sessionsPath, projectPath);
    } catch (error) {
      console.warn(`Warning: Could not scan ${cliType} sessions:`, error.message);
    }

    return sessions;
  }

  scanCodeBuddyHistory(historyFile, projectPath) {
    const sessions = [];

    try {
      const content = fs.readFileSync(historyFile, 'utf8');
      const lines = content.trim().split('\n').filter(line => line.trim());
      
      // Group messages by sessionId
      const sessionMap = new Map();
      
      for (const line of lines) {
        try {
          const msg = JSON.parse(line);
          const sessionId = msg.sessionId || msg.conversationId || 'default';
          
          if (!sessionMap.has(sessionId)) {
            sessionMap.set(sessionId, []);
          }
          sessionMap.get(sessionId).push(msg);
        } catch (error) {
          continue;
        }
      }

      // Convert to session objects
      for (const [sessionId, messages] of sessionMap.entries()) {
        if (messages.length === 0) continue;

        const firstMsg = messages[0];
        const lastMsg = messages[messages.length - 1];
        const firstUserMsg = messages.find(m => m.type === 'user' || m.role === 'user');

              let title = 'Untitled Session';

              if (firstUserMsg) {

                let content = firstUserMsg.content || '';

                if (typeof content === 'object') {

                  content = JSON.stringify(content);

                }

                if (typeof content === 'string' && content.trim()) {

                  title = content.substring(0, 100) || title;

                }

              } else if (firstUserMsg && firstUserMsg.message) {
          title = firstUserMsg.message.substring(0, 100) || title;
        }

        const sessionData = {
          sessionId: sessionId,
          title: title,
          messages: messages,
          timestamp: lastMsg.timestamp || lastMsg.createdAt || Date.now(),
          cwd: firstMsg.cwd || firstMsg.workingDirectory,
          projectPath: firstMsg.cwd || firstMsg.workingDirectory,
          messageCount: messages.filter(m => m.type === 'user' || m.type === 'assistant' || m.role === 'user' || m.role === 'assistant').length
        };

        if (this.isProjectSession(sessionData, projectPath)) {
          sessions.push({
            cliType: 'codebuddy',
            sessionId: sessionData.sessionId,
            title: sessionData.title,
            content: this.extractContent(sessionData),
            updatedAt: new Date(sessionData.timestamp),
            messageCount: sessionData.messageCount,
            projectPath
          });
        }
      }
    } catch (error) {
      console.warn(`Warning: Could not parse CodeBuddy history:`, error.message);
    }

    return sessions;
  }

  scanSessionFiles(cliType, sessionsPath, projectPath) {
    const sessions = [];

    try {
      const files = fs.readdirSync(sessionsPath);
      for (const file of files) {
        if (file.endsWith('.jsonl')) {
          try {
            const filePath = path.join(sessionsPath, file);
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.trim().split('\n').filter(line => line.trim());
            const messages = lines.map(line => JSON.parse(line));

            if (messages.length === 0) continue;

            const firstMsg = messages[0];
            const lastMsg = messages[messages.length - 1];
            const firstUserMsg = messages.find(m => m.type === 'user' && m.message);

            let title = 'Untitled Session';
            if (firstUserMsg && firstUserMsg.message) {
              title = firstUserMsg.message.substring(0, 100) || title;
            }

            const sessionData = {
              sessionId: firstMsg.sessionId || file.replace('.jsonl', ''),
              title: title,
              messages: messages,
              timestamp: lastMsg.timestamp,
              cwd: firstMsg.cwd,
              projectPath: firstMsg.cwd,
              messageCount: messages.filter(m => m.type === 'user' || m.type === 'assistant').length
            };

            if (this.isProjectSession(sessionData, projectPath)) {
              sessions.push({
                cliType,
                sessionId: sessionData.sessionId,
                title: sessionData.title,
                content: this.extractContent(sessionData),
                updatedAt: new Date(sessionData.timestamp),
                messageCount: sessionData.messageCount,
                projectPath
              });
            }
          } catch (error) {
            console.warn(`Warning: Could not parse ${file}:`, error.message);
          }
        }
      }
    } catch (error) {
      console.warn(`Warning: Could not scan files:`, error.message);
    }

    return sessions;
  }

  scanAllCLISessions(projectPath) {`n    const allSessions = [];`n    const cliPathsMap = pathConfigLoader.getAllCLISessionPaths();`n`n    for (const [cliType, sessionsPaths] of Object.entries(cliPathsMap)) {`n      for (const sessionsPath of sessionsPaths) {`n        const sessions = this.scanSessions(cliType, sessionsPath, projectPath);`n        allSessions.push(...sessions);`n      }`n    }`n`n    return allSessions;`n  }


  isProjectSession(session, projectPath) {
    const sessionProject = session.projectPath || session.cwd;
    if (!sessionProject) return true;

    return sessionProject === projectPath ||
           sessionProject.startsWith(projectPath) ||
           projectPath.startsWith(sessionProject);
  }

  extractContent(sessionData) {
    if (sessionData.messages) {
      return sessionData.messages
        .map(msg => {
          if (msg.content) return msg.content;
          if (msg.message) return msg.message;
          if (msg.text) return msg.text;
          return '';
        })
        .join(' ');
    }
    return '';
  }
}

class SessionFilter {
  applyFilters(sessions, options, projectPath) {
    let filtered = sessions.filter(s => s.projectPath === projectPath);

    if (options.cli) {
      filtered = filtered.filter(s => s.cliType === options.cli);
    }

    if (options.search) {
      const term = options.search.toLowerCase();
      filtered = filtered.filter(s =>
        s.title.toLowerCase().includes(term) ||
        s.content.toLowerCase().includes(term)
      );
    }

    filtered.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

    if (options.limit) {
      filtered = filtered.slice(0, options.limit);
    }

    return filtered;
  }
}

class HistoryFormatter {
  formatSummary(sessions) {
    if (sessions.length === 0) {
      return 'ğŸ“­ å½“å‰é¡¹ç›®æš‚æ— å†å²ä¼šè¯\n\nğŸ’¡ å°è¯•: /history --search <å…³é”®ï¿½?';
    }

    let response = `ğŸ“ **é¡¹ç›®å†å²ä¼šè¯**\n\nğŸ“Š ï¿½?${sessions.length} ä¸ª\n\n`;

    const byCLI = {};
    sessions.forEach(s => {
      if (!byCLI[s.cliType]) byCLI[s.cliType] = [];
      byCLI[s.cliType].push(s);
    });

    Object.entries(byCLI).forEach(([cli, cliSessions]) => {
      const icon = this.getCLIIcon(cli);
      response += `${icon} **${cli.toUpperCase()}** (${cliSessions.length}ï¿½?\n`;
      cliSessions.slice(0, 3).forEach((s, i) => {
        response += `   ${i + 1}. ${s.title.substring(0, 50)}...\n`;
        response += `      ğŸ’¬ ${s.messageCount}æ¡æ¶ˆæ¯\n`;
      });
      if (cliSessions.length > 3) {
        response += `   ... è¿˜æœ‰ ${cliSessions.length - 3} ä¸ª\n`;
      }
      response += '\n';
    });

    response += 'ğŸ’¡ **ä½¿ç”¨:** /history --cli <å·¥å…·> | --search <ï¿½? | --format timeline';
    return response;
  }

  formatTimeline(sessions) {
    if (sessions.length === 0) return 'ğŸ“­ æš‚æ— ä¼šè¯';
    let response = 'ï¿½?**æ—¶é—´ï¿½?*\n\n';
    sessions.forEach((s, i) => {
      const icon = this.getCLIIcon(s.cliType);
      response += `${i + 1}. ${icon} ${s.title}\n   ğŸ’¬ ${s.messageCount}æ¡\n\n`;
    });
    return response;
  }

  formatDetailed(sessions) {
    if (sessions.length === 0) return 'ğŸ“­ æš‚æ— ä¼šè¯';
    let response = 'ğŸ“‹ **è¯¦ç»†**\n\n';
    sessions.forEach((s, i) => {
      const icon = this.getCLIIcon(s.cliType);
      response += `${i + 1}. ${icon} **${s.title}**\n   ğŸ”§ ${s.cliType}\n   ğŸ’¬ ${s.messageCount}æ¡\n\n`;
    });
    return response;
  }

  formatContext(session) {
    if (!session) return 'ğŸ“­ æš‚æ— ä¸Šä¸‹ï¿½?;
    return `ğŸ”„ **ä¸Šä¸‹ï¿½?*\n\n${session.title}\nğŸ’¬ ${session.messageCount}æ¡æ¶ˆæ¯\n\n${session.content.substring(0, 500)}...`;
  }

  getCLIIcon(cliType) {
    const icons = {
      'claude': 'ğŸŸ¢',
      'gemini': 'ğŸ”µ',
      'qwen': 'ğŸŸ¡',
      'iflow': 'ğŸ”´',
      'codebuddy': 'ğŸŸ£',
      'codex': 'ğŸŸª',
      'qodercli': 'ğŸŸ '
    };
    return icons[cliType] || 'ğŸ”¹';
  }
}

class HistoryQuery {
  constructor() {
    this.scanner = new SessionScanner();
    this.filter = new SessionFilter();
    this.formatter = new HistoryFormatter();
  }

  queryHistory(options, projectPath) {
    try {
      const allSessions = this.scanner.scanAllCLISessions(projectPath);
      const filtered = this.filter.applyFilters(allSessions, options, projectPath);

      let response;
      switch (options.format) {
        case 'timeline':
          response = this.formatter.formatTimeline(filtered);
          break;
        case 'detailed':
          response = this.formatter.formatDetailed(filtered);
          break;
        case 'context':
          response = this.formatter.formatContext(filtered[0]);
          break;
        default:
          response = this.formatter.formatSummary(filtered);
      }

      return {
        response,
        suggestions: ['/history --format timeline', '/history --search <keyword>']
      };
    } catch (error) {
      return {
        response: `ï¿½?æŸ¥è¯¢å¤±è´¥: ${error.message}`,
        suggestions: []
      };
    }
  }
}

class CodeBuddyHistoryHandler {
  constructor() {
    this.historyQuery = new HistoryQuery();
  }

  async handleSlashCommand(input, context) {
    if (!input.startsWith('/history') && !input.startsWith('/stigmergy-history') && !input.startsWith('/stigmergy-resume')) return null;

    try {
      const options = this.buildQuery(input);
      const result = this.historyQuery.queryHistory(options, 'D:\stigmergy-CLI-Multi-Agents');

      return {
        text: result.response,
        suggestions: result.suggestions
      };
    } catch (error) {
      return {
        text: `ï¿½?å¤±è´¥: ${error.message}`,
        suggestions: []
      };
    }
  }

  buildQuery(input) {
    const options = {
      limit: 10,
      format: 'summary',
      timeRange: 'all',
      cli: null,
      search: null
    };

    const parts = input.replace(/^\/(stigmergy-resume|history|stigmergy-history)\s*/i, '').trim().split(/\s+/).filter(p => p.length > 0);

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i].toLowerCase();

      if (part === '--cli' && i + 1 < parts.length) {
        options.cli = parts[++i];
      } else if (part === '--search' && i + 1 < parts.length) {
        options.search = parts[++i];
      } else if (part === '--limit' && i + 1 < parts.length) {
        options.limit = parseInt(parts[++i]);
      } else if (part === '--format' && i + 1 < parts.length) {
        options.format = parts[++i];
      } else if (part === '--today') {
        options.timeRange = 'today';
      }
    }

    return options;
  }
}

const handler = new CodeBuddyHistoryHandler();

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { CodeBuddyHistoryHandler, handler };
}

if (typeof codebuddy !== 'undefined') {
  codebuddy.addSlashCommand('history', handler.handleSlashCommand.bind(handler));
}
