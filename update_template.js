#!/usr/bin/env node
/**
 * 更新HookDeploymentManager.js中的钩子模板
 */

const fs = require('fs');
const path = require('path');

const filePath = 'src/core/coordination/nodejs/HookDeploymentManager.js';

if (fs.existsSync(filePath)) {
  console.log('Reading HookDeploymentManager.js...');
  
  let content = fs.readFileSync(filePath, 'utf8');
  
  // 查找模板开始位置
  const templateStart = content.indexOf('generateNodeJsHookTemplate(cliName) {');
  if (templateStart === -1) {
    console.error('Template start not found');
    process.exit(1);
  }
  
  // 查找模板结束位置
  const templateEnd = content.indexOf('`;');
  if (templateEnd === -1) {
    console.error('Template end not found');
    process.exit(1);
  }
  
  // 提取模板内容
  const templateMatch = content.match(/return `([\s\S]*?)`;/);
  if (!templateMatch) {
    console.error('Template content not found');
    process.exit(1);
  }
  
  // 新的模板内容（包含中文模式）
  const newTemplate = `  generateNodeJsHookTemplate(cliName) {
    return \`#!/usr/bin/env node
/**
 * Node.js Hook for \${cliName.toUpperCase()}
 * Auto-generated by Stigmergy CLI Hook Deployment Manager
 */
const fs = require('fs');
const path = require('path');
class \${this.capitalize(cliName)}NodeJsHook {
  constructor() {
    this.cliName = '\${cliName}';
    this.hookDir = __dirname;
    this.logFile = path.join(this.hookDir, '\${cliName}_hook.log');
  }
  async onUserPrompt(prompt, context) {
    this.log('INFO', \`User prompt received: \${prompt}\`);
    // Check for cross-CLI requests
    const crossCLIRequest = this.detectCrossCLIRequest(prompt);
    if (crossCLIRequest) {
      return await this.handleCrossCLIRequest(crossCLIRequest, context);
    }
    // Default processing
    return null;
  }
  async onToolUse(toolName, toolArgs, context) {
    this.log('INFO', \`Tool use detected: \${toolName}\`);
    return null;
  }
  async onResponseGenerated(response, context) {
    this.log('INFO', 'Response generated');
    return null;
  }
  detectCrossCLIRequest(prompt) {
    // Enhanced pattern matching for cross-CLI requests
    const patterns = [
      /(?:use|call|ask)\\\\s+(\\\\w+)\\\\s+(?:to|for)\\\\s+(.+)$/i,
      /(?:please\\\\s+)?(?:use|call|ask)\\\\s+(\\\\w+)\\\\s+(.+)$/i,
      /(\\\\w+)[,\\\\s]+(?:please\\\\s+)?(?:help\\\\s+me\\\\s+)?(.+)$/i,
      /请用(\\\\w+)\\\\s*帮我(.+)$/i,
      /调用(\\\\w+)\\\\s*来(.+)$/i,
      /用(\\\\w+)\\\\s*帮我(.+)$/i,
      /(\\\\w+)，(.+)$/i,
      /让(\\\\w+)\\\\s*(.+)$/i
    ];
    
    for (const pattern of patterns) {
      const match = prompt.match(pattern);
      if (match && match.length >= 3) {
        const targetCLI = match[1].toLowerCase();
        const task = match[2];
        
        // Validate that the target CLI is supported
        const supportedCLIs = [
          'claude', 'gemini', 'qwen', 'iflow', 'qodercli', 'codebuddy', 'codex', 'copilot'
        ];
        
        if (supportedCLIs.includes(targetCLI)) {
          return {
            targetCLI: targetCLI,
            task: task,
            source: this.cliName
          };
        }
      }
    }
    
    return null;
  }
  async handleCrossCLIRequest(request, context) {
    this.log('INFO', \`Cross-CLI request detected: \${JSON.stringify(request)}\`);
    
    // Validate the request
    if (!request.targetCLI || !request.task) {
      this.log('ERROR', 'Invalid cross-CLI request: missing targetCLI or task');
      return \`[CROSS-CLI] Invalid request: missing targetCLI or task\`;
    }
    
    // Check if the target CLI is the same as the source
    if (request.targetCLI === this.cliName) {
      this.log('WARN', 'Cross-CLI request to self ignored');
      return \`[CROSS-CLI] Cannot call self (\${request.targetCLI})\`;
    }
    
    // Communicate with the coordination layer to execute the cross-CLI call
    try {
      // Dynamically load the CLCommunication module
      const modulePath = path.join(__dirname, '..', '..', '..', '..', 'src', 'core', 'coordination', 'nodejs', 'CLCommunication');
      const CLCommunication = require(modulePath);
      const communicator = new CLCommunication();
      
      const result = await communicator.executeTask(
        request.source, 
        request.targetCLI, 
        request.task, 
        context
      );
      
      if (result.success) {
        return \`[CROSS-CLI] Response from \${request.targetCLI}: \${result.output}\`;
      } else {
        return \`[CROSS-CLI] Error from \${request.targetCLI}: \${result.error}\`;
      }
    } catch (error) {
      this.log('ERROR', \`Failed to handle cross-CLI request: \${error.message}\`);
      return \`[CROSS-CLI] Failed to execute \${request.targetCLI}: \${error.message}\`;
    }
  }
  log(level, message) {
    const timestamp = new Date().toISOString();
    const logEntry = \`[\${timestamp}] [\${level}] [\${this.cliName.toUpperCase()}] \${message}\\\\n\`;
    
    try {
      fs.appendFileSync(this.logFile, logEntry);
    } catch (error) {
      console.error('Failed to write to log file:', error);
    }
  }
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
// Export the hook class
module.exports = \${this.capitalize(cliName)}NodeJsHook;
// If run directly, instantiate and test
if (require.main === module) {
  const hook = new \${this.capitalize(cliName)}NodeJsHook();
  console.log('\${cliName.toUpperCase()} Node.js Hook initialized');
}\`;
  }`;
  
  // 替换整个模板函数
  const functionStart = content.indexOf('  generateNodeJsHookTemplate(cliName) {');
  const functionEnd = content.indexOf('  }', templateEnd) + 3;
  
  const newContent = content.substring(0, functionStart) + 
                    newTemplate + 
                    content.substring(functionEnd);
  
  fs.writeFileSync(filePath, newContent, 'utf8');
  console.log('✅ HookDeploymentManager.js updated successfully!');
} else {
  console.error('❌ HookDeploymentManager.js not found');
  process.exit(1);
}