// Claude CLI ShareMem Integration
// Auto-generated by ShareMem v1.0.3
// Project: D:\stigmergy-CLI-Multi-Agents\test-end-to-end

const { spawn, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

/**
 * å¤„ç† /history å‘½ä»¤
 */
async function handleHistoryCommand(input, context) {
  try {
    console.log('ğŸ” Searching cross-CLI history...');

    // æ„å»ºæŸ¥è¯¢å‘½ä»¤
    const query = buildQuery(input);

    // æ‰§è¡Œè·¨CLIä¼šè¯æ‰«æ
    const sessions = await scanProjectSessions(query, context);

    // æ ¼å¼åŒ–ç»“æ?    const response = formatResponse(sessions, query, context);

    return {
      response,
      suggestions: generateSuggestions(sessions, query)
    };
  } catch (error) {
    console.error('History command error:', error);
    return {
      response: `â?å†å²æŸ¥è¯¢å¤±è´¥: ${error.message}`,
      suggestions: ['/history --help']
    };
  }
}

/**
 * æ„å»ºæŸ¥è¯¢å‚æ•°
 */
function buildQuery(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(/^\/history\s*/i, '').trim();
  const parts = cleanInput.split(/\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();

    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format') {
      const format = parts[++1]?.toLowerCase();
      if (['summary', 'timeline', 'detailed', 'context'].includes(format)) {
        options.format = format;
      }
    } else if (part === '--today') {
      options.timeRange = 'today';
    } else if (part === '--week') {
      options.timeRange = 'week';
    } else if (part === '--month') {
      options.timeRange = 'month';
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

/**
 * æ‰«æé¡¹ç›®ä¼šè¯
 */
async function scanProjectSessions(query, context) {
  const projectPath = 'D:\stigmergy-CLI-Multi-Agents\test-end-to-end';
  const allSessions = [];

  // æ‰«æå„ä¸ªCLIçš„ä¼šè¯?  const cliPaths = {
    claude: path.join(require('os').homedir(), '.claude', 'sessions'),
    gemini: path.join(require('os').homedir(), '.gemini', 'sessions'),
    qwen: path.join(require('os').homedir(), '.qwen', 'sessions'),
    iflow: path.join(require('os').homedir(), '.iflow', 'stigmergy', 'sessions')
  };

  for (const [cliType, sessionsPath] of Object.entries(cliPaths)) {
    if (fs.existsSync(sessionsPath)) {
      try {
        const sessions = await scanCLISessions(cliType, sessionsPath, projectPath);
        allSessions.push(...sessions);
      } catch (error) {
        console.warn(`Failed to scan ${cliType} sessions:`, error.message);
      }
    }
  }

  // åº”ç”¨è¿‡æ»¤å™?  let filteredSessions = allSessions;

  if (query.cli) {
    filteredSessions = filteredSessions.filter(s => s.cliType === query.cli);
  }

  if (query.search) {
    const searchLower = query.search.toLowerCase();
    filteredSessions = filteredSessions.filter(s =>
      s.title?.toLowerCase().includes(searchLower) ||
      s.content?.toLowerCase().includes(searchLower)
    );
  }

  if (query.timeRange !== 'all') {
    filteredSessions = filterByTimeRange(filteredSessions, query.timeRange);
  }

  // æŒ‰æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼?  filteredSessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

  return filteredSessions.slice(0, query.limit);
}

/**
 * æ‰«æç‰¹å®šCLIçš„ä¼šè¯? */
async function scanCLISessions(cliType, sessionsPath, projectPath) {
  const sessions = [];

  try {
    const files = fs.readdirSync(sessionsPath);

    for (const file of files) {
      if (file.endsWith('.json') || file.endsWith('.session')) {
        try {
          const filePath = path.join(sessionsPath, file);
          const content = fs.readFileSync(filePath, 'utf8');
          const session = JSON.parse(content);

          // æ£€æŸ¥æ˜¯å¦å±äºå½“å‰é¡¹ç›?          if (isProjectSession(session, projectPath)) {
            sessions.push({
              cliType,
              sessionId: session.id || session.sessionId || file.replace(/\.(json|session)$/, ''),
              title: session.title || session.topic || 'Untitled',
              content: session.content || session.messages?.map(m => m.content).join(' ') || '',
              updatedAt: new Date(session.updatedAt || session.timestamp || fs.statSync(filePath).mtime),
              messageCount: session.messageCount || session.messages?.length || 0,
              projectPath
            });
          }
        } catch (error) {
          // å¿½ç•¥å•ä¸ªæ–‡ä»¶è§£æé”™è¯¯
        }
      }
    }
  } catch (error) {
    console.warn(`Error scanning ${cliType} sessions:`, error.message);
  }

  return sessions;
}

/**
 * æ£€æŸ¥ä¼šè¯æ˜¯å¦å±äºå½“å‰é¡¹ç›? */
function isProjectSession(session, projectPath) {
  const sessionProject = session.projectPath || session.workingDirectory;
  if (!sessionProject) return true; // å¦‚æœæ²¡æœ‰é¡¹ç›®è·¯å¾„ï¼Œå‡è®¾å±äºå½“å‰é¡¹ç›?
  return sessionProject === projectPath ||
         sessionProject.startsWith(projectPath) ||
         projectPath.startsWith(sessionProject);
}

/**
 * æŒ‰æ—¶é—´èŒƒå›´è¿‡æ»? */
function filterByTimeRange(sessions, timeRange) {
  const now = new Date();

  return sessions.filter(session => {
    const sessionDate = new Date(session.updatedAt);

    switch (timeRange) {
      case 'today':
        return sessionDate.toDateString() === now.toDateString();
      case 'week':
        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        return sessionDate >= weekAgo;
      case 'month':
        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        return sessionDate >= monthAgo;
      default:
        return true;
    }
  });
}

/**
 * æ ¼å¼åŒ–å“åº? */
function formatResponse(sessions, query, context) {
  if (sessions.length === 0) {
    return `ğŸ“­ å½“å‰é¡¹ç›®æš‚æ— å†å²ä¼šè¯\n\nğŸ’¡ **æç¤º:**\nâ€?å°è¯•: /history --search <å…³é”®è¯?\nâ€?æ£€æŸ? å…¶ä»–CLIå·¥å…·æ˜¯å¦æœ‰ä¼šè¯æ–‡ä»¶`;
  }

  switch (query.format) {
    case 'timeline':
      return formatTimeline(sessions);
    case 'detailed':
      return formatDetailed(sessions);
    case 'context':
      return formatContext(sessions[0]);
    default:
      return formatSummary(sessions, context);
  }
}

/**
 * æ ¼å¼åŒ–æ‘˜è¦è§†å›? */
function formatSummary(sessions, context) {
  let response = `ğŸ“ **é¡¹ç›®å†å²ä¼šè¯**\n\nğŸ“Š å…±æ‰¾åˆ?${sessions.length} ä¸ªä¼šè¯\n\n`;

  // æŒ‰CLIåˆ†ç»„
  const byCLI = {};
  sessions.forEach(session => {
    if (!byCLI[session.cliType]) byCLI[session.cliType] = [];
    byCLI[session.cliType].push(session);
  });

  Object.entries(byCLI).forEach(([cli, cliSessions]) => {
    const icon = cli === 'claude' ? 'ğŸŸ¢' : 'ğŸ”µ';
    response += `${icon} **${cli.toUpperCase()}** (${cliSessions.length}ä¸?\n`;

    cliSessions.slice(0, 3).forEach((session, i) => {
      const date = formatDate(session.updatedAt);
      const title = session.title.substring(0, 50);
      response += `   ${i + 1}. ${title}...
`;
      response += `      ğŸ“… ${date} â€?ğŸ’¬ ${session.messageCount}æ¡æ¶ˆæ¯\n`;
    });

    if (cliSessions.length > 3) {
      response += `   ... è¿˜æœ‰ ${cliSessions.length - 3} ä¸ªä¼šè¯\n`;
    }
    response += '\n';
  });

  response += `ğŸ’¡ **ä½¿ç”¨æ–¹æ³•:**\n`;
  response += `â€?`/history --cli <å·¥å…·>` - æŸ¥çœ‹ç‰¹å®šCLI\n`;
  response += `â€?`/history --search <å…³é”®è¯?` - æœç´¢å†…å®¹\n`;
  response += `â€?`/history --format timeline` - æ—¶é—´çº¿è§†å›¾`;

  return response;
}

/**
 * æ ¼å¼åŒ–æ—¶é—´çº¿è§†å›¾
 */
function formatTimeline(sessions) {
  let response = `â?**æ—¶é—´çº¿è§†å›?*\n\n`;

  sessions.forEach((session, index) => {
    const date = formatDate(session.updatedAt);
    const cliIcon = getCLIIcon(session.cliType);

    response += `${index + 1}. ${cliIcon} ${session.title}\n`;
    response += `   ğŸ“… ${date} â€?ğŸ’¬ ${session.messageCount}æ¡æ¶ˆæ¯\n`;
    response += `   ğŸ”‘ ${session.cliType}:${session.sessionId}\n\n`;
  });

  return response;
}

/**
 * æ ¼å¼åŒ–è¯¦ç»†è§†å›? */
function formatDetailed(sessions) {
  let response = `ğŸ“‹ **è¯¦ç»†è§†å›¾**\n\n`;

  sessions.forEach((session, index) => {
    const cliIcon = getCLIIcon(session.cliType);
    const date = session.updatedAt.toLocaleString();

    response += `${index + 1}. ${cliIcon} **${session.title}**\n`;
    response += `   ğŸ“… ${date}\n`;
    response += `   ğŸ”§ CLI: ${session.cliType}\n`;
    response += `   ğŸ’¬ æ¶ˆæ¯æ•? ${session.messageCount}\n`;
    response += `   ğŸ†” ä¼šè¯ID: \`${session.sessionId}\`\n\n`;
  });

  return response;
}

/**
 * æ ¼å¼åŒ–ä¸Šä¸‹æ–‡è§†å›¾
 */
function formatContext(session) {
  if (!session) {
    return `ğŸ“­ æš‚æ— å¯æ¢å¤çš„ä¸Šä¸‹æ–‡ã€‚`;
  }

  let response = `ğŸ”„ **ä¸Šä¸‹æ–‡æ¢å¤?*\n\n`;
  response += `ğŸ“… ä¼šè¯æ—¶é—´: ${session.updatedAt.toLocaleString()}\n`;
  response += `ğŸ”§ æ¥æºCLI: ${session.cliType}\n`;
  response += `ğŸ’¬ æ¶ˆæ¯æ•? ${session.messageCount}\n`;
  response += `ğŸ†” ä¼šè¯ID: ${session.sessionId}\n\n`;
  response += `---\n\n`;
  response += `**ä¸Šæ¬¡è®¨è®ºå†…å®¹:**\n`;
  response += session.content.substring(0, 500);
  if (session.content.length > 500) {
    response += `...`;
  }

  return response;
}

/**
 * æ ¼å¼åŒ–æ—¥æœ? */
function formatDate(date) {
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const days = Math.floor(diff / (24 * 60 * 60 * 1000));

  if (days === 0) {
    return date.toLocaleTimeString();
  } else if (days === 1) {
    return 'æ˜¨å¤©';
  } else if (days < 7) {
    return `${days}å¤©å‰`;
  } else if (days < 30) {
    return `${Math.floor(days / 7)}å‘¨å‰`;
  } else {
    return `${Math.floor(days / 30)}ä¸ªæœˆå‰`;
  }
}

/**
 * è·å–CLIå›¾æ ‡
 */
function getCLIIcon(cliType) {
  const icons = {
    'claude': 'ğŸŸ¢',
    'gemini': 'ğŸ”µ',
    'qwen': 'ğŸŸ¡',
    'iflow': 'ğŸ”´',
    'codebuddy': 'ğŸŸ£',
    'codex': 'ğŸŸª',
    'qodercli': 'ğŸŸ '
  };
  return icons[cliType] || 'ğŸ”¹';
}

/**
 * ç”Ÿæˆå»ºè®®
 */
function generateSuggestions(sessions, query) {
  const suggestions = [];

  if (sessions.length > 0) {
    suggestions.push('/history --format context');
    suggestions.push('/history --format timeline');

    if (sessions[0].cliType) {
      suggestions.push(`/history --cli ${sessions[0].cliType}`);
    }
  }

  suggestions.push('/history --search "react"');
  suggestions.push('/history --today');

  return suggestions.slice(0, 5);
}

// å¯¼å‡ºå¤„ç†å™?module.exports = {
  handleHistoryCommand
};

// æ³¨å†Œåˆ°Claude CLI
if (typeof global !== 'undefined' && global.claudeCLI) {
  global.claudeCLI.addSlashCommand('/history', handleHistoryCommand);
}
