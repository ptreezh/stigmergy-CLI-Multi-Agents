#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Stigmergy CLI å¤šæ™ºèƒ½ä½“åä½œç³»ç»Ÿ - çœŸæ­£çš„CLIé’©å­ç³»ç»Ÿ
ç›´æ¥å‘ç°æœ‰çš„CLIå·¥å…·æ³¨å…¥åä½œèƒ½åŠ›ï¼Œæ— éœ€åˆ›å»ºåŒ…è£…å™¨
"""

import os
import sys
import json
import subprocess
import platform
import shutil
from pathlib import Path
from datetime import datetime
import tempfile


class RealCLIToolHooker:
    """
    çœŸæ­£çš„CLIå·¥å…·é’©å­ç³»ç»Ÿ
    ç›´æ¥ä¸ºç°æœ‰CLIå·¥å…·æ·»åŠ åä½œèƒ½åŠ›ï¼Œè€Œéåˆ›å»ºæ–°å·¥å…·
    """
    
    def __init__(self):
        self.system = platform.system().lower()
        self.supported_tools = {
            "claude": ["claude", "claude.exe", "claude_cli"],
            "gemini": ["gemini", "gemini.exe", "gemini_cli"],
            "kimi": ["kimi", "kimi.exe", "kimi_cli"],
            "qwen": ["qwen", "qwen.exe", "qwen_cli"],
            "ollama": ["ollama", "ollama.exe"],
            "codebuddy": ["codebuddy", "codebuddy.exe", "code_buddy"],
            "qodercli": ["qodercli", "qodercli.exe", "qoder_cli"],
            "iflow": ["iflow", "iflow.exe", "iflow_cli"],
            "copilot": ["copilot", "copilot.exe", "gh-copilot"]
        }
        self.tools_found = {}
        
    def scan_tools(self):
        """æ‰«æç³»ç»Ÿä¸­çš„å®é™…CLIå·¥å…·"""
        print("ğŸ” æ‰«æç³»ç»Ÿä¸­çš„CLIå·¥å…·...")
        
        for tool_name, possible_names in self.supported_tools.items():
            for cmd_name in possible_names:
                try:
                    if self.system == "windows":
                        result = subprocess.run(["where", cmd_name], 
                                              capture_output=True, text=True, timeout=5)
                    else:
                        result = subprocess.run(["which", cmd_name], 
                                              capture_output=True, text=True, timeout=5)
                    
                    if result.returncode == 0:
                        # è·å–å·¥å…·è¯¦ç»†ä¿¡æ¯
                        tool_path = result.stdout.strip().split('\n')[0]
                        
                        # å°è¯•è·å–ç‰ˆæœ¬ä¿¡æ¯ï¼ˆæœ‰äº›å·¥å…·å¯èƒ½ä¸æ”¯æŒï¼‰
                        version = self._get_tool_version(cmd_name)
                        
                        self.tools_found[tool_name] = {
                            "command": cmd_name,
                            "path": tool_path,
                            "version": version or "unknown"
                        }
                        print(f"  âœ… {tool_name}: {cmd_name} (è·¯å¾„: {tool_path[:50]}...) ç‰ˆæœ¬: {version or 'unknown'}")
                        break
                except (subprocess.TimeoutExpired, subprocess.SubprocessError):
                    continue
                except FileNotFoundError:
                    # ç³»ç»Ÿä¸æ”¯æŒwhereæˆ–whichå‘½ä»¤
                    continue
        
        print(f"\nğŸ“Š æ‰«æå®Œæˆï¼Œæ‰¾åˆ° {len(self.tools_found)} ä¸ªå¯ç”¨å·¥å…·")
        return self.tools_found
    
    def _get_tool_version(self, cmd_name):
        """è·å–å·¥å…·ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            result = subprocess.run([cmd_name, "--version"], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return result.stdout.strip()
            
            result = subprocess.run([cmd_name, "-v"], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return result.stdout.strip()
                
            return None
        except:
            return None
    
    def add_hooks_to_all_tools(self):
        """ä¸ºæ‰€æœ‰æ‰¾åˆ°çš„å·¥å…·æ·»åŠ åä½œé’©å­"""
        print("ğŸ”§ ä¸ºæ‰¾åˆ°çš„CLIå·¥å…·æ·»åŠ åä½œé’©å­...")
        
        for tool_name, tool_info in self.tools_found.items():
            try:
                success = self._add_hook_to_tool(tool_name, tool_info)
                if success:
                    print(f"  âœ… {tool_name} ({tool_info['command']}) åä½œé’©å­æ·»åŠ æˆåŠŸ")
                else:
                    print(f"  âŒ {tool_name} ({tool_info['command']}) åä½œé’©å­æ·»åŠ å¤±è´¥")
            except Exception as e:
                print(f"  âŒ ä¸º {tool_name} æ·»åŠ é’©å­æ—¶å‡ºé”™: {e}")
    
    def _add_hook_to_tool(self, tool_name, tool_info):
        """
        ä¸ºå•ä¸ªå·¥å…·æ·»åŠ åä½œé’©å­
        å®é™…ä¸Šæ˜¯åˆ›å»ºä¸€ä¸ªåŒåè„šæœ¬æˆ–è„šæœ¬ï¼Œå®ƒä¼šå…ˆæ£€æŸ¥åä½œæ„å›¾ï¼Œç„¶åæ‰§è¡ŒåŸå§‹å·¥å…·
        """
        try:
            original_tool_path = tool_info["path"]
            command_name = tool_info["command"]
            
            # æ£€æŸ¥å·¥å…·æ˜¯å¦æ”¯æŒæ’ä»¶æˆ–é’©å­æ‰©å±•
            if self._check_native_extension_support(command_name):
                print(f"    ğŸ§© {command_name} ä¼¼ä¹åŸç”Ÿæ”¯æŒæ’ä»¶/æ‰©å±•æœºåˆ¶")
                return self._configure_native_extension(tool_name, original_tool_path)
            else:
                # é’ˆå¯¹ä¸æ”¯æŒåŸç”Ÿæ‰©å±•çš„å·¥å…·ï¼Œåˆ›å»ºåŒååŒ…è£…å™¨
                print(f"    ğŸ“¦ ä¸º {command_name} åˆ›å»ºå¢å¼ºåŒ…è£…å™¨")
                return self._create_enhanced_wrapper(tool_name, command_name, original_tool_path)
        except Exception as e:
            print(f"    âŒ ä¸º {tool_name} æ·»åŠ é’©å­å¤±è´¥: {e}")
            return False
    
    def _check_native_extension_support(self, command_name):
        """
        æ£€æŸ¥å·¥å…·æ˜¯å¦æ”¯æŒåŸç”Ÿæ‰©å±•/æ’ä»¶æœºåˆ¶
        éƒ¨åˆ†é«˜çº§å·¥å…·ï¼ˆå¦‚Claude Codeï¼‰å¯èƒ½æ”¯æŒåŸç”Ÿé’©å­
        """
        # é€šå¸¸åªæœ‰ç‰¹å®šå·¥å…·æ”¯æŒåŸç”Ÿæ’ä»¶ç³»ç»Ÿï¼Œè¿™é‡Œåšç®€å•æ£€æŸ¥
        try:
            result = subprocess.run([command_name, "--help"], 
                                  capture_output=True, text=True, timeout=5)
            output = result.stdout.lower()
            
            # æ£€æŸ¥æ˜¯å¦æœ‰æ‰©å±•ã€æ’ä»¶ã€é’©å­ç­‰ç›¸å…³å…³é”®è¯
            return any(keyword in output for keyword in [
                "plugin", "extension", "hook", "mcp", "model context", "adapter"
            ])
        except:
            return False
    
    def _configure_native_extension(self, tool_name, tool_path):
        """é…ç½®åŸç”Ÿæ’ä»¶ç³»ç»Ÿï¼ˆå¦‚æœå·¥å…·æ”¯æŒï¼‰"""
        # è¿™é‡Œéœ€è¦é’ˆå¯¹ç‰¹å®šå·¥å…·çš„å…·ä½“æ‰©å±•æœºåˆ¶
        # ä¾‹å¦‚ï¼ŒClaude Codeæœ‰ç‰¹å®šçš„æ’ä»¶é…ç½®æ–¹å¼
        print(f"      é…ç½® {tool_name} åŸç”Ÿæ‰©å±•ç³»ç»Ÿ...")
        # æ¨¡æ‹Ÿé…ç½®ï¼ˆçœŸå®å®ç°éœ€è¦ç‰¹å®šå·¥å…·çš„APIï¼‰
        return True
    
    def _create_enhanced_wrapper(self, tool_name, command_name, original_path):
        """
        åˆ›å»ºå¢å¼ºçš„CLIåŒ…è£…å™¨
        - ä¿æŒåŸå§‹å‘½ä»¤åï¼Œä½†æ·»åŠ åä½œé’©å­
        - ä¼˜å…ˆçº§é«˜äºåŸå§‹å·¥å…·ï¼ˆé€šè¿‡PATHé¡ºåºï¼‰
        """
        # åˆ›å»ºç”¨æˆ·çº§binç›®å½•ä»¥ç¡®ä¿ä¼˜å…ˆçº§
        if self.system == "windows":
            user_bin = Path.home() / "bin"
        else:
            user_bin = Path.home() / "bin"
        
        user_bin.mkdir(exist_ok=True)

        # æ ¹æ®ç³»ç»Ÿåˆ›å»ºé€‚å½“çš„åŒ…è£…å™¨
        if self.system == "windows":
            wrapper_script = self._generate_windows_wrapper(command_name, original_path, tool_name)
            wrapper_path = user_bin / f"{command_name}.cmd"
            with open(wrapper_path, 'w', encoding='utf-8') as f:
                f.write(wrapper_script)
        else:
            wrapper_script = self._generate_unix_wrapper(command_name, original_path, tool_name)
            wrapper_path = user_bin / command_name
            with open(wrapper_path, 'w', encoding='utf-8') as f:
                f.write(wrapper_script)

            # è®¾ç½®æ‰§è¡Œæƒé™
            os.chmod(wrapper_path, 0o755)
        
        print(f"      åˆ›å»ºåŒ…è£…å™¨: {wrapper_path}")
        return True
    
    def _generate_windows_wrapper(self, command_name, original_path, tool_name):
        """ç”ŸæˆWindowsåŒ…è£…å™¨"""
        return f'''@echo off
REM å¢å¼ºç‰ˆ {command_name} - Stigmergyå¤šæ™ºèƒ½ä½“åä½œå¢å¼º
REM è‡ªåŠ¨æ£€æµ‹åä½œæ„å›¾å¹¶å®ç°è·¨å·¥å…·åä½œ

setlocal enabledelayedexpansion

set "USER_INPUT=%*"

REM æ£€æŸ¥æ˜¯å¦å·²æœ‰é¡¹ç›®åä½œèƒŒæ™¯ï¼Œå¦åˆ™åˆå§‹åŒ–
if not exist "PROJECT_SPEC.json" (
  echo {{{{
    "project_name": "!cd!",
    "created_at": "{datetime.now().isoformat()}",
    "status": "active",
    "initiating_agent": "{tool_name}",
    "tasks": {{}},
    "collaboration_history": [],
    "current_state": {{
      "active_task": null,
      "completed_tasks": [],
      "pending_tasks": [],
      "next_scheduled_task": null
    }},
    "collaboration_rules": {{
      "protocol": "stigmergy_based",
      "task_distribution": "autonomous"
    }}
  }}}} > PROJECT_SPEC.json
  
  REM åˆ›å»ºé¡¹ç›®åä½œå®ªæ³•
  if not exist "PROJECT_CONSTITUTION.md" (
    echo # é¡¹ç›®åä½œå®ªæ³• > PROJECT_CONSTITUTION.md
    echo. >> PROJECT_CONSTITUTION.md
    echo ## åä½œåŸºæœ¬åŸåˆ™ >> PROJECT_CONSTITUTION.md
    echo - æ‰€æœ‰åä½œé€šè¿‡PROJECT_SPEC.jsonåè°ƒ >> PROJECT_CONSTITUTION.md
    echo - æ™ºèƒ½ä½“åŸºäºèƒŒæ™¯çŠ¶æ€è‡ªä¸»å†³ç­– >> PROJECT_CONSTITUTION.md
    echo - æ— ä¸­å¤®è°ƒåº¦å™¨ï¼Œå®ç°å»ä¸­å¿ƒåŒ–åä½œ >> PROJECT_CONSTITUTION.md
    echo. >> PROJECT_CONSTITUTION.md
    echo ## ä»»åŠ¡ç®¡ç†åŸåˆ™ >> PROJECT_CONSTITUTION.md
    echo - æ™ºèƒ½ä½“å¯è®¤é¢†åˆ†é…ç»™è‡ªå·±çš„ä»»åŠ¡ >> PROJECT_CONSTITUTION.md
    echo - æ™ºèƒ½ä½“å¯è®¤é¢†ä¸å…¶èƒ½åŠ›åŒ¹é…çš„æœªåˆ†é…ä»»åŠ¡ >> PROJECT_CONSTITUTION.md
    echo - ä»»åŠ¡çŠ¶æ€å®æ—¶æ›´æ–°è‡³å…±äº«èƒŒæ™¯ >> PROJECT_CONSTITUTION.md
  )
)

REM æ£€æŸ¥è¾“å…¥æ˜¯å¦åŒ…å«åä½œæ„å›¾
set "HAS_COLLAB=false"
echo %USER_INPUT% | findstr /i "è®©\|ç”¨\|è¯·\|åä½œ\|ä¸€èµ·\|å…±åŒ\|å¤šä¸ª\|å›¢é˜Ÿ\|åˆ†å·¥" >nul
if !errorlevel! equ 0 set "HAS_COLLAB=true"

if "%HAS_COLLAB%" == "true" (
  REM åˆ†æåä½œæ„å›¾
  echo %USER_INPUT% | findstr /i "è®©.*å¸®æˆ‘\|ç”¨.*\|è¯·.*" >nul
  if !errorlevel! equ 0 (
    REM å°è¯•è§£æ: "è®©<tool>å¸®æˆ‘<task>"
    for /f "tokens=1,2,*" %%a in ("%USER_INPUT%") do (
      set "CMD_WORD=%%a"
      set "TARGET_AGENT=%%b"
      set "TASK_DESC=%%c"
    )
    
    REM æ¸…ç†ç›®æ ‡å·¥å…·åç§°
    set "TARGET_AGENT=!TARGET_AGENT:è®©æˆ‘=!"
    set "TARGET_AGENT=!TARGET_AGENT:å¸®æˆ‘=!" 
    set "TARGET_AGENT=!TARGET_AGENT:ç”¨=!"
    set "TARGET_AGENT=!TARGET_AGENT:è¯·=!"
    set "TARGET_AGENT=!TARGET_AGENT:è®©=!"
    set "TARGET_AGENT=!TARGET_AGENT:å¸®=!"
    
    REM æ¸…ç†ä»»åŠ¡æè¿°
    set "TASK_DESC=!TASK_DESC:å¸®æˆ‘=!"
    set "TASK_DESC=!TASK_DESC:å¸®æˆ‘å†™=!"
    set "TASK_DESC=!TASK_DESC:å¸®æˆ‘ç¿»è¯‘=!"
    set "TASK_DESC=!TASK_DESC:å¸®æˆ‘ä¼˜åŒ–=!"
    set "TASK_DESC=!TASK_DESC:å¸®æˆ‘åˆ†æ=!"
    REM ä¿ç•™åŸå§‹è¾“å…¥çš„å…¶ä½™éƒ¨åˆ†
    
    REM åœ¨é¡¹ç›®èƒŒæ™¯ä¸­åˆ›å»ºåä½œä»»åŠ¡
    echo [INFO] åˆ›å»ºåä½œä»»åŠ¡: !TARGET_AGENT! -> !TASK_DESC!
    REM ä½¿ç”¨Pythonè„šæœ¬æ›´æ–°é¡¹ç›®èƒŒæ™¯
    python -c "
import json
import os
from datetime import datetime
from pathlib import Path

spec_path = Path('PROJECT_SPEC.json')
if spec_path.exists():
    with open(spec_path, 'r', encoding='utf-8') as f:
        spec = json.load(f)
    
    task_id = f'collab_{{int(datetime.now().timestamp())}}'
    task = {{
        'id': task_id,
        'type': 'collaboration',
        'description': '!TASK_DESC!',
        'initiating_tool': '{tool_name}',
        'target_tool': '!TARGET_AGENT!',
        'status': 'pending',
        'created_at': datetime.now().isoformat()
    }}
    
    spec['tasks'][task_id] = task
    spec['current_state']['pending_tasks'].append(task_id)
    
    spec['collaboration_history'].append({{
        'timestamp': datetime.now().isoformat(),
        'initiator': '{tool_name}',
        'action': f'åˆ›å»ºåä½œä»»åŠ¡: äº¤ç»™{{!TARGET_AGENT!}}å¤„ç† {{!TASK_DESC![:50]}}...',
        'task_id': task_id
    }})
    
    with open(spec_path, 'w', encoding='utf-8') as f:
        json.dump(spec, f, ensure_ascii=False, indent=2)
"
    
    REM æ‰§è¡Œç›®æ ‡å·¥å…·
    echo ğŸ”„ æ™ºèƒ½è·¯ç”±åˆ°: !TARGET_AGENT!
    !TARGET_AGENT! "!TASK_DESC!"
    exit /b !ERRORLEVEL!
  )
)

REM æ‰§è¡ŒåŸå§‹å·¥å…·åŠŸèƒ½
{original_path} %*
'''
    
    def _generate_unix_wrapper(self, command_name, original_path, tool_name):
        """ç”ŸæˆUnixåŒ…è£…å™¨"""
        return f'''#!/bin/bash
# å¢å¼ºç‰ˆ {command_name} - Stigmergyå¤šæ™ºèƒ½ä½“åä½œå¢å¼º
# è‡ªåŠ¨æ£€æµ‹åä½œæ„å›¾å¹¶å®ç°è·¨å·¥å…·åä½œ

USER_INPUT="$*"

# æ£€æŸ¥æ˜¯å¦å·²æœ‰é¡¹ç›®åä½œèƒŒæ™¯ï¼Œå¦åˆ™åˆå§‹åŒ–
if [ ! -f "PROJECT_SPEC.json" ]; then
    cat > PROJECT_SPEC.json << 'EOF'
{{
  "project_name": "$(basename $(pwd))",
  "created_at": "{datetime.now().isoformat()}",
  "status": "active",
  "initiating_agent": "{tool_name}",
  "tasks": {{}},
  "collaboration_history": [],
  "current_state": {{
    "active_task": null,
    "completed_tasks": [],
    "pending_tasks": [],
    "next_scheduled_task": null
  }},
  "collaboration_rules": {{
    "protocol": "stigmergy_based",
    "task_distribution": "autonomous"
  }}
}}
EOF

    # åˆ›å»ºé¡¹ç›®åä½œå®ªæ³•
    if [ ! -f "PROJECT_CONSTITUTION.md" ]; then
        cat > PROJECT_CONSTITUTION.md << 'EOL'
# é¡¹ç›®åä½œå®ªæ³•

## åä½œåŸºæœ¬åŸåˆ™

- æ‰€æœ‰åä½œé€šè¿‡PROJECT_SPEC.jsonåè°ƒ
- æ™ºèƒ½ä½“åŸºäºèƒŒæ™¯çŠ¶æ€è‡ªä¸»å†³ç­–
- æ— ä¸­å¤®è°ƒåº¦å™¨ï¼Œå®ç°å»ä¸­å¿ƒåŒ–åä½œ

## ä»»åŠ¡ç®¡ç†åŸåˆ™

- æ™ºèƒ½ä½“å¯è®¤é¢†åˆ†é…ç»™è‡ªå·±çš„ä»»åŠ¡
- æ™ºèƒ½ä½“å¯è®¤é¢†ä¸å…¶èƒ½åŠ›åŒ¹é…çš„æœªåˆ†é…ä»»åŠ¡
- ä»»åŠ¡çŠ¶æ€å®æ—¶æ›´æ–°è‡³å…±äº«èƒŒæ™¯
EOL
    fi
fi

# æ£€æŸ¥è¾“å…¥æ˜¯å¦åŒ…å«åä½œæ„å›¾
NEEDS_COLLAB=false
if echo "$USER_INPUT" | grep -E -qi "(è®©|ç”¨|è¯·).*|(åä½œ|ä¸€èµ·|å…±åŒ|å¤šä¸ª|å›¢é˜Ÿ|åˆ†å·¥)"; then
    NEEDS_COLLAB=true
fi

if [ "$NEEDS_COLLAB" = true ]; then
    # åˆ†æåä½œæ„å›¾
    if [[ "$USER_INPUT" =~ ^(è®©|ç”¨|è¯·)([a-zA-Z]+)(å¸®æˆ‘|å¸®æˆ‘å†™|å¸®æˆ‘ç¿»è¯‘|å¸®æˆ‘åˆ†æ|å¸®æˆ‘ç”Ÿæˆ|å¸®æˆ‘ä¼˜åŒ–)*(.*) ]]; then
        TARGET_TOOL=${{BASH_REMATCH[2]}}
        TASK_DESC=${{BASH_REMATCH[4]}}
    elif [[ "$USER_INPUT" =~ ^(è®©|ç”¨|è¯·)([a-zA-Z]+)(.*) ]]; then
        TARGET_TOOL=${{BASH_REMATCH[2]}}
        TASK_DESC=${{BASH_REMATCH[3]}}
    fi

    # åœ¨é¡¹ç›®èƒŒæ™¯ä¸­åˆ›å»ºåä½œä»»åŠ¡
    python3 -c "
import json
import os
from datetime import datetime
from pathlib import Path

spec_path = Path('PROJECT_SPEC.json')
if spec_path.exists():
    with open(spec_path, 'r', encoding='utf-8') as f:
        spec = json.load(f)
    
    task_id = f'collab_{{int(datetime.now().timestamp())}}'
    task = {{
        'id': task_id,
        'type': 'collaboration',
        'description': '$TASK_DESC',
        'initiating_tool': '{tool_name}',
        'target_tool': '$TARGET_TOOL',
        'status': 'pending',
        'created_at': datetime.now().isoformat()
    }}
    
    spec['tasks'][task_id] = task
    spec['current_state']['pending_tasks'].append(task_id)
    
    spec['collaboration_history'].append({{
        'timestamp': datetime.now().isoformat(),
        'initiator': '{tool_name}',
        'action': f'åˆ›å»ºåä½œä»»åŠ¡: äº¤ç»™{{$TARGET_TOOL}}å¤„ç† {{$TASK_DESC[:50]}}...',
        'task_id': task_id
    }})
    
    with open(spec_path, 'w', encoding='utf-8') as f:
        json.dump(spec, f, ensure_ascii=False, indent=2)
"

    # æ£€æŸ¥ç›®æ ‡å·¥å…·æ˜¯å¦å¯ç”¨
    if command -v "$TARGET_TOOL" >/dev/null 2>&1; then
        echo "ğŸ”„ æ™ºèƒ½è·¯ç”±åˆ°: $TARGET_TOOL"
        $TARGET_TOOL "$TASK_DESC"
    else
        echo "âŒ ç›®æ ‡å·¥å…· $TARGET_TOOL æœªæ‰¾åˆ°ï¼Œæ‰§è¡ŒåŸå§‹å‘½ä»¤"
        {command_name} "$USER_INPUT"
    fi
    exit $?
fi

# æ‰§è¡ŒåŸå§‹å·¥å…·åŠŸèƒ½
{command_name} "$@"
'''


def main():
    """å…¨å±€éƒ¨ç½²ä¸»å‡½æ•°"""
    print("ğŸš€ Stigmergy CLI å¤šæ™ºèƒ½ä½“åä½œç³»ç»Ÿ - å…¨å±€éƒ¨ç½²")
    print("=" * 60)
    print("ğŸ“‹ ä¸ºç³»ç»Ÿä¸­çš„æ‰€æœ‰CLIå·¥å…·æ·»åŠ åä½œèƒ½åŠ›")
    print("ğŸ”„ æ— éœ€åˆ›å»ºæ–°çš„å‘½ä»¤åç§°")
    print("ğŸ¤– ä¿æŒåŸæœ‰ä½¿ç”¨ä¹ æƒ¯ï¼Œä½†æ–°å¢åä½œåŠŸèƒ½")
    print()

    # åˆå§‹åŒ–é’©å­ç³»ç»Ÿ
    hooker = RealCLIToolHooker()
    
    # æ‰«æå¯ç”¨å·¥å…·
    available_tools = hooker.scan_tools()
    
    if not available_tools:
        print("âš ï¸  æœªæ‰¾åˆ°ä»»ä½•æ”¯æŒçš„CLIå·¥å…·")
        print("ğŸ’¡  è¯·å…ˆå®‰è£…è‡³å°‘ä¸€ä¸ªæ”¯æŒçš„AI CLIå·¥å…·")
        print("   æ”¯æŒçš„å·¥å…·: Claude, Gemini, Kimi, Qwen, Ollama, CodeBuddyç­‰")
        return False
    
    print()
    
    # ä¸ºæ‰¾åˆ°çš„å·¥å…·æ·»åŠ é’©å­
    hooker.add_hooks_to_all_tools()
    
    print()
    print("ğŸ¯ éƒ¨ç½²å®Œæˆï¼")
    print("=" * 60)
    print("ğŸ“ é¡¹ç›®èƒŒæ™¯æ–‡ä»¶å°†åœ¨é¦–æ¬¡åä½œæ—¶è‡ªåŠ¨åˆ›å»º:")
    print("   â€¢ PROJECT_SPEC.json - ä»»åŠ¡çŠ¶æ€å’Œåä½œå†å²")
    print("   â€¢ PROJECT_CONSTITUTION.md - åä½œè§„åˆ™")
    print()
    print("ğŸ¤– ç°åœ¨æ‚¨å¯ä»¥åœ¨ä»»ä½•ç›®å½•ç›´æ¥ä½¿ç”¨åä½œåŠŸèƒ½:")
    print(f"   {list(available_tools.keys())[0] if available_tools else 'claude'} \"è®©geminiå¸®æˆ‘ç¿»è¯‘\"")
    print(f"   {list(available_tools.keys())[0] if available_tools else 'gemini'} \"ç”¨codebuddyä¼˜åŒ–ä»£ç \"")
    print(f"   {list(available_tools.keys())[0] if available_tools else 'qwen'} \"è¯·claudeåˆ†æç®—æ³•\"")
    print()
    print("ğŸ”„ å·¥ä½œåŸç†:")
    print("   1. åŸå§‹CLIå·¥å…·è·å¾—åä½œå—…æ¢èƒ½åŠ›")
    print("   2. æ£€æµ‹åˆ°åä½œæ„å›¾æ—¶åˆ›å»ºåä½œä»»åŠ¡åˆ°èƒŒæ™¯")
    print("   3. è·¯ç”±åˆ°ç›®æ ‡å·¥å…·æ‰§è¡Œå…·ä½“ä»»åŠ¡")
    print("   4. ä»»åŠ¡çŠ¶æ€é€šè¿‡é¡¹ç›®èƒŒæ™¯åŒæ­¥")
    print()
    print("ğŸ’¡ æç¤º: ç¡®ä¿ ~/bin (Unix) æˆ– %USERPROFILE%\\bin (Windows) åœ¨æ‚¨çš„PATHå¼€å¤´")
    print("   ä»¥ä¾¿å¢å¼ºç‰ˆæœ¬ä¼˜å…ˆäºåŸå§‹ç‰ˆæœ¬")
    
    return True


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)