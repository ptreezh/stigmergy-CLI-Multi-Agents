# AI CLI Tools Integration Specification
## Detailed Integration Mechanisms per CLI Tool

**Document Version:** 1.0
**Last Updated:** 2025-01-22
**Status:** Final Specification

---

## ğŸ“‹ æ¦‚è¿° (Overview)

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜äº†8ä¸ªä¸»æµAI CLIå·¥å…·çš„æœ€ä¼˜é›†æˆæœºåˆ¶ï¼ŒåŸºäºæˆ‘ä»¬ä¹‹å‰çš„è®¨è®ºå’Œç”¨æˆ·éœ€æ±‚åˆ†æã€‚æ¯ä¸ªCLIå·¥å…·éƒ½æœ‰å…¶æœ€é€‚åˆçš„åŸç”Ÿé›†æˆæ–¹å¼ï¼Œç¡®ä¿æœ€ä½³æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚

---

## ğŸ”§ 1. Claude CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šHook System (Hookç³»ç»Ÿ)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph LR
    A[ç”¨æˆ·è¾“å…¥] --> B[UserPromptSubmit Hook]
    B --> C{åŒ…å«è·¨CLIè°ƒç”¨?}
    C -->|æ˜¯| D[è·¨CLIå¤„ç†å™¨]
    C -->|å¦| E[Claudeæ­£å¸¸å¤„ç†]
    D --> F[è°ƒç”¨ç›®æ ‡CLI]
    F --> G[è¿”å›ç»“æœ]
    G --> H[æ˜¾ç¤ºç»™ç”¨æˆ·]
```

#### å®ç°ç»†èŠ‚

**Hookç‚¹é€‰æ‹©ï¼š**
- **ä¸»è¦Hook:** `UserPromptSubmit` - ç”¨æˆ·æäº¤è¾“å…¥æ—¶æ‹¦æˆª
- **å¤‡ç”¨Hook:** `PreToolUse` - å·¥å…·ä½¿ç”¨å‰æ‹¦æˆª

**ä»£ç ç»“æ„ï¼š**
```python
# claude_cross_cli_adapter.py
from claude_code import HookContext, Plugin

class ClaudeCrossCLIAdapter(Plugin):
    def __init__(self):
        self.name = "claude-cross-cli-adapter"
        self.version = "1.0.0"
        self.hooks = ["UserPromptSubmit", "PreToolUse"]

    async def on_user_prompt_submit(self, context: HookContext) -> Optional[str]:
        """ç”¨æˆ·è¾“å…¥æäº¤Hook - æœ€ç†æƒ³çš„æ‹¦æˆªç‚¹"""
        user_input = context.prompt

        # æ£€æµ‹è·¨CLIè°ƒç”¨
        target_cli = self._detect_cross_cli_call(user_input)
        if target_cli:
            # å¤„ç†è·¨CLIè°ƒç”¨
            result = await self._handle_cross_cli_call(user_input, target_cli, context)
            if result:
                return result  # é˜»æ­¢Claudeç»§ç»­å¤„ç†

        return None  # è®©Claudeæ­£å¸¸å¤„ç†

    def _detect_cross_cli_call(self, user_input: str) -> Optional[str]:
        """æ£€æµ‹è·¨CLIè°ƒç”¨æ„å›¾"""
        import re
        patterns = [
            r'è¯·ç”¨(gemini|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)',
            r'è°ƒç”¨(gemini|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)',
            r'ç”¨(gemini|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)æ¥',
            r'use\s+(gemini|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)'
        ]

        for pattern in patterns:
            match = re.search(pattern, user_input.lower())
            if match:
                return match.group(1)

        return None
```

**å®‰è£…é…ç½®ï¼š**
```json
// ~/.claude/plugins.json
{
  "plugins": [
    {
      "name": "claude-cross-cli-adapter",
      "version": "1.0.0",
      "main": "claude_cross_cli_adapter.py",
      "hooks": ["UserPromptSubmit", "PreToolUse"],
      "permissions": ["network", "shell_execute", "file_read"],
      "enabled": true
    }
  ]
}
```

**ä¼˜åŠ¿ï¼š**
- âœ… åŸç”Ÿæ”¯æŒï¼Œæ€§èƒ½æœ€ä½³
- âœ… ç²¾ç¡®æ‹¦æˆªï¼Œæ— é—æ¼
- âœ… å®Œå…¨é€æ˜ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥
- âœ… å¯ä»¥å®Œå…¨æ§åˆ¶è¯·æ±‚å¤„ç†æµç¨‹

---

## ğŸ”§ 2. Aider CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šPython Plugin Inheritance (Pythonæ’ä»¶ç»§æ‰¿)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[ç”¨æˆ·è¾“å…¥] --> B[Aiderå‘½ä»¤è§£æ]
    B --> C{æ˜¯--askå‘½ä»¤?}
    C -->|æ˜¯| D[on_command Hook]
    C -->|å¦| E[æ­£å¸¸å¤„ç†]
    D --> F{åŒ…å«è·¨CLIè°ƒç”¨?}
    F -->|æ˜¯| G[è·¨CLIå¤„ç†å™¨]
    F -->|å¦| H[åŸaskå¤„ç†]
    G --> I[è°ƒç”¨ç›®æ ‡CLI]
    I --> J[è¿”å›ç»“æœ]
```

#### å®ç°ç»†èŠ‚

**æ’ä»¶ç»§æ‰¿ï¼š**
```python
# aider_cross_cli_adapter.py
from aider.plugins import AiderPlugin
from aider.commands import CommandRegistry
import asyncio

class AiderCrossCLIAdapter(AiderPlugin):
    def __init__(self):
        super().__init__()
        self.name = "cross-cli-adapter"
        self.version = "1.0.0"
        self.description = "Cross-CLI calling adapter for Aider"

        # æ³¨å†Œè‡ªå®šä¹‰å‘½ä»¤
        self.command_registry = CommandRegistry()
        self._register_cross_commands()

    def _register_cross_commands(self):
        """æ³¨å†Œè·¨CLIç›¸å…³å‘½ä»¤"""

        @self.command_registry.register("cross")
        async def cross_command(args):
            """crosså‘½ä»¤ - æ˜ç¡®çš„è·¨CLIè°ƒç”¨"""
            if len(args) < 2:
                return "Usage: cross <cli_name> <request>"

            target_cli = args[0]
            request = " ".join(args[1:])

            return await self._execute_cross_cli(target_cli, request)

        @self.command_registry.register("ask")
        async def enhanced_ask_command(args):
            """å¢å¼ºçš„askå‘½ä»¤"""
            request = " ".join(args) if args else ""

            # æ£€æµ‹è·¨CLIè°ƒç”¨
            target_cli = self._detect_cross_cli_call(request)
            if target_cli:
                return await self._execute_cross_cli(target_cli, request)

            # æ²¡æœ‰è·¨CLIè°ƒç”¨ï¼Œè°ƒç”¨åŸæœ‰askåŠŸèƒ½
            return await self._original_ask(request)

    async def on_command(self, command: str, args: list, context: dict) -> Optional[str]:
        """å‘½ä»¤å¤„ç†Hook - Aiderçš„æ ¸å¿ƒæ‹¦æˆªç‚¹"""

        # æ‹¦æˆª--askå‘½ä»¤
        if command in ["ask", "--ask"]:
            user_input = " ".join(args) if args else ""

            cross_result = await self._handle_cross_cli_request(user_input, context)
            if cross_result:
                return cross_result

        # æ£€æŸ¥å…¶ä»–å‘½ä»¤ä¸­çš„è·¨CLIè°ƒç”¨
        full_command = " ".join([command] + args)
        if self._contains_cross_cli_call(full_command):
            return await self._handle_cross_cli_request(full_command, context)

        return None  # è®©Aideræ­£å¸¸å¤„ç†

    async def on_response(self, response: str, original_request: str) -> str:
        """å“åº”å¤„ç†Hook - åå¤„ç†å¢å¼º"""

        # æ£€æŸ¥å“åº”ä¸­æ˜¯å¦éœ€è¦å…¶ä»–CLIçš„è¡¥å……
        if self._should_enhance_with_cross_cli(response, original_request):
            enhancement = await self._generate_cross_cli_enhancement(response, original_request)

            if enhancement:
                return f"{response}\n\nğŸ¤– **è¡¥å……å»ºè®® (æ¥è‡ªå…¶ä»–AI):**\n{enhancement}"

        return response
```

**é…ç½®æ–‡ä»¶ï¼š**
```yaml
# ~/.aider/plugins.yaml
plugins:
  enabled:
    - cross-cli-adapter
  cross-cli-adapter:
    module: "aider_cross_cli_adapter.AiderCrossCLIAdapter"
    priority: 1
    config:
      auto_detect: true
      fallback_enabled: true
      timeout: 30
```

**ä¼˜åŠ¿ï¼š**
- âœ… åŸç”Ÿæ’ä»¶ç³»ç»Ÿæ”¯æŒ
- âœ… å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸæ§åˆ¶
- âœ… å¯ä»¥æ‰©å±•æˆ–è¦†ç›–ç°æœ‰å‘½ä»¤
- âœ… Pythonç”Ÿæ€å®Œå…¨å…¼å®¹

---

## ğŸ”§ 3. Gemini CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šPython Module + Configuration File (Pythonæ¨¡å—+é…ç½®æ–‡ä»¶)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph LR
    A[ç”¨æˆ·è¾“å…¥] --> B[é…ç½®åŠ è½½å™¨]
    B --> C[æ¨¡å—åŠ è½½å™¨]
    C --> D[è¯·æ±‚é¢„å¤„ç†å™¨]
    D --> E{åŒ…å«è·¨CLIè°ƒç”¨?}
    E -->|æ˜¯| F[è·¨CLIå¤„ç†å™¨]
    E -->|å¦| G[Geminiæ­£å¸¸å¤„ç†]
    F --> H[è°ƒç”¨ç›®æ ‡CLI]
    H --> I[ç»“æœåå¤„ç†å™¨]
    I --> J[è¿”å›ç»™ç”¨æˆ·]
```

#### å®ç°ç»†èŠ‚

**æ¨¡å—ç»“æ„ï¼š**
```python
# gemini_cross_cli_adapter.py
import json
import asyncio
from typing import Optional, Dict, Any

class GeminiCrossCLIAdapter:
    """Gemini CLIè·¨CLIé€‚é…å™¨"""

    def __init__(self, config: Dict[str, Any]):
        self.name = "cross-cli-adapter"
        self.version = "1.0.0"
        self.enabled = config.get("enabled", True)
        self.priority = config.get("priority", 1)
        self.supported_clis = config.get("supported_clis", [
            "claude", "codex", "qwencode", "qodercli", "iflowcli", "codebuddycli", "kimi"
        ])

    async def preprocess_request(self, request: str, context: Dict[str, Any]) -> Optional[str]:
        """è¯·æ±‚é¢„å¤„ç† - Gemini CLIçš„ä¸»è¦æ‹¦æˆªç‚¹"""

        # æ£€æµ‹è·¨CLIè°ƒç”¨
        if self._contains_cross_cli_call(request):
            result = await self._handle_cross_cli_call(request, context)

            if result:
                # è¿”å›å¤„ç†ç»“æœï¼Œé˜»æ­¢Geminiç»§ç»­å¤„ç†
                return result

        return None  # è®©Geminiæ­£å¸¸å¤„ç†

    async def postprocess_response(self, response: str, original_request: str,
                                 context: Dict[str, Any]) -> str:
        """å“åº”åå¤„ç† - å¢å¼ºå“åº”"""

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å……å…¶ä»–CLIçš„èƒ½åŠ›
        if self._should_enhance_with_cross_cli(response, original_request):
            enhancement = await self._generate_cross_cli_enhancement(
                response, original_request, context
            )

            if enhancement:
                return f"{response}\n\nğŸ¤– **è¡¥å……å»ºè®® (æ¥è‡ªå…¶ä»–AI):**\n{enhancement}"

        return response

    def _contains_cross_cli_call(self, text: str) -> bool:
        """æ£€æµ‹æ˜¯å¦åŒ…å«è·¨CLIè°ƒç”¨"""
        import re
        text_lower = text.lower()

        patterns = [
            r'è¯·ç”¨(claude|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)',
            r'è°ƒç”¨(claude|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)',
            r'ç”¨(claude|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)æ¥',
            r'use\s+(claude|codex|qwencode|qodercli|iflowcli|codebuddycli|kimi)'
        ]

        for pattern in patterns:
            if re.search(pattern, text_lower):
                return True

        return False
```

**é…ç½®æ–‡ä»¶ï¼š**
```json
// ~/.gemini/config.json
{
  "version": "1.0.0",
  "plugins": [
    {
      "name": "cross-cli-adapter",
      "module": "gemini_cross_cli_adapter.GeminiCrossCLIAdapter",
      "enabled": true,
      "priority": 1,
      "hooks": ["preprocess_request", "postprocess_response"],
      "config": {
        "auto_detect": true,
        "fallback_enabled": true,
        "supported_clis": [
          "claude", "codex", "qwencode", "qodercli",
          "iflowcli", "codebuddycli", "kimi"
        ],
        "timeout": 30,
        "max_concurrent": 2
      }
    }
  ],
  "cross_cli_settings": {
    "enabled_clis": ["claude", "codex", "qwencode"],
    "timeout": 30,
    "max_concurrent": 2,
    "result_format": "markdown"
  }
}
```

**ä¼˜åŠ¿ï¼š**
- âœ… çµæ´»çš„é…ç½®é©±åŠ¨
- âœ… çƒ­æ’æ‹”æ”¯æŒ
- âœ… ä¼˜å…ˆçº§ç®¡ç†
- âœ… å®Œæ•´çš„è¯·æ±‚/å“åº”ç”Ÿå‘½å‘¨æœŸ

---

## ğŸ”§ 4. QwenCode CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šPython Wrapper (PythonåŒ…è£…)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[åŸå§‹qwencodeå‘½ä»¤] --> B[åŒ…è£…å™¨å…¥å£]
    B --> C[å‚æ•°è§£æ]
    C --> D[è·¨CLIæ£€æµ‹]
    D --> E{åŒ…å«è·¨CLIè°ƒç”¨?}
    E -->|æ˜¯| F[è·¨CLIå¤„ç†å™¨]
    E -->|å¦| G[è°ƒç”¨åŸå§‹qwencode]
    F --> H[è°ƒç”¨ç›®æ ‡CLI]
    H --> I[è¿”å›ç»“æœ]
    G --> I
```

#### å®ç°ç»†èŠ‚

**åŒ…è£…å™¨è„šæœ¬ï¼š**
```python
# qwencode_cross_cli_wrapper.py
#!/usr/bin/env python3
import sys
import os
import asyncio
from pathlib import Path

# æ·»åŠ é€‚é…å™¨è·¯å¾„
sys.path.insert(0, str(Path(__file__).parent / "adapters"))

from qwencode_adapter import QwenCodeCrossCLIAdapter

class QwenCodeWrapper:
    def __init__(self):
        self.adapter = QwenCodeCrossCLIAdapter()
        self.original_command = self._find_original_command()

    def _find_original_command(self) -> str:
        """æŸ¥æ‰¾åŸå§‹qwencodeå‘½ä»¤è·¯å¾„"""
        import shutil

        # å°è¯•ä¸åŒçš„å‘½ä»¤åç§°
        possible_commands = ["qwencode", "qwencode-cli", "qwen"]

        for cmd in possible_commands:
            path = shutil.which(cmd)
            if path and not self._is_wrapper_script(path):
                return path

        raise FileNotFoundError("Original qwencode command not found")

    def _is_wrapper_script(self, path: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„åŒ…è£…è„šæœ¬"""
        try:
            with open(path, 'r') as f:
                first_line = f.readline().strip()
                return "QwenCodeWrapper" in first_line or "cross-cli" in first_line
        except:
            return False

    async def execute(self, args: list) -> int:
        """æ‰§è¡ŒåŒ…è£…é€»è¾‘"""

        # æ£€æµ‹è·¨CLIè°ƒç”¨
        if self.adapter.contains_cross_cli_call(args):
            # å¤„ç†è·¨CLIè°ƒç”¨
            result = await self.adapter.handle_cross_cli_request(args)
            if result:
                print(result)
                return 0

        # è°ƒç”¨åŸå§‹qwencode
        import subprocess
        process = await asyncio.create_subprocess_exec(
            self.original_command, *args,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        stdout, stderr = await process.communicate()

        if stdout:
            print(stdout.decode(), end='')
        if stderr:
            print(stderr.decode(), end='', file=sys.stderr)

        return process.returncode

async def main():
    wrapper = QwenCodeWrapper()
    return await wrapper.execute(sys.argv[1:])

if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
```

**é€‚é…å™¨å®ç°ï¼š**
```python
# adapters/qwencode_adapter.py
from ai_cli_adapter.base import BaseCrossCLIAdapter

class QwenCodeCrossCLIAdapter(BaseCrossCLIAdapter):
    def __init__(self):
        super().__init__("qwencode")

    def contains_cross_cli_call(self, args: list) -> bool:
        """æ£€æµ‹å‘½ä»¤è¡Œå‚æ•°ä¸­çš„è·¨CLIè°ƒç”¨"""

        full_command = " ".join(args)
        return self._detect_cross_cli_call(full_command)

    async def handle_cross_cli_request(self, args: list) -> Optional[str]:
        """å¤„ç†è·¨CLIè¯·æ±‚"""

        full_command = " ".join(args)
        context = self._get_current_context()

        return await self.handle_cross_cli_request(full_command, context)

    def _get_current_context(self) -> dict:
        """è·å–å½“å‰ä¸Šä¸‹æ–‡"""
        return {
            "current_file": os.getenv("QWENCODE_CURRENT_FILE"),
            "workspace_path": os.getcwd(),
            "args": sys.argv[1:]
        }
```

**å®‰è£…è„šæœ¬ï¼š**
```bash
#!/bin/bash
# install_qwencode_wrapper.sh

# 1. å¤‡ä»½åŸå§‹å‘½ä»¤
ORIGINAL_QWENCODE=$(which qwencode)
cp "$ORIGINAL_QWENCODE" ~/.local/bin/qwencode_original

# 2. å®‰è£…åŒ…è£…å™¨
INSTALL_DIR="$HOME/.local/ai-cli-cross-cli"
mkdir -p "$INSTALL_DIR"

# å¤åˆ¶åŒ…è£…å™¨æ–‡ä»¶
cp qwencode_cross_cli_wrapper.py "$INSTALL_DIR/"
chmod +x "$INSTALL_DIR/qwencode_cross_cli_wrapper.py"

# 3. åˆ›å»ºç¬¦å·é“¾æ¥
ln -sf "$INSTALL_DIR/qwencode_cross_cli_wrapper.py" ~/.local/bin/qwencode

# 4. æ›´æ–°PATH
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc

echo "âœ… QwenCode CLI è·¨å¹³å°é›†æˆå®‰è£…å®Œæˆ"
```

**ä¼˜åŠ¿ï¼š**
- âœ… å®Œå…¨é€æ˜çš„ç”¨æˆ·ä½“éªŒ
- âœ… ä¿æŒåŸæœ‰å‘½ä»¤æ¥å£
- âœ… æ”¯æŒæ‰€æœ‰åŸæœ‰å‚æ•°
- âœ… é™çº§å¤„ç†æœºåˆ¶

---

## ğŸ”§ 5. Codex CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šConfiguration Injection (é…ç½®æ³¨å…¥)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[Codex CLIå¯åŠ¨] --> B[åŠ è½½é…ç½®æ–‡ä»¶]
    B --> C[æ³¨å…¥è·¨CLIæ¨¡å—]
    C --> D[è¯·æ±‚æ‹¦æˆªå™¨]
    D --> E[ç”¨æˆ·è¾“å…¥]
    E --> F{åŒ…å«è·¨CLIè°ƒç”¨?}
    F -->|æ˜¯| G[è·¨CLIå¤„ç†å™¨]
    F -->|å¦| H[Codexæ­£å¸¸å¤„ç†]
    G --> I[è°ƒç”¨ç›®æ ‡CLI]
    I --> J[è¿”å›ç»“æœ]
```

#### å®ç°ç»†èŠ‚

**é…ç½®æ³¨å…¥ï¼š**
```json
// ~/.codex/config.json
{
  "version": "1.0.0",
  "plugins": {
    "cross_cli_adapter": {
      "enabled": true,
      "module": "codex_cross_cli_adapter",
      "priority": 1,
      "interceptors": [
        {
          "type": "pre_process",
          "method": "intercept_request",
          "condition": "contains_cross_cli_call"
        },
        {
          "type": "post_process",
          "method": "enhance_response",
          "condition": "should_enhance_response"
        }
      ],
      "config": {
        "supported_clis": ["claude", "gemini", "qwencode", "qodercli"],
        "timeout": 30,
        "fallback_enabled": true
      }
    }
  },
  "cross_cli_integration": {
    "auto_detect": true,
    "result_format": "codex_compatible",
    "preserve_context": true
  }
}
```

**é€‚é…å™¨å®ç°ï¼š**
```python
# codex_cross_cli_adapter.py
import json
from typing import Dict, Any, Optional

class CodexCrossCLIAdapter:
    """Codex CLIè·¨CLIé€‚é…å™¨"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.enabled = config.get("enabled", True)
        self.supported_clis = config.get("supported_clis", [])

    async def intercept_request(self, request: str, context: Dict[str, Any]) -> Optional[str]:
        """æ‹¦æˆªCodexè¯·æ±‚"""

        # Codexä¸»è¦å¤„ç†ä»£ç ç›¸å…³çš„è¯·æ±‚
        if self._contains_cross_cli_call(request):
            result = await self._handle_cross_cli_call(request, context)

            if result:
                return result

        return None

    async def enhance_response(self, response: str, original_request: str,
                             context: Dict[str, Any]) -> str:
        """å¢å¼ºCodexå“åº”"""

        # Codexä¸“æ³¨äºä»£ç ç”Ÿæˆï¼Œå¯ä»¥ç”¨å…¶ä»–CLIè¡¥å……
        if self._should_enhance_with_cross_cli(response, original_request):
            enhancement = await self._generate_cross_cli_enhancement(response, original_request)

            if enhancement:
                return f"{response}\n\nğŸ’¡ **è¡¥å……å»ºè®®:**\n{enhancement}"

        return response

    def _contains_cross_cli_call(self, request: str) -> bool:
        """æ£€æµ‹è·¨CLIè°ƒç”¨"""
        import re

        # Codexç”¨æˆ·çš„å¸¸è§æ¨¡å¼
        patterns = [
            r'è¯·ç”¨(claude|gemini|qwencode)æ¥.*å®¡æŸ¥',
            r'è°ƒç”¨(claude|gemini|qwencode).*åˆ†æ',
            r'use (claude|gemini|qwencode) to.*review',
            r'ç”¨(claude|gemini|qwencode).*ç”Ÿæˆ.*æ–‡æ¡£'
        ]

        for pattern in patterns:
            if re.search(pattern, request.lower()):
                return True

        return False
```

**é›†æˆè„šæœ¬ï¼š**
```python
# codex_integration.py
import json
import os
from pathlib import Path

class CodexCLIIntegrator:
    def __init__(self):
        self.config_dir = Path.home() / ".codex"
        self.config_file = self.config_dir / "config.json"

    async def install_cross_cli_support(self):
        """å®‰è£…è·¨CLIæ”¯æŒ"""

        # 1. ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # 2. è¯»å–ç°æœ‰é…ç½®
        existing_config = {}
        if self.config_file.exists():
            with open(self.config_file, 'r') as f:
                existing_config = json.load(f)

        # 3. æ³¨å…¥è·¨CLIé…ç½®
        cross_cli_config = {
            "cross_cli_adapter": {
                "enabled": True,
                "module": "codex_cross_cli_adapter.CodexCrossCLIAdapter",
                "priority": 1,
                "interceptors": [
                    {
                        "type": "pre_process",
                        "method": "intercept_request",
                        "condition": "contains_cross_cli_call"
                    }
                ],
                "config": {
                    "supported_clis": ["claude", "gemini", "qwencode", "qodercli"],
                    "timeout": 30
                }
            }
        }

        # 4. åˆå¹¶é…ç½®
        if "plugins" not in existing_config:
            existing_config["plugins"] = {}

        existing_config["plugins"].update(cross_cli_config)

        # 5. å†™å…¥é…ç½®
        with open(self.config_file, 'w') as f:
            json.dump(existing_config, f, indent=2)

        print("âœ… Codex CLI è·¨å¹³å°æ”¯æŒå·²å®‰è£…")
```

**ä¼˜åŠ¿ï¼š**
- âœ… æ— éœ€ä¿®æ”¹Codexæºç 
- âœ… é€šè¿‡é…ç½®æ–‡ä»¶æ§åˆ¶
- âœ… çƒ­æ’æ‹”æ”¯æŒ
- âœ… ä¿æŒåŸæœ‰æ¥å£

---

## ğŸ”§ 6. QoderCLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šEnvironment Variable Hook (ç¯å¢ƒå˜é‡é’©å­)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[QoderCLIå¯åŠ¨] --> B[æ£€æŸ¥ç¯å¢ƒå˜é‡]
    B --> C[åŠ è½½é’©å­æ¨¡å—]
    C --> D[è¯·æ±‚å¤„ç†é’©å­]
    D --> E[ç”¨æˆ·è¾“å…¥]
    E --> F[è·¨CLIæ£€æµ‹]
    F --> G{åŒ…å«è·¨CLIè°ƒç”¨?}
    G -->|æ˜¯| H[è·¨CLIå¤„ç†å™¨]
    G -->|å¦| I[QoderCLIæ­£å¸¸å¤„ç†]
    H --> J[è°ƒç”¨ç›®æ ‡CLI]
    J --> K[è¿”å›ç»“æœ]
```

#### å®ç°ç»†èŠ‚

**ç¯å¢ƒå˜é‡é…ç½®ï¼š**
```bash
# ~/.bashrc æˆ– ~/.zshrc
export QODER_CROSS_CLI_ENABLED=true
export QODER_CROSS_CLI_HOOKS=pre_process,post_process
export QODER_CROSS_CLI_MODULE=qoder_cross_cli_adapter
export QODER_CROSS_CLI_CONFIG_PATH="$HOME/.qoder/cross_cli_config.json"
export QODER_CROSS_CLI_TIMEOUT=30
```

**é…ç½®æ–‡ä»¶ï¼š**
```json
// ~/.qoder/cross_cli_config.json
{
  "enabled": true,
  "hooks": {
    "pre_process": {
      "module": "qoder_cross_cli_adapter.QoderCrossCLIAdapter",
      "method": "intercept_input",
      "condition": "contains_cross_cli_call"
    },
    "post_process": {
      "module": "qoder_cross_cli_adapter.QoderCrossCLIAdapter",
      "method": "enhance_output",
      "condition": "should_enhance_output"
    }
  },
  "supported_clis": [
    "claude", "gemini", "codex", "qwencode",
    "iflowcli", "codebuddycli", "kimi"
  ],
  "integration_settings": {
    "auto_detect": true,
    "fallback_enabled": true,
    "result_format": "qoder_compatible",
    "timeout": 30
  }
}
```

**é’©å­é€‚é…å™¨ï¼š**
```python
# qoder_cross_cli_adapter.py
import os
import json
from typing import Optional, Dict, Any

class QoderCrossCLIAdapter:
    """QoderCLIè·¨CLIé€‚é…å™¨"""

    def __init__(self):
        self.enabled = os.getenv("QODER_CROSS_CLI_ENABLED", "false").lower() == "true"
        self.config_path = os.getenv("QODER_CROSS_CLI_CONFIG_PATH")
        self.config = self._load_config()
        self.supported_clis = self.config.get("supported_clis", [])

    def _load_config(self) -> Dict[str, Any]:
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        if self.config_path and os.path.exists(self.config_path):
            with open(self.config_path, 'r') as f:
                return json.load(f)
        return {}

    def intercept_input(self, user_input: str, context: Dict[str, Any]) -> Optional[str]:
        """è¾“å…¥æ‹¦æˆªé’©å­"""

        if not self.enabled:
            return None

        if self._contains_cross_cli_call(user_input):
            result = self._handle_cross_cli_call(user_input, context)

            if result:
                return result

        return None

    def enhance_output(self, output: str, original_input: str,
                      context: Dict[str, Any]) -> str:
        """è¾“å‡ºå¢å¼ºé’©å­"""

        if not self.enabled:
            return output

        # QoderCLIä¸“æ³¨äºä»£ç è´¨é‡ï¼Œå¯ä»¥ç”¨å…¶ä»–CLIè¡¥å……
        if self._should_enhance_with_cross_cli(output, original_input):
            enhancement = self._generate_cross_cli_enhancement(output, original_input)

            if enhancement:
                return f"{output}\n\nğŸ” **è¡¥å……å»ºè®®:**\n{enhancement}"

        return output

    def _contains_cross_cli_call(self, text: str) -> bool:
        """æ£€æµ‹è·¨CLIè°ƒç”¨"""
        import re

        # QoderCLIç”¨æˆ·çš„ä½¿ç”¨æ¨¡å¼
        patterns = [
            r'è¯·ç”¨(claude|gemini|qwencode).*å®¡æŸ¥.*è´¨é‡',
            r'è°ƒç”¨(claude|gemini|qwencode).*åˆ†æ.*æ¶æ„',
            r'use (claude|gemini|qwencode) to.*design',
            r'ç”¨(claude|gemini|qwencode).*æµ‹è¯•.*ä»£ç '
        ]

        for pattern in patterns:
            if re.search(pattern, text.lower()):
                return True

        return False
```

**é›†æˆè„šæœ¬ï¼š**
```bash
#!/bin/bash
# install_qoder_cross_cli.sh

# 1. è®¾ç½®ç¯å¢ƒå˜é‡
cat >> ~/.bashrc << 'EOF'

# QoderCLI è·¨å¹³å°é›†æˆ
export QODER_CROSS_CLI_ENABLED=true
export QODER_CROSS_CLI_HOOKS=pre_process,post_process
export QODER_CROSS_CLI_MODULE=qoder_cross_cli_adapter
export QODER_CROSS_CLI_CONFIG_PATH="$HOME/.qoder/cross_cli_config.json"
export QODER_CROSS_CLI_TIMEOUT=30
EOF

# 2. åˆ›å»ºé…ç½®ç›®å½•å’Œæ–‡ä»¶
mkdir -p ~/.qoder

cat > ~/.qoder/cross_cli_config.json << 'EOF'
{
  "enabled": true,
  "hooks": {
    "pre_process": {
      "module": "qoder_cross_cli_adapter.QoderCrossCLIAdapter",
      "method": "intercept_input",
      "condition": "contains_cross_cli_call"
    }
  },
  "supported_clis": [
    "claude", "gemini", "codex", "qwencode",
    "iflowcli", "codebuddycli", "kimi"
  ]
}
EOF

# 3. å®‰è£…é€‚é…å™¨æ¨¡å—
pip install qoder-cross-cli-adapter

echo "âœ… QoderCLI è·¨å¹³å°é›†æˆå·²å®‰è£…"
echo "è¯·è¿è¡Œ: source ~/.bashrc ä»¥ç”Ÿæ•ˆ"
```

**ä¼˜åŠ¿ï¼š**
- âœ… æ— éœ€ä¿®æ”¹QoderCLIä»£ç 
- âœ… é€šè¿‡ç¯å¢ƒå˜é‡æ§åˆ¶
- âœ… çµæ´»çš„é…ç½®ç®¡ç†
- âœ… æ”¯æŒåŠ¨æ€å¯ç”¨/ç¦ç”¨

---

## ğŸ”§ 7. iFlowCLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šPre/Post Scripts (å‰åç½®è„šæœ¬)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[iFlowCLIå·¥ä½œæµ] --> B[å‰ç½®è„šæœ¬]
    B --> C[å·¥ä½œæµèŠ‚ç‚¹å¤„ç†]
    C --> D[è·¨CLIæ£€æµ‹]
    D --> E{éœ€è¦è·¨CLIè°ƒç”¨?}
    E -->|æ˜¯| F[è·¨CLIå¤„ç†å™¨]
    E -->|å¦| G[ç»§ç»­å·¥ä½œæµ]
    F --> H[è°ƒç”¨ç›®æ ‡CLI]
    H --> I[åç½®è„šæœ¬]
    I --> J[å·¥ä½œæµç»§ç»­]
    G --> I
```

#### å®ç°ç»†èŠ‚

**å·¥ä½œæµé…ç½®ï¼š**
```yaml
# ~/.iflow/workflows/cross_cli_integration.yaml
name: "Cross CLI Integration Workflow"
description: "é›†æˆè·¨CLIè°ƒç”¨èƒ½åŠ›çš„å·¥ä½œæµ"

triggers:
  - type: "user_input"
    pattern: "contains_cross_cli_call"

steps:
  - name: "detect_cross_cli"
    type: "script"
    script: "detect_cross_cli.py"
    outputs:
      - "target_cli"
      - "clean_request"

  - name: "execute_cross_cli"
    type: "conditional"
    condition: "target_cli != null"
    steps:
      - name: "call_target_cli"
        type: "script"
        script: "execute_cross_cli.py"
        inputs:
          - "target_cli"
          - "clean_request"
      - name: "format_result"
        type: "script"
        script: "format_result.py"

  - name: "continue_workflow"
    type: "continue"
    when: "target_cli == null"

config:
  cross_cli:
    enabled: true
    supported_clis: ["claude", "gemini", "codex", "qwencode", "qodercli", "codebuddycli", "kimi"]
    timeout: 30
    fallback_enabled: true
```

**æ£€æµ‹è„šæœ¬ï¼š**
```python
# detect_cross_cli.py
import json
import sys
import re

def detect_cross_cli_call(user_input: str) -> dict:
    """æ£€æµ‹è·¨CLIè°ƒç”¨"""

    supported_clis = ["claude", "gemini", "codex", "qwencode", "qodercli", "codebuddycli", "kimi"]

    # iFlowCLIç‰¹æœ‰çš„æ¨¡å¼
    patterns = [
        r'è¯·ç”¨(\w+)CLI?æ¥.*æ‰§è¡Œ.*å·¥ä½œæµ',
        r'è°ƒç”¨(\w+)CLI?æ¥.*å¤„ç†.*ä»»åŠ¡',
        r'use (\w+)CLI? to.*execute.*workflow',
        r'ç”¨(\w+)CLI?æ¥.*è‡ªåŠ¨åŒ–.*æµç¨‹'
    ]

    for pattern in patterns:
        match = re.search(pattern, user_input.lower())
        if match:
            target_cli = match.group(1).lower()
            if target_cli in supported_clis:
                # æ¸…ç†è¯·æ±‚ï¼Œç§»é™¤CLIå¼•ç”¨
                clean_request = user_input
                for cli in supported_clis:
                    clean_request = re.sub(fr'è¯·ç”¨{cli}CLI?æ¥', '', clean_request, flags=re.IGNORECASE)
                    clean_request = re.sub(fr'è°ƒç”¨{cli}CLI?æ¥', '', clean_request, flags=re.IGNORECASE)
                    clean_request = re.sub(fr'use {cli}CLI? to', '', clean_request, flags=re.IGNORECASE)
                    clean_request = re.sub(fr'ç”¨{cli}CLI?æ¥', '', clean_request, flags=re.IGNORECASE)

                clean_request = clean_request.strip()

                return {
                    "target_cli": target_cli,
                    "clean_request": clean_request,
                    "detected": True
                }

    return {
        "target_cli": None,
        "clean_request": user_input,
        "detected": False
    }

if __name__ == "__main__":
    user_input = sys.argv[1] if len(sys.argv) > 1 else ""
    result = detect_cross_cli_call(user_input)
    print(json.dumps(result))
```

**æ‰§è¡Œè„šæœ¬ï¼š**
```python
# execute_cross_cli.py
import json
import sys
import asyncio
import subprocess
from pathlib import Path

async def execute_cross_cli(target_cli: str, request: str) -> dict:
    """æ‰§è¡Œè·¨CLIè°ƒç”¨"""

    try:
        # æŸ¥æ‰¾ç›®æ ‡CLIå‘½ä»¤
        cli_commands = {
            'claude': ['claude', 'claude-code'],
            'gemini': ['gemini', 'gemini-cli'],
            'codex': ['codex', 'codex-cli'],
            'qwencode': ['qwencode', 'qwencode-cli'],
            'qodercli': ['qodercli', 'qoder'],
            'codebuddycli': ['codebuddy', 'codebuddy-cli'],
            'kimi': ['kimi', 'kimi-cli']
        }

        command = None
        for cmd in cli_commands.get(target_cli, []):
            result = subprocess.run(['which', cmd], capture_output=True, text=True)
            if result.returncode == 0:
                command = result.stdout.strip()
                break

        if not command:
            return {
                "success": False,
                "error": f"{target_cli} CLI not found",
                "result": ""
            }

        # æ‰§è¡Œç›®æ ‡CLI
        process = await asyncio.create_subprocess_exec(
            command, request,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        stdout, stderr = await process.communicate()

        if process.returncode == 0:
            return {
                "success": True,
                "result": stdout.decode().strip(),
                "error": ""
            }
        else:
            return {
                "success": False,
                "error": stderr.decode().strip(),
                "result": ""
            }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "result": ""
        }

if __name__ == "__main__":
    target_cli = sys.argv[1] if len(sys.argv) > 1 else ""
    request = sys.argv[2] if len(sys.argv) > 2 else ""

    result = asyncio.run(execute_cross_cli(target_cli, request))
    print(json.dumps(result))
```

**å®‰è£…é…ç½®ï¼š**
```bash
#!/bin/bash
# install_iflow_cross_cli.sh

# 1. åˆ›å»ºå·¥ä½œæµç›®å½•
mkdir -p ~/.iflow/workflows

# 2. å¤åˆ¶å·¥ä½œæµé…ç½®
cp cross_cli_integration.yaml ~/.iflow/workflows/

# 3. å¤åˆ¶è„šæœ¬æ–‡ä»¶
mkdir -p ~/.iflow/scripts
cp detect_cross_cli.py ~/.iflow/scripts/
cp execute_cross_cli.py ~/.iflow/scripts/
cp format_result.py ~/.iflow/scripts/

# 4. å®‰è£…Pythonä¾èµ–
pip install iflow-cross-cli-tools

# 5. é…ç½®iFlowCLI
iflow config set cross_cli.enabled true
iflow config set cross_cli.workflow_path ~/.iflow/workflows/cross_cli_integration.yaml

echo "âœ… iFlowCLI è·¨å¹³å°é›†æˆå·²å®‰è£…"
```

**ä¼˜åŠ¿ï¼š**
- âœ… ä¸å·¥ä½œæµç³»ç»Ÿå®Œç¾é›†æˆ
- âœ… æ”¯æŒå¤æ‚çš„å¤šæ­¥éª¤æµç¨‹
- âœ… å¯è§†åŒ–é…ç½®
- âœ… æ”¯æŒæ¡ä»¶æ‰§è¡Œ

---

## ğŸ”§ 8. CodeBuddy CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šPlugin System (æ’ä»¶ç³»ç»Ÿ)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[CodeBuddy CLIå¯åŠ¨] --> B[æ’ä»¶åŠ è½½å™¨]
    B --> C[åŠ è½½è·¨CLIæ’ä»¶]
    C --> D[ç”¨æˆ·è¾“å…¥]
    D --> E[æ’ä»¶æ‹¦æˆªå™¨]
    E --> F{åŒ…å«è·¨CLIè°ƒç”¨?}
    F -->|æ˜¯| G[è·¨CLIå¤„ç†å™¨]
    F -->|å¦| H[CodeBuddyæ­£å¸¸å¤„ç†]
    G --> I[è°ƒç”¨ç›®æ ‡CLI]
    I --> J[æ’ä»¶åå¤„ç†å™¨]
    J --> K[è¿”å›ç»™ç”¨æˆ·]
    H --> K
```

#### å®ç°ç»†èŠ‚

**æ’ä»¶å®šä¹‰ï¼š**
```python
# codebuddy_cross_cli_plugin.py
from codebuddy.plugins import Plugin, PluginContext, PluginResponse

class CodeBuddyCrossCLIPlugin(Plugin):
    """CodeBuddy CLIè·¨CLIæ’ä»¶"""

    def __init__(self):
        super().__init__()
        self.name = "cross-cli-adapter"
        self.version = "1.0.0"
        self.description = "Enable cross-CLI calling capabilities"
        self.author = "AI CLI Cross Platform Team"

        # æ”¯æŒçš„CLIå·¥å…·
        self.supported_clis = [
            "claude", "gemini", "codex", "qwencode",
            "qodercli", "iflowcli", "kimi"
        ]

    async def on_load(self) -> bool:
        """æ’ä»¶åŠ è½½æ—¶è°ƒç”¨"""
        print(f"ğŸ”Œ Loading {self.name} plugin v{self.version}")
        return True

    async def on_unload(self) -> bool:
        """æ’ä»¶å¸è½½æ—¶è°ƒç”¨"""
        print(f"ğŸ”Œ Unloading {self.name} plugin")
        return True

    async def on_user_input(self, context: PluginContext) -> PluginResponse:
        """ç”¨æˆ·è¾“å…¥å¤„ç† - ä¸»è¦æ‹¦æˆªç‚¹"""

        user_input = context.user_input

        # æ£€æµ‹è·¨CLIè°ƒç”¨
        if self._contains_cross_cli_call(user_input):
            # CodeBuddyæ˜¯æ•™è‚²å¯¼å‘çš„ï¼Œé¼“åŠ±ç”¨æˆ·å­¦ä¹ ä¸åŒå·¥å…·
            target_cli = self._detect_target_cli(user_input)

            if target_cli:
                # æä¾›æ•™è‚²æ€§è¯´æ˜
                educational_note = self._generate_educational_note(target_cli)

                # æ‰§è¡Œè·¨CLIè°ƒç”¨
                result = await self._execute_cross_cli_call(target_cli, user_input, context)

                if result:
                    response_text = f"""{educational_note}

ğŸ¤– **æ¥è‡ª {target_cli.upper()} çš„å›ç­”:**

{result}

---
ğŸ’¡ **å­¦ä¹ æç¤º:** é€šè¿‡è¿™ä¸ªè°ƒç”¨ï¼Œæ‚¨å¯ä»¥äº†è§£åˆ°ä¸åŒAIå·¥å…·çš„ä¸“é•¿å’Œèƒ½åŠ›å·®å¼‚ã€‚"""

                    return PluginResponse(
                        success=True,
                        response=response_text,
                        metadata={"source": "cross_cli", "target": target_cli}
                    )

        return PluginResponse(success=False)  # è®©CodeBuddyæ­£å¸¸å¤„ç†

    async def on_response(self, response: str, context: PluginContext) -> str:
        """å“åº”åå¤„ç† - æ•™è‚²æ€§å¢å¼º"""

        # CodeBuddyä¸“æ³¨äºæ•™è‚²ï¼Œå¯ä»¥å»ºè®®å…¶ä»–å·¥å…·
        if self._should_suggest_other_tools(response, context):
            suggestions = self._generate_tool_suggestions(response, context)

            if suggestions:
                return f"{response}\n\nğŸ“ **æ‰©å±•å­¦ä¹ å»ºè®®:**\n{suggestions}"

        return response

    def _contains_cross_cli_call(self, text: str) -> bool:
        """æ£€æµ‹è·¨CLIè°ƒç”¨"""
        import re

        # CodeBuddyç”¨æˆ·çš„å­¦ä¹ å¯¼å‘æ¨¡å¼
        patterns = [
            r'è¯·ç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|kimi)æ¥.*æ•™æˆ‘',
            r'è°ƒç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|kimi)æ¥.*å­¦ä¹ ',
            r'use (claude|gemini|codex|qwencode|qodercli|iflowcli|kimi) to.*teach',
            r'ç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|kimi)æ¥.*è§£é‡Š'
        ]

        for pattern in patterns:
            if re.search(pattern, text.lower()):
                return True

        return False

    def _detect_target_cli(self, text: str) -> Optional[str]:
        """æ£€æµ‹ç›®æ ‡CLI"""
        import re

        for cli in self.supported_clis:
            if re.search(fr'\b{cli}\b', text.lower()):
                return cli

        return None

    def _generate_educational_note(self, target_cli: str) -> str:
        """ç”Ÿæˆæ•™è‚²æ€§è¯´æ˜"""

        educational_notes = {
            "claude": "ğŸ“ **Claude** æ“…é•¿å¤æ‚çš„æ¨ç†å’Œæ¶æ„è®¾è®¡ï¼Œç‰¹åˆ«é€‚åˆå¤„ç†éœ€è¦æ·±åº¦åˆ†æçš„ä»»åŠ¡ã€‚",
            "gemini": "ğŸ“ **Gemini** å…·æœ‰å¼ºå¤§çš„å¤šæ¨¡æ€èƒ½åŠ›ï¼Œèƒ½å¤Ÿå¤„ç†å›¾åƒå’Œæ–‡æœ¬çš„ç»„åˆä»»åŠ¡ã€‚",
            "codex": "ğŸ“ **Codex** ä¸“æ³¨äºä»£ç ç”Ÿæˆå’Œè¡¥å…¨ï¼Œåœ¨ç¼–ç¨‹æŠ€å·§å’Œæ¨¡å¼åŒ¹é…æ–¹é¢è¡¨ç°å‡ºè‰²ã€‚",
            "qwencode": "ğŸ“ **QwenCode** å¯¹ä¸­æ–‡å’Œæœ¬åœ°åŒ–æ”¯æŒä¼˜ç§€ï¼Œé€‚åˆå¤„ç†ä¸­æ–‡ç¼–ç¨‹ä»»åŠ¡ã€‚",
            "qodercli": "ğŸ“ **QoderCLI** ä¸“æ³¨äºä»£ç è´¨é‡å’Œä¼ä¸šæ ‡å‡†ï¼Œé€‚åˆéœ€è¦ä¸¥æ ¼è§„èŒƒçš„åœºæ™¯ã€‚",
            "iflowcli": "ğŸ“ **iFlowCLI** ä¸“ç²¾äºå·¥ä½œæµè‡ªåŠ¨åŒ–ï¼Œèƒ½å¤Ÿä¼˜åŒ–å’Œè‡ªåŠ¨åŒ–å¤æ‚çš„å¼€å‘æµç¨‹ã€‚",
            "kimi": "ğŸ“ **Kimi** å…·æœ‰å¼ºå¤§çš„ç½‘ç»œæœç´¢å’Œä¿¡æ¯æ•´åˆèƒ½åŠ›ï¼Œé€‚åˆéœ€è¦æœ€æ–°ä¿¡æ¯çš„ä»»åŠ¡ã€‚"
        }

        return educational_notes.get(target_cli, f"ğŸ“ **{target_cli}** æ˜¯ä¸€ä¸ªå¼ºå¤§çš„AIå·¥å…·ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å®ƒçš„ä¸“é•¿ã€‚")
```

**æ’ä»¶é…ç½®ï¼š**
```json
// ~/.codebuddy/plugins.json
{
  "plugins": [
    {
      "name": "cross-cli-adapter",
      "module": "codebuddy_cross_cli_plugin.CodeBuddyCrossCLIPlugin",
      "enabled": true,
      "priority": 1,
      "hooks": [
        "on_load",
        "on_unload",
        "on_user_input",
        "on_response"
      ],
      "config": {
        "supported_clis": [
          "claude", "gemini", "codex", "qwencode",
          "qodercli", "iflowcli", "kimi"
        ],
        "educational_mode": true,
        "timeout": 30,
        "show_tool_tips": true
      }
    }
  ]
}
```

**å®‰è£…è„šæœ¬ï¼š**
```python
# install_codebuddy_cross_cli.py
import json
import os
from pathlib import Path

class CodeBuddyCrossCLIInstaller:
    def __init__(self):
        self.config_dir = Path.home() / ".codebuddy"
        self.plugins_file = self.config_dir / "plugins.json"

    async def install(self):
        """å®‰è£…CodeBuddyè·¨CLIæ’ä»¶"""

        # 1. ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # 2. è¯»å–ç°æœ‰æ’ä»¶é…ç½®
        existing_plugins = []
        if self.plugins_file.exists():
            with open(self.plugins_file, 'r') as f:
                try:
                    existing_config = json.load(f)
                    existing_plugins = existing_config.get("plugins", [])
                except:
                    existing_plugins = []

        # 3. æ·»åŠ è·¨CLIæ’ä»¶
        cross_cli_plugin = {
            "name": "cross-cli-adapter",
            "module": "codebuddy_cross_cli_plugin.CodeBuddyCrossCLIPlugin",
            "enabled": True,
            "priority": 1,
            "hooks": ["on_load", "on_unload", "on_user_input", "on_response"],
            "config": {
                "supported_clis": [
                    "claude", "gemini", "codex", "qwencode",
                    "qodercli", "iflowcli", "kimi"
                ],
                "educational_mode": true,
                "timeout": 30,
                "show_tool_tips": true
            }
        }

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        for i, plugin in enumerate(existing_plugins):
            if plugin.get("name") == "cross-cli-adapter":
                existing_plugins[i] = cross_cli_plugin
                break
        else:
            existing_plugins.append(cross_cli_plugin)

        # 4. å†™å…¥é…ç½®
        config = {
            "version": "1.0.0",
            "plugins": existing_plugins
        }

        with open(self.plugins_file, 'w') as f:
            json.dump(config, f, indent=2)

        # 5. å®‰è£…æ’ä»¶æ¨¡å—
        # è¿™é‡Œåº”è¯¥å°†æ’ä»¶æ–‡ä»¶å¤åˆ¶åˆ°CodeBuddyçš„æ’ä»¶ç›®å½•
        plugin_dir = self.config_dir / "plugins"
        plugin_dir.mkdir(exist_ok=True)

        # å¤åˆ¶æ’ä»¶æ–‡ä»¶ï¼ˆå‡è®¾æ–‡ä»¶åœ¨å½“å‰ç›®å½•ï¼‰
        import shutil
        plugin_file = Path("codebuddy_cross_cli_plugin.py")
        if plugin_file.exists():
            shutil.copy2(plugin_file, plugin_dir / "codebuddy_cross_cli_plugin.py")

        print("âœ… CodeBuddy CLI è·¨å¹³å°æ’ä»¶å·²å®‰è£…")
        print("ğŸ“ è¯·é‡å¯ CodeBuddy CLI ä»¥åŠ è½½æ–°æ’ä»¶")

if __name__ == "__main__":
    import asyncio
    installer = CodeBuddyCrossCLIInstaller()
    asyncio.run(installer.install())
```

**ä¼˜åŠ¿ï¼š**
- âœ… å®Œç¾é›†æˆCodeBuddyçš„æ•™è‚²ç†å¿µ
- âœ… æä¾›å­¦ä¹ å¯¼å‘çš„è·¨CLIä½“éªŒ
- âœ… æ ‡å‡†çš„æ’ä»¶ç³»ç»Ÿæ”¯æŒ
- âœ… ä¸°å¯Œçš„ç”Ÿå‘½å‘¨æœŸé’©å­

---

## ğŸ”§ 9. Kimi CLI é›†æˆæ–¹æ¡ˆ

### æœ€ä¼˜æœºåˆ¶ï¼šAPI Middleware (APIä¸­é—´ä»¶)

#### æŠ€æœ¯æ¶æ„
```mermaid
graph TB
    A[ç”¨æˆ·è¯·æ±‚] --> B[APIä¸­é—´ä»¶]
    B --> C[è¯·æ±‚è§£æå™¨]
    C --> D[è·¨CLIæ£€æµ‹å™¨]
    D --> E{åŒ…å«è·¨CLIè°ƒç”¨?}
    E -->|æ˜¯| F[è·¨CLIå¤„ç†å™¨]
    E -->|å¦| G[Kimi APIè°ƒç”¨]
    F --> H[è°ƒç”¨ç›®æ ‡CLI]
    H --> I[ç»“æœæ•´åˆå™¨]
    I --> J[è¿”å›ç»™ç”¨æˆ·]
    G --> I
```

#### å®ç°ç»†èŠ‚

**ä¸­é—´ä»¶å®ç°ï¼š**
```python
# kimi_api_middleware.py
from typing import Dict, Any, Optional, Callable
import asyncio
import json

class KimiAPIMiddleware:
    """Kimi CLI APIä¸­é—´ä»¶"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.enabled = config.get("enabled", True)
        self.supported_clis = config.get("supported_clis", [
            "claude", "gemini", "codex", "qwencode", "qodercli", "iflowcli", "codebuddycli"
        ])

        # æ³¨å†Œä¸­é—´ä»¶é’©å­
        self.pre_process_hooks = []
        self.post_process_hooks = []

        if config.get("cross_cli_enabled", True):
            self.pre_process_hooks.append(self._pre_process_cross_cli)
            self.post_process_hooks.append(self._post_process_cross_cli)

    async def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """å¤„ç†APIè¯·æ±‚"""

        # æ‰§è¡Œå‰ç½®å¤„ç†é’©å­
        for hook in self.pre_process_hooks:
            result = await hook(request)
            if result:
                return result

        # è°ƒç”¨åŸå§‹Kimi API
        original_response = await self._call_kimi_api(request)

        # æ‰§è¡Œåç½®å¤„ç†é’©å­
        for hook in self.post_process_hooks:
            enhanced_response = await hook(original_response, request)
            if enhanced_response:
                return enhanced_response

        return original_response

    async def _pre_process_cross_cli(self, request: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """å‰ç½®å¤„ç†ï¼šè·¨CLIæ£€æµ‹"""

        user_input = request.get("prompt", "")

        if self._contains_cross_cli_call(user_input):
            # Kimiå…·æœ‰å¼ºå¤§çš„ä¿¡æ¯æ£€ç´¢èƒ½åŠ›ï¼Œä½†ä»éœ€å…¶ä»–CLIçš„ä¸“ä¸šèƒ½åŠ›
            target_cli = self._detect_target_cli(user_input)

            if target_cli:
                # æ‰§è¡Œè·¨CLIè°ƒç”¨
                cross_result = await self._execute_cross_cli(target_cli, user_input)

                if cross_result:
                    return {
                        "type": "cross_cli_response",
                        "source": target_cli,
                        "content": cross_result,
                        "metadata": {
                            "original_request": user_input,
                            "middleware": "kimi_cross_cli"
                        }
                    }

        return None

    async def _post_process_cross_cli(self, response: Dict[str, Any],
                                    original_request: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """åç½®å¤„ç†ï¼šå¢å¼ºå“åº”"""

        # Kimiæ“…é•¿ä¿¡æ¯æ£€ç´¢ï¼Œå¯ä»¥å»ºè®®å…¶ä»–CLIçš„ä¸“ä¸šåˆ†æ
        content = response.get("content", "")
        user_input = original_request.get("prompt", "")

        if self._should_suggest_cross_cli(content, user_input):
            suggestion = self._generate_cross_cli_suggestion(content, user_input)

            if suggestion:
                enhanced_content = f"{content}\n\nğŸ” **ä¸“ä¸šå·¥å…·å»ºè®®:**\n{suggestion}"

                return {
                    "type": "enhanced_response",
                    "content": enhanced_content,
                    "metadata": {
                        "original_length": len(content),
                        "enhancement": "cross_cli_suggestion"
                    }
                }

        return None

    def _contains_cross_cli_call(self, text: str) -> bool:
        """æ£€æµ‹è·¨CLIè°ƒç”¨"""
        import re

        # Kimiç”¨æˆ·çš„ç ”ç©¶å¯¼å‘æ¨¡å¼
        patterns = [
            r'è¯·ç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|codebuddycli).*åˆ†æ.*ä¸“ä¸š',
            r'è°ƒç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|codebuddycli).*æ·±åº¦.*ç ”ç©¶',
            r'use (claude|gemini|codex|qwencode|qodercli|iflowcli|codebuddycli) to.*expert.*analysis',
            r'ç”¨(claude|gemini|codex|qwencode|qodercli|iflowcli|codebuddycli)æ¥.*ä¸“ä¸š.*è¯„ä¼°'
        ]

        for pattern in patterns:
            if re.search(pattern, text.lower()):
                return True

        return False
```

**APIé…ç½®ï¼š**
```json
// ~/.kimi/api_config.json
{
  "version": "1.0.0",
  "api_endpoint": "https://api.kimi.ai/v1",
  "middleware": {
    "enabled": true,
    "plugins": [
      {
        "name": "cross_cli_middleware",
        "module": "kimi_api_middleware.KimiAPIMiddleware",
        "priority": 1,
        "config": {
          "enabled": true,
          "cross_cli_enabled": true,
          "supported_clis": [
            "claude", "gemini", "codex", "qwencode",
            "qodercli", "iflowcli", "codebuddycli"
          ],
          "timeout": 30,
          "max_concurrent": 2,
          "cache_enabled": true,
          "cache_ttl": 300
        }
      }
    ]
  },
  "cross_cli_settings": {
    "auto_detect": true,
    "fallback_to_kimi": true,
    "enhance_responses": true,
    "show_tool_recommendations": true
  }
}
```

**é›†æˆè„šæœ¬ï¼š**
```python
# kimi_cross_cli_integration.py
import json
import os
from pathlib import Path

class KimiCrossCLIIntegrator:
    def __init__(self):
        self.config_dir = Path.home() / ".kimi"
        self.api_config_file = self.config_dir / "api_config.json"

    async def install(self):
        """å®‰è£…Kimi CLIè·¨CLIé›†æˆ"""

        # 1. ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(parents=True, exist_ok=True)

        # 2. è¯»å–ç°æœ‰APIé…ç½®
        existing_config = {}
        if self.api_config_file.exists():
            with open(self.api_config_file, 'r') as f:
                try:
                    existing_config = json.load(f)
                except:
                    existing_config = {}

        # 3. æ·»åŠ è·¨CLIä¸­é—´ä»¶é…ç½®
        middleware_config = {
            "enabled": True,
            "plugins": [
                {
                    "name": "cross_cli_middleware",
                    "module": "kimi_api_middleware.KimiAPIMiddleware",
                    "priority": 1,
                    "config": {
                        "enabled": True,
                        "cross_cli_enabled": True,
                        "supported_clis": [
                            "claude", "gemini", "codex", "qwencode",
                            "qodercli", "iflowcli", "codebuddycli"
                        ],
                        "timeout": 30,
                        "max_concurrent": 2,
                        "cache_enabled": True,
                        "cache_ttl": 300
                    }
                }
            ]
        }

        # 4. åˆå¹¶é…ç½®
        if "middleware" not in existing_config:
            existing_config["middleware"] = {}

        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è·¨CLIä¸­é—´ä»¶
        existing_plugins = existing_config["middleware"].get("plugins", [])
        for i, plugin in enumerate(existing_plugins):
            if plugin.get("name") == "cross_cli_middleware":
                existing_plugins[i] = middleware_config["plugins"][0]
                break
        else:
            existing_plugins.extend(middleware_config["plugins"])

        existing_config["middleware"]["plugins"] = existing_plugins

        # 5. æ·»åŠ è·¨CLIè®¾ç½®
        cross_cli_settings = {
            "auto_detect": True,
            "fallback_to_kimi": True,
            "enhance_responses": True,
            "show_tool_recommendations": True
        }

        existing_config["cross_cli_settings"] = cross_cli_settings

        # 6. å†™å…¥é…ç½®
        with open(self.api_config_file, 'w') as f:
            json.dump(existing_config, f, indent=2)

        # 7. å®‰è£…ä¸­é—´ä»¶æ¨¡å—
        middleware_dir = self.config_dir / "middleware"
        middleware_dir.mkdir(exist_ok=True)

        # å¤åˆ¶ä¸­é—´ä»¶æ–‡ä»¶
        import shutil
        middleware_file = Path("kimi_api_middleware.py")
        if middleware_file.exists():
            shutil.copy2(middleware_file, middleware_dir / "kimi_api_middleware.py")

        print("âœ… Kimi CLI è·¨å¹³å°é›†æˆå·²å®‰è£…")
        print("ğŸ“ ä¸­é—´ä»¶å°†åœ¨ä¸‹æ¬¡APIè°ƒç”¨æ—¶ç”Ÿæ•ˆ")

if __name__ == "__main__":
    import asyncio
    integrator = KimiCrossCLIIntegrator()
    asyncio.run(integrator.install())
```

**ä¼˜åŠ¿ï¼š**
- âœ… ä¸Kimiçš„APIæ¶æ„å®Œç¾é›†æˆ
- âœ… æ”¯æŒå¤æ‚çš„è¯·æ±‚/å“åº”å¤„ç†
- âœ… ç¼“å­˜å’Œå¹¶å‘æ§åˆ¶
- âœ… å¢å¼ºKimiçš„ä¿¡æ¯æ£€ç´¢èƒ½åŠ›

---

## ğŸ“Š é›†æˆæ–¹æ¡ˆæ€»ç»“è¡¨

| CLIå·¥å…· | æœ€ä¼˜æœºåˆ¶ | å®ç°å¤æ‚åº¦ | æ€§èƒ½å½±å“ | ç»´æŠ¤éš¾åº¦ | ç”¨æˆ·é€æ˜åº¦ |
|---------|----------|------------|----------|----------|------------|
| **Claude CLI** | Hookç³»ç»Ÿ | ä½ | æä½ | ä½ | å®Œå…¨é€æ˜ |
| **Aider CLI** | Pythonæ’ä»¶ç»§æ‰¿ | ä¸­ | ä½ | ä¸­ | å®Œå…¨é€æ˜ |
| **Gemini CLI** | æ¨¡å—+é…ç½® | ä¸­ | ä½ | ä¸­ | å®Œå…¨é€æ˜ |
| **QwenCode CLI** | PythonåŒ…è£… | ä½ | ä¸­ | ä½ | å®Œå…¨é€æ˜ |
| **Codex CLI** | é…ç½®æ³¨å…¥ | ä¸­ | ä½ | ä¸­ | å®Œå…¨é€æ˜ |
| **QoderCLI** | ç¯å¢ƒå˜é‡é’©å­ | ä¸­ | ä½ | ä¸­ | å®Œå…¨é€æ˜ |
| **iFlowCLI** | å‰åç½®è„šæœ¬ | é«˜ | ä¸­ | é«˜ | å®Œå…¨é€æ˜ |
| **CodeBuddy CLI** | æ’ä»¶ç³»ç»Ÿ | ä¸­ | ä½ | ä¸­ | å®Œå…¨é€æ˜ |
| **Kimi CLI** | APIä¸­é—´ä»¶ | é«˜ | ä¸­ | é«˜ | å®Œå…¨é€æ˜ |

---

## ğŸš€ ç»Ÿä¸€å®‰è£…è„šæœ¬

```bash
#!/bin/bash
# install_all_cross_cli_integrations.sh

echo "ğŸš€ å®‰è£…AI CLIè·¨å¹³å°è°ƒç”¨ç³»ç»Ÿ..."

# æ£€æŸ¥Pythonç¯å¢ƒ
if ! command -v python3 &> /dev/null; then
    echo "âŒ Python 3 æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£…Python 3.8+"
    exit 1
fi

# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python3 -m venv ~/.ai-cli-cross-cli
source ~/.ai-cli-cross-cli/bin/activate

# å®‰è£…æ ¸å¿ƒåŒ…
pip install ai-cli-cross-adapter

# å®‰è£…å„CLIçš„é›†æˆ
echo "ğŸ“¦ å®‰è£…Claude CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install claude

echo "ğŸ“¦ å®‰è£…Aider CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install aider

echo "ğŸ“¦ å®‰è£…Gemini CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install gemini

echo "ğŸ“¦ å®‰è£…QwenCode CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install qwencode

echo "ğŸ“¦ å®‰è£…Codex CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install codex

echo "ğŸ“¦ å®‰è£…QoderCLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install qodercli

echo "ğŸ“¦ å®‰è£…iFlowCLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install iflowcli

echo "ğŸ“¦ å®‰è£…CodeBuddy CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install codebuddycli

echo "ğŸ“¦ å®‰è£…Kimi CLIé›†æˆ..."
python3 -m ai_cli_cross_adapter.installer install kimi

# åˆ›å»ºShellåˆ«åï¼ˆå¯é€‰ï¼‰
cat >> ~/.bashrc << 'EOF'

# AI CLIè·¨å¹³å°è°ƒç”¨åˆ«å
alias ai-cross="python3 ~/.ai-cli-cross-cli/bin/ai-cli-coordinator"
alias cross-cli="python3 ~/.ai-cli-cross-cli/bin/cross-cli-manager"
EOF

echo "âœ… æ‰€æœ‰AI CLIè·¨å¹³å°é›†æˆå®‰è£…å®Œæˆï¼"
echo ""
echo "ğŸ“ ä½¿ç”¨æ–¹æ³•ï¼š"
echo "  claude 'è¯·ç”¨geminiåˆ†æè¿™ä¸ªæˆªå›¾'"
echo "  aider --ask 'è¯·ç”¨qwencodeç”Ÿæˆæµ‹è¯•ç”¨ä¾‹'"
echo "  gemini 'è¯·ç”¨claudeå®¡æŸ¥è¿™æ®µä»£ç '"
echo ""
echo "ğŸ”§ ç®¡ç†å‘½ä»¤ï¼š"
echo "  cross-cli status  # æŸ¥çœ‹é›†æˆçŠ¶æ€"
echo "  cross-cli config  # é…ç½®é›†æˆé€‰é¡¹"
echo "  cross-cli update   # æ›´æ–°é›†æˆç»„ä»¶"

# é‡æ–°åŠ è½½Shellé…ç½®
source ~/.bashrc

echo "ğŸ‰ å®‰è£…å®Œæˆï¼è¯·é‡å¯ç»ˆç«¯ä»¥ç”Ÿæ•ˆã€‚"
```

è¿™å¥—è¯¦ç»†çš„é›†æˆè§„èŒƒç¡®ä¿äº†æ¯ä¸ªAI CLIå·¥å…·éƒ½ä½¿ç”¨å…¶æœ€é€‚åˆçš„åŸç”Ÿé›†æˆæœºåˆ¶ï¼Œæ—¢ä¿è¯äº†æœ€ä½³æ€§èƒ½ï¼Œåˆå®ç°äº†å®Œå…¨é€æ˜çš„ç”¨æˆ·ä½“éªŒï¼
