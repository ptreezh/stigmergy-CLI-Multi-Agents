# Stigmergy-Based Collaboration System Specification
## Technical Design for Indirect AI CLI Collaboration

**Project Code:** AI-CLI-STIGMERGY-002
**Version:** 1.0
**Date:** 2025-01-22
**Status:** Final Specification**

---

## ğŸ“‹ Overview

### System Philosophy
åŸºäºç”Ÿç‰©å­¦çš„Stigmergyç†è®ºï¼Œè®¾è®¡ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„AI CLIåä½œç³»ç»Ÿï¼Œè®©å¤šä¸ªAIå·¥å…·é€šè¿‡å…±äº«çš„é¡¹ç›®ç¯å¢ƒå®ç°è‡ªç„¶åä½œï¼Œæ— éœ€ä¸­å¤®åè°ƒå™¨çš„å¤æ‚é€šä¿¡æœºåˆ¶ã€‚

### Core Principles
1. **ç¯å¢ƒé©±åŠ¨åä½œ (Environment-Driven Collaboration)** - é€šè¿‡PROJECT_SPEC.jsonå®ç°çŠ¶æ€å…±äº«
2. **é—´æ¥é€šä¿¡ (Indirect Communication)** - é€šè¿‡ç¯å¢ƒçŠ¶æ€å˜æ›´ä¼ é€’ä¿¡æ¯
3. **è‡ªä¸»å†³ç­– (Autonomous Decision-Making)** - æ™ºäºç¯å¢ƒçŠ¶æ€è‡ªä¸»å†³å®šè¡ŒåŠ¨
4. **åŸå­æ€§å®‰å…¨ (Atomic Safety)** - ç¡®ä¿å¹¶å‘æ“ä½œçš„å®‰å…¨æ€§å’Œä¸€è‡´æ€§

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```mermaid
graph TB
    subgraph "AI CLI Tools"
        A[Claude CLI]
        B[Gemini CLI]
        C[Codex CLI]
        D[QwenCode CLI]
        E[Other CLI Tools]
    end

    subgraph "Collaboration Layer"
        F[Collaboration Interface]
        G[Intent Parser]
        H[State Manager]
        I[Decision Engine]
        J[Task Router]
    end

    subgraph "Storage Layer"
        K[PROJECT_SPEC.json]
        L[File Lock Manager]
        M[Event Monitor]
        N[Change Detector]
    end

    A --> F
    B --> F
    C --> F
    D --> F
    E --> F

    F --> G
    G --> I
    I --> J
    J --> H
    H --> K

    H --> L
    K --> M
    M --> N
    N --> G
```

### æ ¸å¿ƒç»„ä»¶å…³ç³»

```mermaid
sequenceDiagram
    participant CLI1 as Claude CLI
    participant CLI2 as Gemini CLI
    participant SPEC as PROJECT_SPEC.json

    Note over SPEC: å…±äº«åä½œçŠ¶æ€æ–‡ä»¶

    CLI1->>SPEC: Read current state
    SPEC-->>CLI1: Project background & tasks

    CLI1->>SPEC: Claim task (atomic)
    SPEC-->>CLI1: Task acquired

    CLI1->>SPEC: Update status to in_progress
    SPEC-->>CLI1: Status updated

    Note right of SPEC: çŠ¶æ€å˜æ›´é€šçŸ¥å…¶ä»–å·¥å…·

    CLI2->>SPEC: Detect state change
    SPEC-->>CLI2: Task in_progress notice

    CLI2->>SPEC: Read task details
    SPEC-->>CLI2: Task information

    CLI2->>SPEC: Wait for task completion
    SPEC-->>CLI2: Monitoring status

    CLI1->>SPEC: Update status to completed
    SPEC-->>CLI1: Task completed

    SPEC-->>CLI2: Task completed notice
    CLI2->>SPEC: Read results
    SPEC-->>CLI2: Collaboration results

    CLI2->>SPEC: Update own tasks based on results
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. é¡¹ç›®çŠ¶æ€æ–‡æ¡£ (PROJECT_SPEC.json)

#### æ–‡æ¡£ç»“æ„è®¾è®¡

```json
{
  "version": "2.0.0",
  "metadata": {
    "created_at": "2025-01-22T10:00:00Z",
    "updated_at": "2025-01-22T15:30:00Z",
    "project_id": "proj_001",
    "collaboration_version": "1.0.0",
    "schema_version": "1.0.0"
  },

  "project_info": {
    "name": "æ™ºèƒ½CLIåä½œé¡¹ç›®",
    "description": "å¤šAI CLIå·¥å…·åä½œå¼€å‘é¡¹ç›®",
    "type": "software_development",
    "status": "active",
    "created_by": "system",
    "deadline": "2025-02-22T00:00:00Z"
  },

  "project_context": {
    "background": "åŸºäºStigmergyç†è®ºçš„å¤šAIå·¥å…·åä½œå¹³å°",
    "objectives": [
      "å®ç°æ— ç¼çš„AIå·¥å…·åä½œ",
      "æä¾›æ™ºèƒ½ä»»åŠ¡è·¯ç”±",
      "ç¡®ä¿åä½œçš„ä¸€è‡´æ€§",
      "æ”¯æŒå¤æ‚çš„ååŒå·¥ä½œæµ"
    ],
    "requirements": [
      "æ”¯æŒè·¨CLIå·¥å…·è°ƒç”¨",
      "å®ç°æ™ºèƒ½ä»»åŠ¡åˆ†å‘",
      "æä¾›åä½œå†å²è®°å½•",
      "ç¡®ä¿çŠ¶æ€ä¸€è‡´æ€§"
    ],
    "constraints": [
      "æ— ä¸­å¤®åè°ƒå™¨ä¾èµ–",
      "åŸºäºæ–‡ä»¶ç³»ç»ŸçŠ¶æ€",
      "æ”¯æŒåŸå­æ€§æ“ä½œ",
      "ä¿è¯æ•°æ®å®Œæ•´æ€§"
    ],
    "workspace": {
      "root_path": "/project/root",
      "structure": {
        "source": "./src",
        "docs": "./docs",
        "tests": "./tests",
        "output": "./output"
      },
      "current_files": [
        "main.py",
        "README.md",
        "config.json"
      ]
    }
  },

  "agents": [
    {
      "id": "agent_claude_001",
      "name": "claude",
      "type": "ai_assistant",
      "capabilities": [
        "code_review",
        "architecture_design",
        "documentation",
        "debugging"
      ],
      "status": "active",
      "assigned_tasks": [],
      "workload": {
        "current": 2,
        "max_capacity": 5
      },
      "last_active": "2025-01-22T14:30:00Z",
      "performance": {
        "tasks_completed": 15,
        "average_duration": "5.2min",
        "success_rate": 0.95
      }
    },
    {
      "id": "agent_gemini_002",
      "name": "gemini",
      "type": "ai_assistant",
      "capabilities": [
        "content_generation",
        "translation",
        "analysis",
        "creativity"
      ],
      "status": "active",
      "assigned_tasks": [],
      "workload": {
        "current": 1,
        "max_capacity": 4
      },
      "last_active": "2025-01-22T15:00:00Z",
      "performance": {
        "tasks_completed": 8,
        "average_duration": "3.8min",
        "success_rate": 0.92
      }
    }
  ],

  "tasks": {
    "task_code_review_001": {
      "id": "task_code_review_001",
      "title": "ä»£ç å®¡æŸ¥ä»»åŠ¡",
      "description": "å¯¹é¡¹ç›®ä»£ç è¿›è¡Œå…¨é¢çš„ä»£ç å®¡æŸ¥",
      "type": "review",
      "priority": "high",
      "status": "pending",
      "created_at": "2025-01-22T10:00:00Z",
      "deadline": "2025-01-23T18:00:00Z",
      "assigned_to": null,
      "dependencies": [],
      "subtasks": [
        {
          "id": "subtask_syntax_review",
          "title": "è¯­æ³•å®¡æŸ¥",
          "status": "pending",
          "estimated_duration": "10min"
        },
        {
          "id": "subtask_logic_review",
          "title": "é€»è¾‘å®¡æŸ¥",
          "status": "pending",
          "estimated_duration": "15min"
        }
      ],
      "requirements": [
        "Pythonä»£ç ",
        "åŒ…å«æµ‹è¯•ç”¨ä¾‹"
      ],
      "context": {
        "target_files": [
          "./src/main.py",
          "./src/utils.py"
        ],
        "review_criteria": [
          "ä»£ç è§„èŒƒ",
          "æ€§èƒ½ä¼˜åŒ–",
          "å®‰å…¨æ€§æ£€æŸ¥"
        ]
      }
    },
    "task_translation_002": {
      "id": "task_translation_002",
      "title": "æ–‡æ¡£ç¿»è¯‘ä»»åŠ¡",
      "description": "å°†é¡¹ç›®æ–‡æ¡£ç¿»è¯‘æˆå¤šç§è¯­è¨€",
      "type": "content_generation",
      "priority": "medium",
      "status": "pending",
      "created_at": "2025-01-22T11:00:00Z",
      "deadline": "2025-01-24T12:00:00Z",
      "assigned_to": null,
      "dependencies": [],
      "requirements": [
        "æ”¯æŒä¸­è‹±ç¿»è¯‘",
        "ä¿æŒæ ¼å¼ä¸€è‡´æ€§"
      ],
      "context": {
        "source_language": "Chinese",
        "target_languages": ["English", "Japanese"],
        "files": [
          "./README.md",
          "./docs/api.md"
        ]
      }
    }
  },

  "collaboration_history": [
    {
      "timestamp": "2025-01-22T14:30:00Z",
      "event_type": "task_created",
      "initiator": "system",
      "details": {
        "task_id": "task_code_review_001",
        "action": "åˆ›å»ºä»£ç å®¡æŸ¥ä»»åŠ¡"
      }
    },
    {
      "timestamp": "2025-01-22T15:00:00Z",
      "event_type": "agent_active",
      "initiator": "gemini",
      "details": {
        "agent_id": "agent_gemini_002",
        "action": "æ™ºèƒ½ä½“ä¸Šçº¿",
        "current_tasks": 1
      }
    }
  ],

  "current_state": {
    "active_agent": "claude",
    "active_task": null,
    "pending_tasks": 2,
    "in_progress_tasks": 0,
    "completed_tasks": 0,
    "blocked_tasks": 0,
    "failed_tasks": 0,
    "last_state_change": "2025-01-22T15:00:00Z"
  },

  "communication_log": [
    {
      "timestamp": "2025-01-22T10:00:00Z",
      "from": "system",
      "to": "all_agents",
      "message": "åä½œé¡¹ç›®å·²åˆå§‹åŒ–ï¼Œè¯·æ™ºèƒ½ä½“å¼€å§‹è®¤é¢†ä»»åŠ¡",
      "type": "system_notification"
    }
  ],

  "decision_log": [
    {
      "timestamp": "2025-01-22T14:30:00Z",
      "agent_id": "claude",
      "decision": "task_scan",
      "context": {
        "available_tasks": ["task_code_review_001", "task_translation_002"],
        "agent_capabilities": ["code_review", "architecture_design"],
        "current_workload": 2,
        "task_priorities": {
          "task_code_review_001": 8,
          "task_translation_002": 5
        }
      },
      "action": "ç­‰å¾…é€‚åˆçš„ä»»åŠ¡"
    }
  ],

  "configuration": {
    "collaboration_settings": {
      "auto_task_assignment": true,
      "max_concurrent_tasks": 5,
      "task_timeout": "2h",
      "retry_attempts": 3,
      "state_check_interval": "5s"
    },
    "file_settings": {
      "backup_interval": "300s",
      "max_file_size": "10MB",
      "encoding": "utf-8",
      "backup_count": 5
    },
    "security_settings": {
      "agent_authentication": true,
      "operation_logging": true,
      "malicious_detection": true,
      "access_control": {
        "read": true,
        "write": true,
        "execute": false
      }
    },
    "performance_settings": {
      "cache_enabled": true,
      "cache_ttl": "60s",
      "compression": true,
      "optimization": "atomic_operations"
    }
  }
}
```

### 2. åä½œæ¥å£è®¾è®¡

#### ç»Ÿä¸€åä½œæ¥å£ (ICollaborationAdapter)

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from datetime import datetime
import asyncio
import json

@dataclass
class CollaborationContext:
    """åä½œä¸Šä¸‹æ–‡ä¿¡æ¯"""
    project_path: str
    agent_id: str
    agent_name: str
    agent_capabilities: List[str]
    current_file: Optional[str] = None
    workspace_files: List[str] = None

@dataclass
class CollaborationRequest:
    """åä½œè¯·æ±‚"""
    request_id: str
    timestamp: datetime
    initiator_id: str
    intent_type: str  # 'task_claim', 'task_update', 'status_report'
    content: Dict[str, Any]
    metadata: Dict[str, Any] = None

@dataclass
class CollaborationResponse:
    """åä½œå“åº”"""
    request_id: str
    success: bool
    action: str
    result: Any = None
    error: Optional[str] = None
    metadata: Dict[str, Any] = None

class ICollaborationAdapter(ABC):
    """åä½œæ¥å£åŸºç±»"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.agent_id = config.get("agent_id")
        self.agent_name = config.get("agent_name")
        self.capabilities = config.get("capabilities", [])

    @abstractmethod
    async def read_project_state(self, project_path: str) -> Dict[str, Any]:
        """è¯»å–é¡¹ç›®çŠ¶æ€"""
        pass

    @abstractmethod
    async def update_project_state(self, project_path: str, updates: Dict[str, Any]) -> bool:
        """æ›´æ–°é¡¹ç›®çŠ¶æ€"""
        pass

    @abstractmethod
    async def parse_collaboration_intent(self, user_input: str,
                                        context: CollaborationContext) -> Optional[CollaborationRequest]:
        """è§£æåä½œæ„å›¾"""
        pass

    @abstractmethod
    async def decide_task_action(self, context: CollaborationContext) -> Optional[str]:
        """å†³å®šä»»åŠ¡è¡ŒåŠ¨"""
        pass

    @abstractmethod
    async def execute_collaboration(self, request: CollaborationRequest,
                                      context: CollaborationContext) -> CollaborationResponse:
        """æ‰§è¡Œåä½œä»»åŠ¡"""
        pass

    @abstractmethod
    async def report_collaboration_result(self, result: Any,
                                           context: CollaborationContext) -> None:
        """æŠ¥å‘Šåä½œç»“æœ"""
        pass

    def get_current_context(self) -> CollaborationContext:
        """è·å–å½“å‰ä¸Šä¸‹æ–‡"""
        # å®ç°è·å–å½“å‰å·¥ä½œä¸Šä¸‹æ–‡çš„é€»è¾‘
        pass

    def _parse_task_request_patterns(self) -> Dict[str, str]:
        """è§£æä»»åŠ¡è¯·æ±‚æ¨¡å¼"""
        return {
            # "è®©{tool}å¸®æˆ‘{task}" æ¨¡å¼
            "task_assignment": r'è®©(\w+)\s*(?:å¸®æˆ‘|æ¥|ååŠ©|ååŠ©æˆ‘)\s*(.+)',

            # "ç”¨{tool}æ¥{task}" æ¨¡å¼
            "task_execution": r'ç”¨(\w+)\s*æ¥\s*(.+)',

            # "è¯·{tool}{task}" æ¨¡å¼
            "direct_request": r'è¯·(\w+)\s*(.+)',

            # "è°ƒç”¨{tool}æ¥{task}" æ¨¡å¼
            "tool_invocation": r'è°ƒç”¨\s*(\w+)\s*(?:æ¥|ååŠ©)\s*(.+)',

            # "{tool}å·¥å…·å¸®æˆ‘{task}" æ¨¡å¼
            "tool_assistance": r'(\w+)(?:å·¥å…·)?\s*(?:å¸®æˆ‘|æ¥|ååŠ©|ååŠ©æˆ‘)\s*(.+)',

            # "è¯·{tool}å¤„ç†{task}" æ¨¡å¼
            "task_delegation": r'è¯·(\w+)\s*(?:å¤„ç†|æ‰§è¡Œ|å®Œæˆ)\s*(.+)',

            # "{tool}å·¥å…·å¤„ç†{task}" æ¨¡å¼
            "task_processing": r'(\w+)(?:å·¥å…·)?\s*(?:å¤„ç†|æ‰§è¡Œ|å®Œæˆ)\s*(.+)',

            # "è®©{tool}å¤„ç†{task}" æ¨¡å¼
            "task_delegation": r'è®©\s*(\w+)\s*(?:å¤„ç†|æ‰§è¡Œ|å®Œæˆ)\s*(.+)',

            # "åä½œ{tool}å·¥å…·{task}" æ¨¡å¼
            "collaboration": r'(?:åä½œ|é…åˆ)\s*(\w+)\s*(?:å·¥å…·)?\s*(.+)',

            # "{tool}ååŠ©{task}" æ¨¡å¼
            "assistance": r'(?:ååŠ©|å¸®åŠ©)\s*(\w+)\s*(?:æ¥|è¿›è¡Œ|å®ç°)\s*(.+)',

            # "åˆä½œ{tool}æ¥{task}" æ¨¡å¼
            "cooperation": r'(?:åˆä½œ|ååŒ)\s*(\w+)\s*(?:æ¥|è¿›è¡Œ|å®Œæˆ)\s*(.+)',

            # "è¯·æ±‚{tool}ååŠ©{task}" æ¨¡å¼
            "request": r'(?:è¯·æ±‚|ask)\s*(\w+)\s*(?:ååŠ©|å¸®åŠ©|æ”¯æŒ)\s*(.+)',

            # "æ‰¾{tool}æ¥åš{task}" æ¨¡å¼
            "seek_help": r'(?:æ‰¾|å¯»æ‰¾|éœ€è¦)\s*(\w+)\s*(?:æ¥|å»|åš)\s*(.+)'
        }

    def _is_urgent_task(self, task_description: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç´§æ€¥ä»»åŠ¡"""
        urgent_keywords = [
            'ç´§æ€¥', 'urgent', 'ç«‹å³', 'é©¬ä¸Š', 'å°½å¿«', 'èµ¶ç´§', 'ç«‹å³å¤„ç†',
            'high priority', 'ä¼˜å…ˆå¤„ç†', 'é‡è¦'
        ]

        return any(keyword.lower() in task_description.lower() for keyword in urgent_keywords)

    def _extract_task_details(self, request_text: str) -> Tuple[str, str]:
        """æå–ä»»åŠ¡è¯¦ç»†ä¿¡æ¯"""
        # å®ç°ä»»åŠ¡è¯¦ç»†ä¿¡æ¯æå–é€»è¾‘
        pass

    def _validate_task_match(self, task_requirements: List[str],
                              agent_capabilities: List[str]) -> Tuple[bool, float]:
        """éªŒè¯ä»»åŠ¡åŒ¹é…åº¦"""
        if not task_requirements or not agent_capabilities:
            return False, 0.0

        required_skills = set(task_requirements)
        available_skills = set(agent_capabilities)

        # è®¡ç®—åŒ¹é…åº¦
        matching_skills = required_skills & available_skills
        match_ratio = len(matching_skills) / len(required_skills) if required_skills else 0

        # è€ƒè™‘æŠ€èƒ½æƒé‡
        weighted_skills = {
            'code_review': 0.9, 'architecture_design': 0.8, 'documentation': 0.6,
            'content_generation': 0.7, 'translation': 0.6, 'analysis': 0.7,
            'creativity': 0.5, 'debugging': 0.8, 'testing': 0.7
        }

        weighted_match = 0.0
        total_weight = 0.0

        for skill in matching_skills:
            weight = weighted_skills.get(skill, 0.5)
            weighted_match += weight
            total_weight += weight

        for skill in required_skills:
            weight = weighted_skills.get(skill, 0.5)
            total_weight += weight

        if total_weight > 0:
            weighted_ratio = weighted_match / total_weight
        else:
            weighted_ratio = 0.0

        return match_ratio > 0.5, max(match_ratio, weighted_ratio)
```

### 3. çŠ¶æ€ç®¡ç†å™¨ (StateManager)

#### åŸå­æ€§çŠ¶æ€ç®¡ç†å®ç°

```python
import asyncio
import json
import fcntl
import os
import time
from pathlib import Path
from typing import Dict, Any, Optional, Callable
from contextlib import contextmanager
import tempfile
import shutil

class AtomicStateManager:
    """åŸå­æ€§çŠ¶æ€ç®¡ç†å™¨"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.lock_timeout = config.get("lock_timeout", 10)
        self.retry_attempts = config.get("retry_attempts", 3)
        self.retry_delay = config.get("retry_delay", 0.1)

        # çŠ¶æ€å˜æ›´ç›‘å¬å™¨
        self._state_listeners: List[Callable] = []

        # å¤‡ä»½ç®¡ç†
        self.backup_enabled = config.get("backup_enabled", True)
        self.backup_count = config.get("backup_count", 5)
        self.backup_interval = config.get("backup_interval", 300)  # 5åˆ†é’Ÿ

        # æ–‡ä»¶ç›‘æ§
        self._file_monitor = None
        self._monitoring_enabled = False

    @contextmanager
    async def atomic_update(self, file_path: str) -> "AtomicUpdateContext":
        """åŸå­æ€§æ›´æ–°ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        lock_file = f"{file_path}.lock"

        # åˆ›å»ºé”æ–‡ä»¶
        with open(lock_file, 'w') as f:
            f.write("")

        try:
            # å°è¯•è·å–æ–‡ä»¶é”
            for attempt in range(self.retry_attempts):
                try:
                    with open(lock_file, 'r') as f:
                        fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)

                    # æˆåŠŸè·å–é”ï¼Œè¿”å›ä¸Šä¸‹æ–‡
                    with open(file_path, 'r') as f:
                        current_data = json.load(f)

                    yield AtomicUpdateContext(
                        file_path=file_path,
                        current_data=current_data,
                        backup_path=f"{file_path}.backup.{int(time.time())}"
                    )
                    break

                except (IOError, OSError) as e:
                    if e.errno == 11:  # Resource temporarily unavailable
                        if attempt < self.retry_attempts - 1:
                            await asyncio.sleep(self.retry_delay * (2 ** attempt))
                            continue
                        else:
                            raise FileNotFoundError(f"æ— æ³•è·å–æ–‡ä»¶é”: {file_path}")
                    else:
                        raise

        except Exception as e:
            raise
        finally:
            # é‡Šæ”¾é”æ–‡ä»¶
            try:
                os.unlink(lock_file)
            except:
                pass

    async def read_state(self, file_path: str) -> Dict[str, Any]:
        """è¯»å–çŠ¶æ€æ–‡ä»¶"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            # æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤çŠ¶æ€
            return self._get_default_state()
        except json.JSONDecodeError as e:
            # JSONè§£æé”™è¯¯ï¼Œå°è¯•ä»å¤‡ä»½æ¢å¤
            return await self._restore_from_backup(file_path)

    async def update_state(self, file_path: str, updates: Dict[str, Any],
                            backup: bool = None) -> bool:
        """æ›´æ–°çŠ¶æ€æ–‡ä»¶"""
        async with self.atomic_update(file_path) as ctx:
            current_data = ctx.current_data

            # åº”ç”¨æ›´æ–°
            self._deep_update(current_data, updates)

            # æ›´æ–°å…ƒæ•°æ®
            if 'metadata' not in current_data:
                current_data['metadata'] = {}

            current_data['metadata']['updated_at'] = datetime.now().isoformat()
            current_data['metadata']['updated_by'] = self.config.get('agent_id', 'unknown')

            # å†™å…¥æ–°çŠ¶æ€
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(current_data, f, indent=2, ensure_ascii=False)

            # åˆ›å»ºå¤‡ä»½ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if backup and self.backup_enabled:
                backup_path = ctx.backup_path
                with open(backup_path, 'w', encoding='utf-8') as f:
                    json.dump(current_data, f, indent=2, ensure_ascii=False)

                # æ¸…ç†æ—§å¤‡ä»½
                await self._cleanup_backups(file_path)

            # é€šçŸ¥ç›‘å¬å™¨
            await self._notify_state_listeners(file_path, updates)

            return True

    async def monitor_file_changes(self, file_path: str,
                                callback: Callable[[str, Dict[str, Any]], None]) -> None:
        """ç›‘æ§æ–‡ä»¶å˜æ›´"""
        import asyncio
        from watchdog.observers import Observer
        from watchdog.events import FileSystemEvent

        class ChangeHandler(FileSystemEventHandler):
            def __init__(self, callback):
                self.callback = callback

            def on_modified(self, event):
                if not event.is_directory:
                    if event.src_path.endswith('.json'):
                        try:
                            with open(event.src_path, 'r', encoding='utf-8') as f:
                                data = json.load(f)
                            self.callback(event.src_path, data)
                        except Exception as e:
                            print(f"æ–‡ä»¶ç›‘æ§å›è°ƒé”™è¯¯: {e}")

            # å¿½ç•¥å…¶ä»–äº‹ä»¶
            def on_created(self, event): pass
            def on_deleted(self, event): pass
            def on_moved(self, event): pass

        observer = Observer()
        handler = ChangeHandler(callback)

        observer.schedule(handler, path=os.path.dirname(file_path))

        try:
            self._file_monitor = asyncio.create_task(observer.start())
            self._monitoring_enabled = True
        except Exception as e:
            print(f"æ–‡ä»¶ç›‘æ§å¯åŠ¨å¤±è´¥: {e}")

    async def stop_monitoring(self):
        """åœæ­¢æ–‡ä»¶ç›‘æ§"""
        if self._file_monitor and self._monitoring_enabled:
            observer = self._file_monitor.get_loop()
            observer.stop()
            await self._file_monitor
            self._monitoring_enabled = False
            self._file_monitor = None

    def add_state_listener(self, listener: Callable[[str, Dict[str, Any]], None]):
        """æ·»åŠ çŠ¶æ€å˜æ›´ç›‘å¬å™¨"""
        self._state_listeners.append(listener)

    def remove_state_listener(self, listener: Callable[[str, Dict[str, Any]], None]):
        """ç§»é™¤çŠ¶æ€å˜æ›´ç›‘å¬å™¨"""
        if listener in self._state_listeners:
            self._state_listeners.remove(listener)

    async def _notify_state_listeners(self, file_path: str, updates: Dict[str, Any]):
        """é€šçŸ¥çŠ¶æ€ç›‘å¬å™¨"""
        try:
            # è¯»å–æœ€æ–°çŠ¶æ€
            current_state = await self.read_state(file_path)

            # é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
            for listener in self._state_listeners:
                try:
                    await listener(file_path, updates, current_state)
                except Exception as e:
                    print(f"ç›‘å¬å™¨é€šçŸ¥é”™è¯¯: {e}")

        except Exception as e:
            print(f"çŠ¶æ€ç›‘å¬é”™è¯¯: {e}")

    def _deep_update(self, target: Dict[str, Any], source: Dict[str, Any]):
        """æ·±åº¦æ›´æ–°å­—å…¸"""
        for key, value in source.items():
            if key in target and isinstance(target[key], dict) and isinstance(value, dict):
                self._deep_update(target[key], value)
            else:
                target[key] = value

    def _get_default_state(self) -> Dict[str, Any]:
        """è·å–é»˜è®¤çŠ¶æ€ç»“æ„"""
        return {
            "version": "2.0.0",
            "metadata": {
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat()
            },
            "project_info": {
                "name": "é»˜è®¤åä½œé¡¹ç›®",
                "status": "active"
            },
            "project_context": {
                "background": "",
                "objectives": [],
                "requirements": [],
                "constraints": []
            },
            "agents": [],
            "tasks": {},
            "collaboration_history": [],
            "current_state": {
                "active_agent": None,
                "active_task": None,
                "pending_tasks": 0,
                "completed_tasks": 0,
                "last_state_change": datetime.now().isoformat()
            },
            "communication_log": [],
            "decision_log": [],
            "configuration": {}
        }

    async def _restore_from_backup(self, file_path: str) -> Dict[str, Any]:
        """ä»å¤‡ä»½æ¢å¤çŠ¶æ€"""
        backup_pattern = f"{file_path}.backup.*"

        try:
            # æŸ¥æ‰¾æœ€æ–°çš„å¤‡ä»½æ–‡ä»¶
            backup_files = sorted(Path(os.path.dirname(file_path)).glob(
                os.path.basename(backup_pattern)
            ), key=lambda p: p.stat().st_mtime, reverse=True)

            if backup_files:
                latest_backup = backup_files[0]
                with open(latest_backup, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                return self._get_default_state()

        except Exception as e:
            print(f"å¤‡ä»½æ¢å¤å¤±è´¥: {e}")
            return self._get_default_state()

    async def _cleanup_backups(self, file_path: str):
        """æ¸…ç†æ—§å¤‡ä»½æ–‡ä»¶"""
        try:
            backup_pattern = f"{file_path}.backup.*"
            backup_files = sorted(Path(os.path.dirname(file_path)).glob(
                os.path.basename(backup_pattern)
            ), key=lambda p: p.stat().st_mtime, reverse=True)

            # ä¿ç•™æœ€è¿‘çš„Nä¸ªå¤‡ä»½
            for backup_file in backup_files[self.backup_count:]:
                try:
                    backup_file.unlink()
                except Exception as e:
                    print(f"åˆ é™¤å¤‡ä»½æ–‡ä»¶å¤±è´¥: {e}")

        except Exception as e:
            print(f"å¤‡ä»½æ¸…ç†å¤±è´¥: {e}")
```

### 4. æ™ºèƒ½ä½“å†³ç­–å¼•æ“ (Decision Engine)

#### æ™ºèƒ½ä»»åŠ¡åˆ†é…ç®—æ³•

```python
import asyncio
import random
import time
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class TaskPriority(Enum):
    CRITICAL = 8
    HIGH = 7
    URGENT = 6
    NORMAL = 5
    LOW = 4
    MINIMAL = 3

class AgentWorkload(Enum):
    IDLE = 0
    LIGHT = 1
    NORMAL = 2
    BUSY = 3
    FULL = 4
    OVERLOADED = 5

@dataclass
class TaskScore:
    task_id: str
    priority: TaskPriority
    match_score: float
    weight_score: float
    workload_penalty: float
    urgency_bonus: float
    total_score: float

class DecisionEngine:
    """æ™ºèƒ½å†³ç­–å¼•æ“"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.decision_factors = {
            'priority_weight': config.get('priority_weight', 0.3),
            'match_weight': config.get('match_weight', 0.4),
            'workload_weight': config.get('workload_weight', 0.2),
            'urgency_weight': config.get('urgency_weight', 0.1),
            'random_factor': config.get('random_factor', 0.05)
        }

        # å­¦ä¹ å‚æ•°
        self.learning_rate = config.get('learning_rate', 0.1)
        self.performance_history = {}

    async def decide_task_claim(self, agent_id: str, agent_info: Dict[str, Any],
                                available_tasks: List[Dict[str, Any]],
                                project_state: Dict[str, Any]) -> Optional[str]:
        """å†³ç­–æ˜¯å¦è®¤é¢†ä»»åŠ¡"""

        # è·å–å½“å‰æ—¶é—´å’Œä¸Šä¸‹æ–‡
        current_time = datetime.now()

        # ä¸ºæ¯ä¸ªä»»åŠ¡è®¡ç®—è¯„åˆ†
        task_scores = []
        for task in available_tasks:
            score = await self._calculate_task_score(
                task, agent_info, project_state, current_time
            )
            task_scores.append(score)

        # æŒ‰è¯„åˆ†æ’åº
        task_scores.sort(key=lambda x: x.total_score, reverse=True)

        # è·å–æœ€ä½³å€™é€‰ä»»åŠ¡
        if not task_scores:
            return None

        best_task = task_scores[0]

        # å†³ç­–é€»è¾‘
        decision = self._make_claim_decision(
            best_task, agent_info, project_state, task_scores
        )

        if decision == 'claim':
            return best_task.task_id
        elif decision == 'wait':
            return None
        else:
            return None

    async def _calculate_task_score(self, task: Dict[str, Any],
                                  agent_info: Dict[str, Any],
                                  project_state: Dict[str, Any],
                                  current_time: datetime) -> TaskScore:
        """è®¡ç®—ä»»åŠ¡è¯„åˆ†"""

        # 1. ä¼˜å…ˆçº§è¯„åˆ†
        task_id = task.get('id', '')
        priority = self._get_task_priority(task)
        priority_score = priority.value * self.decision_factors['priority_weight']

        # 2. åŒ¹é…åº¦è¯„åˆ†
        task_requirements = task.get('requirements', [])
        agent_capabilities = agent_info.get('capabilities', [])
        match_result, match_score = self._calculate_match_score(
            task_requirements, agent_capabilities
        )
        match_weighted_score = match_score * self.decision_factors['match_weight']

        # 3. å·¥ä½œè´Ÿè½½è¯„åˆ†
        workload = self._get_agent_workload(agent_info)
        workload_penalty = self._calculate_workload_penalty(workload)
        workload_score = -workload_penalty * self.decision_workload['workload_weight']

        # 4. ç´§æ€¥åº¦è¯„åˆ†
        urgency_score = 0.0
        deadline = task.get('deadline')
        if deadline:
            time_remaining = (deadline - current_time).total_seconds()
            if time_remaining < 3600:  # 1å°æ—¶å†…
                urgency_score = 8.0 * self.decision_factors['urgency_weight']
            elif time_remaining < 86400: # 24å°æ—¶å†…
                urgency_score = 5.0 * self.decision_factors['urgency_weight']
            elif time_remaining < 604800: # 7å¤©å†…
                urgency_score = 3.0 * self.decision_factors['urgency_weight']

        # 5. å­¦ä¹ æƒé‡è°ƒæ•´
        learning_adjustment = self._get_learning_adjustment(task_id, agent_id)

        # 6. éšæœºå› å­ï¼ˆé˜²æ­¢ç¡®å®šæ€§å†³ç­–ï¼‰
        random_factor = (random.random() - 0.5) * 2 * self.decision_factors['random_factor']

        # è®¡ç®—æ€»åˆ†
        total_score = (priority_score + match_weighted_score +
                       workload_score + urgency_score +
                       learning_adjustment + random_factor)

        return TaskScore(
            task_id=task_id,
            priority=priority,
            match_score=match_score,
            weight_score=match_weighted_score,
            workload_penalty=workload_penalty,
            urgency_bonus=urgency_score,
            total_score=total_score
        )

    def _get_task_priority(self, task: Dict[str, Any]) -> TaskPriority:
        """è·å–ä»»åŠ¡ä¼˜å…ˆçº§"""
        priority_str = task.get('priority', 'normal').lower()

        priority_mapping = {
            'critical': TaskPriority.CRITICAL,
            'high': TaskPriority.HIGH,
            'urgent': TaskPriority.URGENT,
            'normal': TaskPriority.NORMAL,
            'medium': TaskPriority.NORMAL,
            'low': TaskPriority.LOW,
            'minimal': TaskPriority.MINIMAL
        }

        return priority_mapping.get(priority_str, TaskPriority.NORMAL)

    def _calculate_match_score(self, task_requirements: List[str],
                                  agent_capabilities: List[str]) -> Tuple[bool, float]:
        """è®¡ç®—åŒ¹é…è¯„åˆ†"""
        if not task_requirements or not agent_capabilities:
            return False, 0.0

        # å®šä¹‰æŠ€èƒ½æƒé‡
        skill_weights = {
            'code_review': 0.9, 'architecture_design': 0.8, 'documentation': 0.6,
            'content_generation': 0.7, 'translation': 0.6, 'analysis': 0.7,
            'creativity': 0.5, 'debugging': 0.8, 'testing': 0.7,
            'planning': 0.7, 'organization': 0.6, 'security': 0.8
        }

        # è®¡ç®—åŒ¹é…åº¦
        required_skills = set(task_requirements)
        available_skills = set(agent_capabilities)
        matching_skills = required_skills & available_skills

        # è®¡ç®—åŠ æƒåŒ¹é…åˆ†
        weighted_match = 0.0
        total_weight = 0.0

        for skill in matching_skills:
            weight = skill_weights.get(skill, 0.5)
            weighted_match += weight
            total_weight += weight

        for skill in required_skills:
            weight = skill_weights.get(skill, 0.5)
            total_weight += weight

        match_ratio = weighted_match / total_weight if total_weight > 0 else 0.0

        # ç‰¹æ®ŠåŠ åˆ†è§„åˆ™
        bonus = 0.0

        # å®Œå…¨åŒ¹é…åŠ åˆ†
        if required_skills.issubset(available_skills):
            bonus += 2.0

        # å…³é”®æŠ€èƒ½åŠ åˆ†
        key_skills = {'code_review', 'architecture_design', 'security'}
        key_matching = required_skills & available_skills
        if key_matching:
            bonus += len(key_matching) * 0.5

        return match_ratio > 0.3, match_ratio + bonus

    def _get_agent_workload(self, agent_info: Dict[str, str]) -> AgentWorkload:
        """è·å–æ™ºèƒ½ä½“å·¥ä½œè´Ÿè½½"""
        workload_data = agent_info.get('workload', {})

        if isinstance(workload_data, dict):
            current = workload_data.get('current', 0)
            max_capacity = workload_data.get('max_capacity', 5)

            if max_capacity <= 0:
                return AgentWorkload.OVERLOADED
            elif current >= max_capacity:
                return AgentWorkload.FULL
            elif current >= max_capacity * 0.8:
                return AgentWorkload.BUSY
            elif current >= max_capacity * 0.6:
                return AgentWorkload.NORMAL
            elif current >= max_capacity * 0.3:
                return AgentWorkload.LIGHT
            else:
                return AgentWorkload.IDLE

        return AgentWorkload.NORMAL

    def _calculate_workload_penalty(self, workload: AgentWorkload) -> float:
        """è®¡ç®—å·¥ä½œè´Ÿè½½æƒ©ç½šåˆ†"""
        penalty_mapping = {
            AgentWorkload.IDLE: 0.0,
            AgentWorkload.LIGHT: 0.5,
            AgentWorkload.NORMAL: 1.0,
            AgentWorkload.BUSY: 2.0,
            AgentWorkload.FULL: 3.0,
            AgentWorkload.OVERLOADED: 4.0
        }

        return penalty_mapping.get(workload, 1.0)

    def _get_learning_adjustment(self, task_id: str, agent_id: str) -> float:
        """è·å–å­¦ä¹ è°ƒæ•´æƒé‡"""
        # è·å–å†å²è¡¨ç°æ•°æ®
        task_history = self.performance_history.get(f"{agent_id}:{task_id}", [])

        if not task_history:
            return 0.0

        # è®¡ç®—å¹³å‡æˆåŠŸç‡
        success_rates = [entry.get('success_rate', 0.5) for entry in task_history]
        if success_rates:
            recent_performance = sum(success_rates[-5:]) / len(success_rates[-5:])

            # å¦‚æœè¡¨ç°è‰¯å¥½ï¼Œç»™äºˆæ­£å‘è°ƒæ•´
            if recent_performance > 0.8:
                return 0.2
            elif recent_performance < 0.3:
                return -0.2

        return 0.0

    def _make_claim_decision(self, task: TaskScore, agent_info: Dict[str, str],
                           project_state: Dict[str, Any],
                           all_scores: List[TaskScore]) -> str:
        """åšå‡ºè®¤é¢†å†³ç­–"""

        # å¦‚æœä»»åŠ¡ä¼˜å…ˆçº§å¾ˆé«˜ï¼Œç›´æ¥è®¤é¢†
        if task.priority == TaskPriority.CRITICAL:
            return 'claim'

        # å¦‚æœåŒ¹é…åº¦å¾ˆä½ï¼Œä¸è®¤é¢†
        if task.match_score < 0.3:
            return 'wait'

        # å¦‚æœå·¥ä½œè´Ÿè½½è¿‡é«˜ï¼Œè°¨æ…è®¤é¢†
        workload = self._get_agent_workload(agent_info)
        if workload == AgentWorkload.OVERLOADED:
            return 'wait'

        # å¦‚æœç¬¬äºŒå¥½çš„ä»»åŠ¡ä¹Ÿå¾ˆå¥½ï¼Œè€ƒè™‘è®¤é¢†
        if len(all_scores) > 1:
            second_best = all_scores[1]
            score_gap = task.total_score - second_best.total_score

            # å¦‚æœå·®è·å¾ˆå°ï¼Œå¯ä»¥è€ƒè™‘è®¤é¢†
            if score_gap < 0.1:
                return 'claim'

        return 'wait'
```

---

## ğŸ“Š åä½œæµç¨‹è®¾è®¡

### åä½œæµç¨‹å›¾

```mermaid
sequenceDiagram
    participant CLI1 as Claude CLI
    participant CLI2 as Gemini CLI
    participant CLI3 as Codex CLI
    participant STATE as PROJECT_SPEC.json

    Note over STATE: å…±äº«åä½œçŠ¶æ€æ–‡ä»¶

    CLI1->>STATE: è¯»å–é¡¹ç›®çŠ¶æ€
    CLI1->>CLI1: åˆ†æå¯ç”¨ä»»åŠ¡

    alt å†³ç­–1: è®¤é¢†é€‚åˆçš„ä»»åŠ¡
        CLI1->>STATE: åŸï¿½å­æ€§æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºin_progress
        Note over STATE: ä½¿ç”¨æ–‡ä»¶é”ä¿è¯åŸå­æ€§
        STATE-->>CLI1: ä»»åŠ¡è®¤é¢†æˆåŠŸ

        CLI1->>STATE: æ‰§è¡Œä»»åŠ¡
        CLI1->>STATE: æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºcompleted
        CLI1->>STATE: è®°å½•åä½œç»“æœ
        Note over STATE: çŠ¶æ€å˜æ›´è§¦å‘é€šçŸ¥

        STATE-->>CLI2: é€šçŸ¥ä»»åŠ¡å®Œæˆ
        STATE-->>CLI3: é€šçŸ¥ä»»åŠ¡å®Œæˆ

        CLI2->>STATE: æ£€æµ‹åˆ°çŠ¶æ€å˜æ›´
        CLI2->>STATE: è¯»å–ä»»åŠ¡ç»“æœ
        CLI2->>STATE: åŸºäºç»“æœæ›´æ–°è‡ªå·±çš„ä»»åŠ¡
        Note over STATE: æ™ºèƒ½å†³ç­–æ›´æ–°

        CLI3->>STATE: æ£€æµ‹åˆ°çŠ¶æ€å˜æ›´
        CLI3->>STATE: è¯»å–æ‰€æœ‰å®ŒæˆçŠ¶æ€
        CLI3->>STATE: æ£€æŸ¥ä¾èµ–ä»»åŠ¡æ˜¯å¦å®Œæˆ
        CLI3->>STATE: è®¤é¢†æ–°çš„ä¾èµ–ä»»åŠ¡
```

### ä»»åŠ¡çŠ¶æ€æµè½¬

```mermaid
stateDiagram-v2
    [*] --> pending
    pending --> in_progress: æ™ºèƒ½ä½“è®¤é¢†ä»»åŠ¡
    in_progress --> completed: ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ
    in_progress --> failed: ä»»åŠ¡æ‰§è¡Œå¤±è´¥
    in_progress --> blocked: é‡åˆ°ä¾èµ–é˜»å¡

    completed --> [*]: ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸç»“æŸ
    failed --> pending: é‡è¯•æœºåˆ¶
    blocked --> pending: é˜»å¡è§£é™¤åé‡è¯•

    pending --> [*]: ä»»åŠ¡è¢«å–æ¶ˆ
    failed --> [*]: æ”¾å¼ƒä»»åŠ¡

    [*] --> pending: é‡æ–°åˆ›å»ºä»»åŠ¡
```

---

## ğŸ”§ å®ç°ç»†èŠ‚

### è‡ªç„¶è¯­è¨€åä½œåè®®è§£æ

```python
class CollaborationProtocolParser:
    """åä½œåè®®è§£æå™¨"""

    def __init__(self):
        self.patterns = {
            # ä¸»æ¨¡å¼
            'task_assignment': {
                'regex': r'è®©\s*(\w+)\s*(?:å¸®æˆ‘|æ¥|ååŠ©|ååŠ©æˆ‘)\s*(.+)',
                'groups': ['target_tool', 'task_description'],
                'priority': 'high'
            },
            'task_execution': {
                'regex': r'ç”¨\s*(\w+)\s*æ¥\s*(.+)',
                'groups': ['target_tool', 'task_description'],
                'priority': 'high'
            },
            'direct_request': {
                'regex': r'è¯·\s*(\w+)\s*(.+)',
                'groups': ['target_tool', 'task_description'],
                'priority': 'high'
            },

            # åä½œæ¨¡å¼
            'collaboration': {
                'regex': r'(?:åä½œ|é…åˆ)\s*(\w+)\s*(?:å·¥å…·)?\s*(.+)',
                'groups': ['target_tool', 'collaboration_description'],
                'priority': 'medium'
            },
            'cooperation': {
                'regex': r'(?:åˆä½œ|ååŒ)\s*(\w+)\s*(?:æ¥|è¿›è¡Œ|å®Œæˆ)\s*(.+)',
                'groups': ['target_tool', 'task_description'],
                'priority': 'medium'
            },

            # å¸®ç”¨æ¨¡å¼
            'assistance': {
                'regex': r'(?:ååŠ©|å¸®åŠ©)\s*(\w+)\s*(?:æ¥|è¿›è¡Œ|å®ç°)\s*(.+)',
                'groups': ['target_tool', 'assistance_description'],
                'priority': 'medium'
            },
            'support': {
                'regex': r'(?:æ”¯æŒ|æ”¯æ´)\s*(\w+)\s*(?:æ¥|å»|åš)\s*(.+)',
                'groups': ['target_tool', 'support_description'],
                'priority': 'medium'
            }
        }

    def parse_collaboration_intent(self, user_input: str,
                               context: CollaborationContext) -> Optional[CollaborationRequest]:
        """è§£æåä½œæ„å›¾"""

        for pattern_name, pattern_info in self.patterns.items():
            match = re.search(pattern_info['regex'], user_input, re.IGNORECASE)
            if match:
                target_tool = match.group('target_tool')
                task_description = match.group('task_description')

                # æ¸…ç†å’Œæ ‡å‡†åŒ–
                target_tool = self._normalize_tool_name(target_tool)
                task_description = task_description.strip()

                # éªŒè¯ç›®æ ‡å·¥å…·
                if not self._is_valid_tool(target_tool):
                    continue

                # åˆ›å»ºåä½œè¯·æ±‚
                request = CollaborationRequest(
                    request_id=self._generate_request_id(),
                    timestamp=datetime.now(),
                    initiator_id=context.agent_id,
                    intent_type=pattern_name,
                    content={
                        'target_tool': target_tool,
                        'task_description': task_description,
                        'priority': pattern_info['priority']
                    },
                    metadata={
                        'original_input': user_input,
                        'context': context.__dict__(),
                        'confidence': self._calculate_confidence(match, user_input)
                    }
                )

                return request

        return None

    def _normalize_tool_name(self, tool_name: str) -> str:
        """æ ‡å‡†åŒ–å·¥å…·åç§°"""
        tool_mapping = {
            'claude': 'claude',
            'claude-code': 'claude',
            'gemini': 'gemini',
            'codex': 'codex',
            'openai': 'codex',
            'qwen': 'qwencode',
            'qwen-code': 'qwencode',
            'qoder': 'qodercli',
            'qoder-cli': 'qodercli',
            'iflow': 'iflowcli',
            'iflow-cli': 'iflowcli',
            'codebuddy': 'codebuddycli',
            'codebuddy-cli': 'codebuddycli',
            'kimi': 'kimi',
            'kimi-cli': 'kimi'
        }

        return tool_mapping.get(tool_name.lower(), tool_name)

    def _is_valid_tool(self, tool_name: str) -> bool:
        """éªŒè¯å·¥å…·åç§°æ˜¯å¦æœ‰æ•ˆ"""
        valid_tools = [
            'claude', 'gemini', 'codex', 'qwencode', 'qodercli',
            'iflowcli', 'codebuddycli', 'kimi'
        ]
        return tool_name.lower() in valid_tools

    def _calculate_confidence(self, match, original_input: str) -> float:
        """è§£æç½®ä¿¡åº¦è®¡ç®—"""
        # åŸºäºåŒ¹é…è´¨é‡è®¡ç®—ç½®ä¿¡åº¦
        base_confidence = 0.8

        # å¦‚æœå®Œå…¨åŒ¹é…ï¼Œæé«˜ç½®ä¿¡åº¦
        if match.group(0).lower() == original_input.lower():
            base_confidence = 1.0

        # å¦‚æœåŒ…å«å¤šä½™æ–‡æœ¬ï¼Œé™ä½ç½®ä¿¡åº¦
        elif len(match.group(0)) < len(original_input) * 0.7:
            base_confidence *= 0.9

        # åŸºäºæ¨¡å¼ä¼˜å…ˆçº§è°ƒæ•´
        pattern_priorities = {
            'task_assignment': 0.95,
            'task_execution': 0.95,
            'direct_request': 0.90,
            'collaboration': 0.85,
            'cooperation': 0.85,
            'assistance': 0.80,
            'support': 0.80
        }

        pattern_name = match.re.pattern if hasattr(match, 're') else 'unknown'
        pattern_priority = pattern_priorities.get(pattern_name, 0.5)

        return base_confidence * pattern_priority

    def _generate_request_id(self) -> str:
        """ç”Ÿæˆè¯·æ±‚ID"""
        return f"req_{int(time.time() * 1000)}_{random.randint(1000, 9999)}"
```

### å¤šæ™ºèƒ½ä½“å†²çªæ£€æµ‹

```python
class ConflictDetector:
    """å†²çªæ£€æµ‹å™¨"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.agent_activity_timeout = config.get('agent_activity_timeout', 300)  # 5åˆ†é’Ÿ
        self.max_concurrent_claims = config.get('max_concurrent_claims', 1)

        # è·Ÿè¸ªæ™ºèƒ½ä½“çŠ¶æ€
        self.agent_activity = {}  # agent_id -> last_active_time
        self.task_claims = {}    # task_id -> agent_id

        self._lock_manager = LockManager()

    async def check_task_availability(self, task_id: str,
                                     project_state: Dict[str, Any]) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å¯ç”¨"""

        # æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²è¢«è®¤é¢†
        if task_id in self.task_claims:
            claimed_by = self.task_claims[task_id]

            # æ£€æŸ¥è®¤é¢†è€…æ˜¯å¦ä»ç„¶æ´»è·ƒ
            if not self._is_agent_active(claimed_by):
                # æ™ºèƒ½ä½“è¶…æ—¶ï¼Œé‡Šæ”¾ä»»åŠ¡
                del self.task_claims[task_id]
                return True
            else:
                # æ™ºèƒ½ä½“ä»ç„¶æ´»è·ƒï¼Œä»»åŠ¡è¢«å ç”¨
                return False

        return True

    async def claim_task(self, task_id: str, agent_id: str,
                          project_state: Dict[str, Any]) -> bool:
        """è®¤é¢†ä»»åŠ¡"""

        # æ£€æŸ¥ä»»åŠ¡å¯ç”¨æ€§
        if not await self.check_task_availability(task_id, project_state):
            return False

        # æ£€æŸ¥æ™ºèƒ½ä½“çŠ¶æ€
        if not self._can_agent_claim_task(agent_id):
            return False

        # åŸå­æ€§è®¤é¢†æ“ä½œ
        try:
            lock_key = f"task_claim_{task_id}"
            async with self._lock_manager.acquire_lock(lock_key):
                # åŒé‡æ£€æŸ¥ä»»åŠ¡çŠ¶æ€
                if not await self.check_task_availability(task_id, project_state):
                    return False

                # æ‰§è¡Œè®¤é¢†æ“ä½œ
                self.task_claims[task_id] = agent_id
                self.agent_activity[agent_id] = datetime.now()

                # æ›´æ–°ä»»åŠ¡çŠ¶æ€
                updates = {
                    f"tasks.{task_id}.assigned_to": agent_id,
                    f"tasks.{task_id}.status": "in_progress",
                    f"tasks.{task_id}.claimed_at": datetime.now().isoformat()
                }

                success = await self._update_project_state(project_state, updates)
                return success

        except Exception as e:
            print(f"ä»»åŠ¡è®¤é¢†å¤±è´¥: {e}")
            return False

    def _is_agent_active(self, agent_id: str) -> bool:
        """æ£€æŸ¥æ™ºèƒ½ä½“æ˜¯å¦æ´»è·ƒ"""
        if agent_id not in self.agent_activity:
            return False

        last_active = self.agent_activity[agent_id]
        time_since_active = (datetime.now() - last_active).total_seconds()

        return time_since_active < self.agent_activity_timeout

    def _can_agent_claim_task(self, agent_id: str) -> bool:
        """æ£€æŸ¥æ™ºèƒ½ä½“æ˜¯å¦å¯ä»¥è®¤é¢†ä»»åŠ¡"""
        if agent_id not in self.agent_activity:
            return True

        current_workload = self._get_agent_current_workload(agent_id)
        max_capacity = self._get_agent_max_capacity(agent_id)

        return current_workload < max_capacity

class LockManager:
    """é”ç®¡ç†å™¨"""

    def __init__(self):
        self.locks = {}
        self.lock_timeout = 10

    @contextmanager
    async def acquire_lock(self, lock_key: str):
        """è·å–é”"""
        lock_file = f"/tmp/{lock_key}.lock"

        for attempt in range(3):
            try:
                with open(lock_file, 'w') as f:
                    f.write(f"lock_{os.getpid()}")

                try:
                    with open(lock_file, 'r') as f:
                        fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)

                    yield LockContext(lock_file)
                    return

                except (IOError, OSError) as e:
                    if e.errno == 11:  # Resource busy
                        if attempt < 2:
                            await asyncio.sleep(0.1)
                            continue
                        else:
                            raise
                    else:
                        raise

            except Exception as e:
                raise
        finally:
            try:
                os.unlink(lock_file)
            except:
                pass
```

---

## ğŸš€ å®ç°è·¯çº¿å›¾

### åˆ†é˜¶æ®µå®ç°è®¡åˆ’

#### Phase 1: æ ¸å¿ƒåä½œåŸºç¡€ (Weeks 1-4)
- Week 1: PROJECT_SPEC.jsonç»“æ„è®¾è®¡
- Week 2: åŸå­æ€§çŠ¶æ€ç®¡ç†å™¨å®ç°
- Week 3: åŸºç¡€åä½œæ¥å£å®šä¹‰
- Week 4: è‡ªç„¶è¯­è¨€åè®®è§£æå™¨

#### Phase 2: æ™ºèƒ½ä½“é›†æˆ (Weeks 5-8)
- Week 5: Claude CLIé›†æˆ
- Week 6: Gemini CLIé›†æˆ
- Week 7: å…¶ä»–CLIå·¥å…·é›†æˆ
- Week 8: å¤šæ™ºèƒ½ä½“åä½œæµ‹è¯•

#### Phase 3: é«˜çº§ç‰¹æ€§ (Weeks 9-12)
- Week 9: æ™ºèƒ½å†³ç­–å¼•æ“ä¼˜åŒ–
- Week 10: å­¦ä¹ å’Œé€‚åº”æœºåˆ¶
- Week 11: æ€§èƒ½ä¼˜åŒ–
- Week 12: å®Œæ•´ç³»ç»Ÿé›†æˆæµ‹è¯•

#### Phase 4: äº§å“åŒ–å’Œå‘å¸ƒ (Weeks 13-16)
- Week 13: ç”¨æˆ·ç•Œé¢å’Œç®¡ç†å·¥å…·
- Week 14: æ–‡æ¡£å’Œæ•™ç¨‹
- Week 15: å®‰å…¨æ€§åŠ å›º
- Week 16: æ­£å¼å‘å¸ƒ

---

è¿™ä¸ªè¯¦ç»†çš„æŠ€æœ¯è§„èŒƒä¸ºé—´æ¥ååŒç³»ç»Ÿæä¾›äº†å®Œæ•´çš„è®¾è®¡æŒ‡å¯¼ï¼ŒåŒ…æ‹¬ç³»ç»Ÿæ¶æ„ã€æ ¸å¿ƒç»„ä»¶ã€å®ç°ç»†èŠ‚å’Œå®æ–½è·¯çº¿å›¾ï¼Œç¡®ä¿ç³»ç»Ÿèƒ½å¤Ÿå®ç°å»ä¸­å¿ƒåŒ–çš„AI CLIåä½œç›®æ ‡ã€‚