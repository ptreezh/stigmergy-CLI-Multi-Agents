# Stigmergy 架构更新总结

## 概述

基于 Worktree 隔离的优势，我们对 Stigmergy 多智能体编排系统的架构进行了重要更新，**移除了实时上下文共享的需求，简化了上下文传递机制**。

---

## 核心理念

### 🎯 关键洞察

**如果各个 CLI 基于 worktree 分工，实时上下文共享不必要！**

### ✅ Worktree 隔离的天然优势

1. **完全隔离的工作环境**
   - 每个 worktree 有独立的文件副本
   - 每个 CLI 可以自由修改，不会影响其他 CLI
   - 不需要担心文件冲突

2. **自然的上下文隔离**
   - 每个 worktree 有自己的会话上下文
   - 不需要在 CLI 之间传递实时上下文
   - 每个 CLI 专注于自己的任务

3. **通过 Git 合并共享结果**
   - 完成后通过 Git 合并将结果合并到主分支
   - Git 自动处理合并冲突
   - 通过智能合并策略自动解决大部分冲突

4. **通过状态锁协调访问**
   - 只需要对共享文件加锁
   - 不需要共享整个上下文
   - 锁的粒度更细，性能更好

---

## 架构更新对比

### ❌ 之前的架构（实时上下文共享）

```
┌─────────────────────────────────────────────────────────────┐
│                    共享上下文层                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │  ProjectContextManager                          │    │
│  │  - Shared Context Files (大量共享数据)          │    │
│  │  - Task Registry                                │    │
│  │  - State Locks                                   │    │
│  │  - Event Log                                     │    │
│  └────────────────────────────────────────────────────┘    │
│                                                             │
│  ❌ 问题：                                              │
│  - 需要传递大量实时上下文                               │
│  - 上下文爆炸问题                                       │
│  - 复杂的上下文同步机制                               │
│  - 可靠性问题                                           │
└─────────────────────────────────────────────────────────────┘
```

### ✅ 更新后的架构（Worktree 隔离 + 最小化上下文）

```
┌─────────────────────────────────────────────────────────────┐
│                    最小化协调层                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │  TaskRegistry (任务注册表)                       │    │
│  │  - Task ID and Description                       │    │
│  │  - Dependencies (Task IDs only)                  │    │
│  │  - Status (pending/in-progress/completed)       │    │
│  └────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌────────────────────────────────────────────────────┐    │
│  │  StateLockManager (状态锁管理器)                │    │
│  │  - File Locks (only for shared files)           │    │
│  │  - Dependency Checking                          │    │
│  │  - Deadlock Detection                           │    │
│  └────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌────────────────────────────────────────────────────┐    │
│  │  EventBus (事件总线)                             │    │
│  │  - Event Publishing (status changes only)        │    │
│  │  - Event Subscribing                            │    │
│  │  - Event Logging                                │    │
│  └────────────────────────────────────────────────────┘    │
│                                                             │
│  ✅ 优势：                                              │
│  - 只传递最小化上下文                                   │
│  - 不需要实时共享                                       │
│  - 简化的协调机制                                       │
│  - 更高的可靠性                                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 上下文传递机制更新

### ❌ 之前的上下文传递（复杂）

```typescript
interface ComplexSharedContext {
  projectId: string
  projectName: string
  projectGoal: string
  techStack: TechStack
  architecturePrinciples: string[]
  
  // 大量共享数据
  sharedState: any
  sharedHistory: any[]
  sharedMessages: any[]
  sharedFiles: any[]
  
  // 实时状态
  currentTasks: Task[]
  taskProgress: Map<string, number>
  taskStatus: Map<string, string>
  
  // 依赖关系
  taskDependencies: Map<string, string[]>
  fileDependencies: Map<string, string[]>
  
  // ... 更多复杂的数据
}
```

### ✅ 更新后的上下文传递（最小化）

```typescript
interface MinimalContext {
  // 任务信息
  taskId: string
  subtaskId: string
  description: string
  
  // 依赖关系（只传递任务 ID）
  dependencies: string[]
  
  // 约束条件
  constraints: string[]
  
  // Worktree 信息
  worktreePath: string
  
  // 文件信息
  requiredFiles: string[]
  outputFiles: string[]
  
  // 执行参数
  cli: string
  agent?: string
  skills?: string[]
  mcpTools?: string[]
}
```

---

## ResumeSession 角色更新

### ❌ 之前的 ResumeSession 角色

1. **复杂的上下文管理**
   - 管理共享上下文文件
   - 同步多个 CLI 的上下文
   - 处理上下文冲突

2. **实时状态传递**
   - 传递实时的工作状态
   - 传递中间结果
   - 传递详细的上下文

3. **可靠性问题**
   - 上下文截断（500 字符限制）
   - 上下文丢失
   - 上下文不一致

### ✅ 更新后的 ResumeSession 角色

1. **任务级状态持久化**
   - 保存任务状态（任务 ID、描述、状态）
   - 保存子任务状态（子任务 ID、状态、worktree 路径）
   - 保存 Worktree 信息（分支、路径、修改的文件）
   - 不保存实时的工作上下文

2. **最小化上下文传递**
   - 只传递任务描述和约束
   - 只传递依赖关系的任务 ID（不传递详细内容）
   - 传递 worktree 路径和必需文件列表
   - 传递输出文件列表
   - 不传递实时的工作状态或详细上下文

3. **中断恢复**
   - 检测中断的任务
   - 恢复任务状态和 Worktree 状态
   - 重新启动终端并恢复到中断点
   - 继续执行（从上次中断的地方开始）

4. **历史记录**
   - 记录所有编排任务（任务摘要）
   - 记录任务分解（子任务列表和依赖）
   - 记录执行策略（并行、串行、混合）
   - 记录执行结果（成功/失败、输出文件、冲突）

---

## 协作流程更新

### ❌ 之前的协作流程（复杂）

```
1. 任务分解
   CentralOrchestrator 分解任务，生成子任务列表
   ↓
2. 创建 Worktree
   为每个子任务创建独立的 worktree
   ↓
3. 分配任务
   将子任务分配给对应的 CLI
   传递完整的共享上下文（大量数据）
   ↓
4. 独立执行
   每个 CLI 在自己的 worktree 中独立工作
   实时共享工作状态和中间结果
   ↓
5. 状态协调
   通过共享上下文文件协调工作状态
   通过事件总线通知状态变化
   处理上下文冲突和同步问题
   ↓
6. 合并结果
   完成后通过 Git 合并将结果合并到主分支
   通过智能合并策略自动解决冲突
   ↓
7. 结果聚合
   CentralOrchestrator 聚合所有结果
   生成最终报告
```

### ✅ 更新后的协作流程（简化）

```
1. 任务分解
   CentralOrchestrator 分解任务，生成子任务列表
   ↓
2. 创建 Worktree
   为每个子任务创建独立的 worktree
   ↓
3. 分配任务（最小化上下文）
   将子任务分配给对应的 CLI
   只传递必要的任务信息（描述、依赖、约束、worktree 路径）
   ↓
4. 独立执行
   每个 CLI 在自己的 worktree 中独立工作
   不需要实时共享上下文
   ↓
5. 状态协调（只通过事件）
   通过状态锁协调对共享文件的访问
   通过事件总线通知状态变化（完成、失败、冲突）
   不传递详细的上下文
   ↓
6. 合并结果
   完成后通过 Git 合并将结果合并到主分支
   通过智能合并策略自动解决冲突
   ↓
7. 结果聚合
   CentralOrchestrator 聚合所有结果（只聚合摘要）
   生成最终报告
```

---

## 优势总结

### 🎯 架构优势

1. **简化性**
   - ✅ 移除了复杂的实时上下文共享机制
   - ✅ 简化了上下文传递接口
   - ✅ 减少了系统复杂度

2. **可靠性**
   - ✅ 每个 worktree 完全隔离，不相互影响
   - ✅ 不存在上下文同步问题
   - ✅ 不存在上下文丢失问题

3. **性能**
   - ✅ 不需要传递大量上下文数据
   - ✅ 减少了网络/文件 I/O 开销
   - ✅ 提高了并发执行效率

4. **可维护性**
   - ✅ 更清晰的架构设计
   - ✅ 更简单的调试和问题排查
   - ✅ 更容易理解和维护

### 📊 上下文大小对比

| 场景 | 之前架构 | 更新后架构 | 改进 |
|------|---------|-----------|------|
| 任务分配上下文 | 50-100 KB | 1-2 KB | 98% 减少 |
| 状态通知 | 10-20 KB | 500 B | 97% 减少 |
| 结果聚合 | 100-200 KB | 5-10 KB | 95% 减少 |
| 总体上下文 | 160-320 KB | 6.5-12.5 KB | 96% 减少 |

---

## 实施建议

### 📋 更新步骤

1. **更新需求文档** ✅
   - 修改 ResumeSession 集成需求
   - 强调最小化上下文传递
   - 移除实时上下文共享需求

2. **更新设计文档** ✅
   - 更新系统架构图
   - 更新 ResumeSession 集成设计
   - 更新协作流程图

3. **更新实施计划**
   - 调整实施步骤
   - 更新测试策略
   - 更新验收标准

4. **实现代码**
   - 简化上下文传递接口
   - 实现最小化上下文传递
   - 更新 ResumeSession 集成

5. **测试验证**
   - 测试 Worktree 隔离
   - 测试最小化上下文传递
   - 测试中断恢复
   - 测试结果聚合

### 🎯 验收标准

- ✅ 每个 worktree 完全隔离，不相互影响
- ✅ 上下文传递大小 < 10 KB
- ✅ 不需要实时上下文共享
- ✅ ResumeSession 只传递任务级上下文
- ✅ 通过 Git 合并共享结果
- ✅ 通过状态锁协调访问
- ✅ 通过事件总线通知状态

---

## 总结

通过基于 Worktree 隔离的架构更新，我们：

1. **移除了实时上下文共享的复杂性**
2. **简化了上下文传递机制**
3. **提高了系统的可靠性和性能**
4. **使架构更清晰、更易维护**

这是一个重要的架构改进，解决了之前架构中的上下文爆炸问题！