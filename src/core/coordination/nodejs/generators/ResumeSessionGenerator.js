// ResumeSession Extension Generator
// ä¸“é—¨è´Ÿè´£ç”Ÿæˆå„CLIçš„ResumeSessionæ‰©å±•æ–‡ä»¶

const path = require('path');

class ResumeSessionGenerator {
  constructor() {
    this.supportedCLIs = [
      'claude', 'gemini', 'qwen', 'codebuddy', 'codex',
      'iflow', 'qodercli', 'copilot', 'kode', 'opencode',
      'oh-my-opencode', 'resumesession'
    ];
  }

  generateForCLI(cliName) {
    const needsSlashPrefix = ['claude', 'codebuddy'].includes(cliName.toLowerCase());
    const commandName = needsSlashPrefix ? '/stigmergy-resume' : 'stigmergy-resume';
    const currentProjectPath = process.cwd();

    return this.generateExtensionContent(cliName, commandName, currentProjectPath);
  }

  generateExtensionContent(cliName, commandName, projectPath) {
    return `// ${cliName.charAt(0).toUpperCase() + cliName.slice(1)} CLI ResumeSession Integration
// Auto-generated by ResumeSession v1.0.4
// Project: ${projectPath}

const fs = require('fs');
const path = require('path');
const os = require('os');

// Embedded path configuration for CLI session paths
const getAllCLISessionPaths = () => {
  const homeDir = os.homedir();
  return {
    claude: [path.join(homeDir, '.claude', 'projects')],
    gemini: [path.join(homeDir, '.config', 'gemini', 'tmp')],
    qwen: [path.join(homeDir, '.qwen', 'projects')],
    iflow: [path.join(homeDir, '.iflow', 'projects')],
    qodercli: [path.join(homeDir, '.qoder', 'projects')],
    codebuddy: [path.join(homeDir, '.codebuddy')],
    codex: [path.join(homeDir, '.config', 'codex')],
    kode: [path.join(homeDir, '.kode', 'projects')]
  };
};

// Embedded ResumeSession Core Functionality

class SessionScanner {
  scanSessions(cliType, sessionsPath, projectPath) {
    const sessions = [];
    if (!sessionsPath || !projectPath) return sessions;

    try {
      if (!fs.existsSync(sessionsPath)) return sessions;

      // For IFlow, Claude, QoderCLI, Kode: scan projects subdirectories (one level)
      if ((cliType === 'iflow' || cliType === 'claude' || cliType === 'qodercli' || cliType === 'kode') && sessionsPath.includes('projects')) {
        const subdirs = fs.readdirSync(sessionsPath);
        for (const subdir of subdirs) {
          const subdirPath = path.join(sessionsPath, subdir);
          try {
            const stat = fs.statSync(subdirPath);
            if (stat.isDirectory()) {
              sessions.push(...this.scanSessionFiles(cliType, subdirPath, projectPath));
            }
          } catch (error) {
            continue;
          }
        }
        return sessions;
      }

      // For Gemini: scan tmp/<hash>/chats subdirectories (multiple levels)
      if (cliType === 'gemini' && sessionsPath.includes('tmp')) {
        const hashDirs = fs.readdirSync(sessionsPath);
        for (const hashDir of hashDirs) {
          const hashDirPath = path.join(sessionsPath, hashDir);
          try {
            const stat = fs.statSync(hashDirPath);
            if (stat.isDirectory()) {
              const chatsPath = path.join(hashDirPath, 'chats');
              if (fs.existsSync(chatsPath)) {
                sessions.push(...this.scanSessionFiles(cliType, chatsPath, projectPath));
              }
            }
          } catch (error) {
            continue;
          }
        }
        return sessions;
      }

      // For Qwen: scan projects/<projectName>/chats subdirectories (two levels)
      if (cliType === 'qwen' && sessionsPath.includes('projects')) {
        const projectDirs = fs.readdirSync(sessionsPath);
        for (const projectDir of projectDirs) {
          const projectDirPath = path.join(sessionsPath, projectDir);
          try {
            const stat = fs.statSync(projectDirPath);
            if (stat.isDirectory()) {
              const chatsPath = path.join(projectDirPath, 'chats');
              if (fs.existsSync(chatsPath)) {
                sessions.push(...this.scanSessionFiles(cliType, chatsPath, projectPath));
              }
            }
          } catch (error) {
            continue;
          }
        }
        return sessions;
      }

      // For CodeBuddy: scan both projects subdirectories and root history.jsonl
      if (cliType === 'codebuddy') {
        const projectsPath = path.join(sessionsPath, 'projects');
        if (fs.existsSync(projectsPath)) {
          const projectDirs = fs.readdirSync(projectsPath);
          for (const projectDir of projectDirs) {
            const projectDirPath = path.join(projectsPath, projectDir);
            try {
              const stat = fs.statSync(projectDirPath);
              if (stat.isDirectory()) {
                sessions.push(...this.scanSessionFiles(cliType, projectDirPath, projectPath));
              }
            } catch (error) {
              continue;
            }
          }
        }
        sessions.push(...this.scanSessionFiles(cliType, sessionsPath, projectPath));
        return sessions;
      }

      return this.scanSessionFiles(cliType, sessionsPath, projectPath);
    } catch (error) {
      console.warn(\`Warning: Could not scan \${cliType} sessions:\`, error.message);
    }

    return sessions;
  }

  scanSessionFiles(cliType, sessionsPath, projectPath) {
    const sessions = [];
    try {
      const files = fs.readdirSync(sessionsPath);
      for (const file of files) {
        if (file.endsWith('.json') || file.endsWith('.session') || file.endsWith('.jsonl')) {
          try {
            const filePath = path.join(sessionsPath, file);
            let sessionData;

            if (file.endsWith('.jsonl')) {
              const content = fs.readFileSync(filePath, 'utf8');
              const lines = content.trim().split('\\n').filter(line => line.trim());
              const messages = lines.map(line => JSON.parse(line));

              if (messages.length === 0) continue;
              sessionData = this.parseJSONLSession(messages, file);
            } else {
              const content = fs.readFileSync(filePath, 'utf8');
              sessionData = JSON.parse(content);
            }

            if (this.isProjectSession(sessionData, projectPath)) {
              sessions.push({
                cliType,
                sessionId: sessionData.id || sessionData.sessionId || file.replace(/\\.(json|session|jsonl)$/, ''),
                title: sessionData.title || sessionData.topic || 'Untitled',
                content: this.extractContent(sessionData),
                updatedAt: new Date(sessionData.updatedAt || sessionData.timestamp || fs.statSync(filePath).mtime),
                messageCount: sessionData.messageCount || this.countMessages(sessionData),
                projectPath
              });
            }
          } catch (error) {
            console.warn(\`Warning: Could not parse \${file}:\`, error.message);
          }
        }
      }
    } catch (error) {
      console.warn('Warning: Could not scan files:', error.message);
    }

    return sessions;
  }

  parseJSONLSession(messages, filename) {
    const firstMsg = messages[0];
    const lastMsg = messages[messages.length - 1];
    const userMessages = messages.filter(m => m.type === 'user' || m.role === 'user');

    let title = 'Untitled Session';
    if (userMessages.length > 0) {
      const firstUserMsg = userMessages[0];
      let content = firstUserMsg.message?.content || firstUserMsg.content || '';
      if (typeof content === 'object') {
        content = JSON.stringify(content);
      }
      if (typeof content === 'string' && content.trim()) {
        title = content.substring(0, 100) || title;
      }
    }

    const contentParts = messages
      .map(m => {
        if (m.message && typeof m.message === 'object') {
          return m.message.content || m.message.text || '';
        }
        return m.content || m.text || '';
      })
      .filter(text => text && typeof text === 'string' && text.trim());

    return {
      sessionId: firstMsg.sessionId || filename.replace('.jsonl', ''),
      title: title,
      content: contentParts.join(' '),
      timestamp: lastMsg.timestamp || new Date().toISOString(),
      projectPath: firstMsg.cwd || firstMsg.workingDirectory,
      messageCount: messages.filter(m => m.type === 'user' || m.type === 'assistant' || m.role === 'user' || m.role === 'assistant').length,
      messages: messages
    };
  }

  scanAllCLISessions(projectPath) {
    const allSessions = [];
    const cliPathsMap = getAllCLISessionPaths();

    for (const [cliType, sessionsPaths] of Object.entries(cliPathsMap)) {
      for (const sessionsPath of sessionsPaths) {
        const sessions = this.scanSessions(cliType, sessionsPath, projectPath);
        allSessions.push(...sessions);
      }
    }

    return allSessions;
  }

  isProjectSession(session, projectPath) {
    const sessionProject = session.projectPath || session.workingDirectory;
    if (!sessionProject) return true;

    return sessionProject === projectPath ||
           sessionProject.startsWith(projectPath) ||
           projectPath.startsWith(sessionProject);
  }

  extractContent(sessionData) {
    if (sessionData.content && typeof sessionData.content === 'string') {
      return sessionData.content;
    }

    if (sessionData.messages && Array.isArray(sessionData.messages)) {
      return sessionData.messages
        .map(msg => {
          if (msg.message && typeof msg.message === 'object') {
            const content = msg.message.content || msg.message.text || '';
            return this.extractTextFromContent(content);
          }
          const content = msg.content || msg.text || '';
          return this.extractTextFromContent(content);
        })
        .filter(text => text && typeof text === 'string' && text.trim())
        .join(' ');
    }

    if (Array.isArray(sessionData)) {
      return sessionData
        .map(item => {
          if (item.message && typeof item.message === 'object') {
            const content = item.message.content || item.message.text || '';
            return this.extractTextFromContent(content);
          }
          const content = item.content || item.text || '';
          return this.extractTextFromContent(content);
        })
        .filter(text => text && typeof text === 'string' && text.trim())
        .join(' ');
    }

    return '';
  }

  extractTextFromContent(content) {
    if (typeof content === 'string') {
      return content;
    }

    if (Array.isArray(content)) {
      return content
        .map(item => {
          if (typeof item === 'string') return item;
          if (item && typeof item === 'object') {
            return item.text || item.content || '';
          }
          return '';
        })
        .filter(text => text && typeof text === 'string')
        .join(' ');
    }

    if (content && typeof content === 'object') {
      return content.text || content.content || JSON.stringify(content);
    }

    return '';
  }

  countMessages(sessionData) {
    if (sessionData.messages) {
      return Array.isArray(sessionData.messages) ? sessionData.messages.length : 0;
    }

    if (Array.isArray(sessionData)) {
      return sessionData.length;
    }

    return 0;
  }
}

class SessionFilter {
  filterByCLI(sessions, cliType) {
    if (!cliType) return sessions;
    return sessions.filter(session => session.cliType === cliType);
  }

  filterBySearch(sessions, searchTerm) {
    if (!searchTerm) return sessions;

    const lowerSearch = searchTerm.toLowerCase();
    return sessions.filter(session =>
      session.title.toLowerCase().includes(lowerSearch) ||
      session.content.toLowerCase().includes(lowerSearch)
    );
  }

  filterByDateRange(sessions, timeRange = 'all') {
    if (timeRange === 'all') return sessions;

    const now = new Date();
    return sessions.filter(session => {
      const sessionDate = new Date(session.updatedAt);

      switch (timeRange) {
        case 'today':
          return sessionDate.toDateString() === now.toDateString();
        case 'week': {
          const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          return sessionDate >= weekAgo;
        }
        case 'month': {
          const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
          return sessionDate >= monthAgo;
        }
        default:
          return true;
      }
    });
  }

  sortByDate(sessions) {
    return [...sessions].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
  }

  filterByProject(sessions, projectPath) {
    return sessions.filter(session => session.projectPath === projectPath);
  }

  applyFilters(sessions, options, projectPath) {
    let filteredSessions = [...sessions];

    filteredSessions = this.filterByProject(filteredSessions, projectPath);

    if (options.cli) {
      filteredSessions = this.filterByCLI(filteredSessions, options.cli);
    }

    if (options.search) {
      filteredSessions = this.filterBySearch(filteredSessions, options.search);
    }

    if (options.timeRange) {
      filteredSessions = this.filterByDateRange(filteredSessions, options.timeRange);
    }

    filteredSessions = this.sortByDate(filteredSessions);

    if (options.limit && options.limit > 0) {
      filteredSessions = filteredSessions.slice(0, options.limit);
    }

    return filteredSessions;
  }
}

class HistoryFormatter {
  formatSummary(sessions, context) {
    if (sessions.length === 0) {
      return \`ğŸ“­ å½“å‰é¡¹ç›®æš‚æ— å†å²ä¼šè¯\\n\\nğŸ’¡ **æç¤º:** å°è¯•: ${commandName} --search <å…³é”®è¯>\`;
    }

    let response = \`ğŸ“ **é¡¹ç›®å†å²ä¼šè¯**\\n\\nğŸ“Š å…±æ‰¾åˆ° \${sessions.length} ä¸ªä¼šè¯\\n\\n\`;

    const byCLI = {};
    sessions.forEach(session => {
      if (!byCLI[session.cliType]) byCLI[session.cliType] = [];
      byCLI[session.cliType].push(session);
    });

    Object.entries(byCLI).forEach(([cli, cliSessions]) => {
      const icon = this.getCLIIcon(cli);
      response += \`\${icon} **\${cli.toUpperCase()}** (\${cliSessions.length}ä¸ª)\\n\`;

      cliSessions.slice(0, 3).forEach((session, i) => {
        const date = this.formatDate(session.updatedAt);
        const title = session.title.substring(0, 50);
        response += \`   \${i + 1}. \${title}...\\n\`;
        response += \`      ğŸ“… \${date} â€¢ ğŸ’¬ \${session.messageCount}æ¡æ¶ˆæ¯\\n\`;
      });

      if (cliSessions.length > 3) {
        response += \`   ... è¿˜æœ‰ \${cliSessions.length - 3} ä¸ªä¼šè¯\\n\`;
      }
      response += '\\n';
    });

    response += \`ğŸ’¡ **ä½¿ç”¨æ–¹æ³•:**\\n\`;
    response += \`â€¢ '${commandName} --cli <å·¥å…·>' - æŸ¥çœ‹ç‰¹å®šCLI\\n\`;
    response += \`â€¢ '${commandName} --search <å…³é”®è¯>' - æœç´¢å†…å®¹\\n\`;
    response += \`â€¢ '${commandName} --format timeline' - æ—¶é—´çº¿è§†å›¾\`;

    return response;
  }

  getCLIIcon(cliType) {
    const icons = {
      'claude': 'ğŸŸ¢',
      'gemini': 'ğŸ”µ',
      'qwen': 'ğŸŸ¡',
      'iflow': 'ğŸ”´',
      'codebuddy': 'ğŸŸ£',
      'codex': 'ğŸŸª',
      'qodercli': 'ğŸŸ ',
      'kode': 'âš¡'
    };
    return icons[cliType] || 'ğŸ”¹';
  }

  formatDate(date) {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const days = Math.floor(diff / (24 * 60 * 60 * 1000));

    if (days === 0) {
      return date.toLocaleTimeString();
    } else if (days === 1) {
      return 'æ˜¨å¤©';
    } else if (days < 7) {
      return \`\${days}å¤©å‰\`;
    } else if (days < 30) {
      return \`\${Math.floor(days / 7)}å‘¨å‰\`;
    } else {
      return \`\${Math.floor(days / 30)}ä¸ªæœˆå‰\`;
    }
  }
}

class HistoryQuery {
  constructor() {
    this.scanner = new SessionScanner();
    this.filter = new SessionFilter();
    this.formatter = new HistoryFormatter();
  }

  queryHistory(options, projectPath) {
    try {
      const allSessions = this.scanner.scanAllCLISessions(projectPath);
      const filteredSessions = this.filter.applyFilters(allSessions, options, projectPath);

      const response = this.formatter.formatSummary(filteredSessions);
      const suggestions = this.generateSuggestions(filteredSessions, options);

      return {
        response,
        suggestions
      };
    } catch (error) {
      return {
        response: \`âŒ å†å²æŸ¥è¯¢å¤±è´¥: \${error.message}\`,
        suggestions: ['${commandName} --help']
      };
    }
  }

  generateSuggestions(sessions, query) {
    const suggestions = [];

    if (sessions.length > 0) {
      suggestions.push(\`${commandName} --format timeline\`);

      if (sessions[0]?.cliType) {
        suggestions.push(\`${commandName} --cli \${sessions[0].cliType}\`);
      }
    }

    suggestions.push(\`${commandName} --search "react"\`);
    suggestions.push(\`${commandName} --today\`);

    return suggestions.slice(0, 5);
  }
}

/**
 * å¤„ç† ${commandName} å‘½ä»¤
 */
async function handleHistoryCommand(input, context) {
  try {
    console.log('ğŸ” Searching cross-CLI history...');

    const query = buildQuery(input);
    const historyQuery = new HistoryQuery();
    const result = historyQuery.queryHistory(query, '${projectPath}');

    return {
      response: result.response,
      suggestions: result.suggestions
    };
  } catch (error) {
    console.error('History command error:', error);
    return {
      response: \`âŒ å†å²æŸ¥è¯¢å¤±è´¥: \${error.message}\`,
      suggestions: ['${commandName} --help']
    };
  }
}

/**
 * æ„å»ºæŸ¥è¯¢å‚æ•°
 */
function buildQuery(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(new RegExp('^\\\\\\\\/?' + '${commandName}' + '\\\\\\s*', 'i'), '').trim();
  const parts = cleanInput.split(/\\\\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();

    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format' && i + 1 < parts.length) {
      const format = parts[++i]?.toLowerCase();
      if (['summary', 'timeline', 'detailed', 'context'].includes(format)) {
        options.format = format;
      }
    } else if (part === '--today') {
      options.timeRange = 'today';
    } else if (part === '--week') {
      options.timeRange = 'week';
    } else if (part === '--month') {
      options.timeRange = 'month';
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

// CLI-specific registration logic

${this.generateCLIRegistrationCode(cliName, commandName, projectPath)}
`;
  }

  generateCLIRegistrationCode(cliName, commandName, projectPath) {
    switch (cliName.toLowerCase()) {
      case 'claude':
      case 'codebuddy':
        return `
// ${cliName.charAt(0).toUpperCase() + cliName.slice(1)} CLI integration

// Command name constant
const commandName = '${commandName}';

// Main command handler
function handleHistoryCommand(input) {
  if (!input || typeof input !== 'string') {
    return {
      response: 'Usage: ' + commandName + ' [options]\\n' +
                'Options:\\n' +
                '  --cli <name>     Filter by CLI (claude, gemini, qwen, etc.)\\n' +
                '  --search <term>  Search in session content\\n' +
                '  --limit <num>    Maximum sessions to show (default: 10)\\n' +
                '  --format <type>  Output format: summary, detailed, json (default: summary)\\n' +
                '  --time <range>   Time range: today, week, month, all (default: all)',
      suggestions: []
    };
  }

  try {
    const options = parseCommandOptions(input);
    const historyQuery = new HistoryQuery();
    const result = historyQuery.queryHistory(options, projectPath);
    
    return {
      response: result.response,
      suggestions: result.suggestions || []
    };
  } catch (error) {
    return {
      response: 'Error: ' + error.message,
      suggestions: []
    };
  }
}

// Parse command options
function parseCommandOptions(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(new RegExp('^\\\\/?' + commandName + '\\\\\s*', 'i'), '').trim();
  const parts = cleanInput.split(/\\\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();
    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format' && i + 1 < parts.length) {
      options.format = parts[++i];
    } else if (part === '--time' && i + 1 < parts.length) {
      options.timeRange = parts[++i];
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

// Register command
if (typeof ${cliName} !== 'undefined') {
  ${cliName}.addCommand('${commandName}', handleHistoryCommand);
}

// å¯¼å‡ºå¤„ç†å™¨
module.exports = {
  handleHistoryCommand,
  parseCommandOptions
};`;

      case 'gemini':
        return `
class GeminiHistoryHandler {
  constructor() {
    this.commandName = '${commandName}';
  }

  async handleCommand(input, session) {
    if (!input.startsWith('${commandName}')) return null;

    try {
      const options = this.buildQuery(input);
      const historyQuery = new HistoryQuery();
      const result = historyQuery.queryHistory(options, '${projectPath}');

      return {
        text: result.response,
        continue: true,
        suggestions: result.suggestions
      };
    } catch (error) {
      return {
        text: \`History command failed: \${error.message}\`,
        continue: true,
        suggestions: []
      };
    }
  }

  buildQuery(input) {
    const options = {
      limit: 10,
      format: 'summary',
      timeRange: 'all',
      cli: null,
      search: null
    };

    const cleanInput = input.replace(new RegExp('^\\\\/?' + this.commandName + '\\\\\s*', 'i'), '').trim();
    const parts = cleanInput.split(/\\\s+/).filter(p => p.length > 0);

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i].toLowerCase();
      if (part === '--cli' && i + 1 < parts.length) {
        options.cli = parts[++i];
      } else if (part === '--search' && i + 1 < parts.length) {
        options.search = parts[++i];
      } else if (part === '--limit' && i + 1 < parts.length) {
        options.limit = parseInt(parts[++i]);
      } else if (part === '--format' && i + 1 < parts.length) {
        options.format = parts[++i];
      } else if (part === '--time' && i + 1 < parts.length) {
        options.timeRange = parts[++i];
      } else if (!part.startsWith('--') && !options.search) {
        options.search = part;
      }
    }

    return options;
  }
}

// æ³¨å†Œå¤„ç†å™¨
const handler = new GeminiHistoryHandler();

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { GeminiHistoryHandler, handler };
}

if (typeof geminiCLI !== 'undefined') {
  const cmdName = '${commandName}'.replace(/^\\\//, '');
  geminiCLI.addCommandHandler(cmdName, handler.handleCommand.bind(handler));
}`;

      case 'qwen':
      case 'qodercli':
      case 'kode':
        return `
// ${cliName.charAt(0).toUpperCase() + cliName.slice(1)} CLI integration

// Command name constant
const commandName = '${commandName}';

// Main command handler
function handleHistoryCommand(input) {
  if (!input || typeof input !== 'string') {
    return {
      response: 'Usage: ' + commandName + ' [options]\\n' +
                'Options:\\n' +
                '  --cli <name>     Filter by CLI (claude, gemini, qwen, etc.)\\n' +
                '  --search <term>  Search in session content\\n' +
                '  --limit <num>    Maximum sessions to show (default: 10)\\n' +
                '  --format <type>  Output format: summary, detailed, json (default: summary)\\n' +
                '  --time <range>   Time range: today, week, month, all (default: all)',
      suggestions: []
    };
  }

  try {
    const options = parseCommandOptions(input);
    const historyQuery = new HistoryQuery();
    const result = historyQuery.queryHistory(options, projectPath);
    
    return {
      response: result.response,
      suggestions: result.suggestions || []
    };
  } catch (error) {
    return {
      response: 'Error: ' + error.message,
      suggestions: []
    };
  }
}

// Parse command options
function parseCommandOptions(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(new RegExp('^\\\\/?' + commandName + '\\\\\s*', 'i'), '').trim();
  const parts = cleanInput.split(/\\\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();
    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format' && i + 1 < parts.length) {
      options.format = parts[++i];
    } else if (part === '--time' && i + 1 < parts.length) {
      options.timeRange = parts[++i];
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

// Register extension
if (typeof ${cliName} !== 'undefined' && ${cliName}.addExtension) {
  ${cliName}.addExtension('history', handleHistoryCommand);
}

// å¯¼å‡ºå¤„ç†å™¨
module.exports = {
  handleHistoryCommand,
  parseCommandOptions
};`;

      default:
        return `
// ${cliName.charAt(0).toUpperCase() + cliName.slice(1)} CLI integration
// Generic registration - may need customization for specific CLI

// Command name constant
const commandName = '${commandName}';

// Main command handler
function handleHistoryCommand(input) {
  if (!input || typeof input !== 'string') {
    return {
      response: 'Usage: ' + commandName + ' [options]\\n' +
                'Options:\\n' +
                '  --cli <name>     Filter by CLI (claude, gemini, qwen, etc.)\\n' +
                '  --search <term>  Search in session content\\n' +
                '  --limit <num>    Maximum sessions to show (default: 10)\\n' +
                '  --format <type>  Output format: summary, detailed, json (default: summary)\\n' +
                '  --time <range>   Time range: today, week, month, all (default: all)',
      suggestions: []
    };
  }

  try {
    const options = parseCommandOptions(input);
    const historyQuery = new HistoryQuery();
    const result = historyQuery.queryHistory(options, projectPath);
    
    return {
      response: result.response,
      suggestions: result.suggestions || []
    };
  } catch (error) {
    return {
      response: 'Error: ' + error.message,
      suggestions: []
    };
  }
}

// Parse command options
function parseCommandOptions(input) {
  const options = {
    limit: 10,
    format: 'summary',
    timeRange: 'all',
    cli: null,
    search: null
  };

  const cleanInput = input.replace(new RegExp('^\\\\/?' + commandName + '\\\\\s*', 'i'), '').trim();
  const parts = cleanInput.split(/\\\s+/).filter(p => p.length > 0);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].toLowerCase();
    if (part === '--cli' && i + 1 < parts.length) {
      options.cli = parts[++i];
    } else if (part === '--search' && i + 1 < parts.length) {
      options.search = parts[++i];
    } else if (part === '--limit' && i + 1 < parts.length) {
      options.limit = parseInt(parts[++i]);
    } else if (part === '--format' && i + 1 < parts.length) {
      options.format = parts[++i];
    } else if (part === '--time' && i + 1 < parts.length) {
      options.timeRange = parts[++i];
    } else if (!part.startsWith('--') && !options.search) {
      options.search = part;
    }
  }

  return options;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    handleHistoryCommand,
    parseCommandOptions
  };
}`;

      case 'opencode':
        return `
// OpenCode CLI ResumeSession Integration
// ä¸“é—¨ä¸º OpenCode å®ç°çš„ä¼šè¯æ¢å¤åŠŸèƒ½

const fs = require('fs');
const path = require('path');
const os = require('os');

class OpenCodeResumeSession {
  constructor() {
    this.homeDir = os.homedir();
    this.opencodeConfigPath = path.join(this.homeDir, '.opencode');
    this.sessionStoragePath = path.join(this.opencodeConfigPath, 'sessions');
  }

  getProjectPathHash(projectPath) {
    return projectPath
      .replace(/^([A-Za-z]):\\\\/, '$1--')
      .replace(/\\\\/g, '-')
      .replace(/\//g, '-');
  }

  findOpenCodeSessions(projectPath) {
    const sessions = [];

    if (!fs.existsSync(this.sessionStoragePath)) {
      return sessions;
    }

    try {
      const projectHash = this.getProjectPathHash(projectPath);
      const projectSessionPath = path.join(this.sessionStoragePath, projectHash);

      if (!fs.existsSync(projectSessionPath)) {
        return sessions;
      }

      const files = fs.readdirSync(projectSessionPath);
      
      for (const file of files) {
        if (file.endsWith('.json') || file.endsWith('.jsonl')) {
          const filePath = path.join(projectSessionPath, file);
          try {
            const stats = fs.statSync(filePath);
            sessions.push({
              id: file.replace(/\\.(json|jsonl)$/, ''),
              file: file,
              path: filePath,
              modified: stats.mtime,
              size: stats.size
            });
          } catch (error) {
            continue;
          }
        }
      }

      sessions.sort((a, b) => b.modified - a.modified);

    } catch (error) {
      console.error('Error finding OpenCode sessions:', error.message);
    }

    return sessions;
  }

  readSession(sessionPath) {
    try {
      const content = fs.readFileSync(sessionPath, 'utf8');
      
      if (sessionPath.endsWith('.jsonl')) {
        const lines = content.trim().split('\\n').filter(line => line.trim());
        return lines.map(line => {
          try {
            return JSON.parse(line);
          } catch (e) {
            return null;
          }
        }).filter(msg => msg !== null);
      } else {
        return JSON.parse(content);
      }
    } catch (error) {
      console.error('Error reading session:', error.message);
      return null;
    }
  }

  formatSession(session, options = {}) {
    const { format = 'summary', limit = 5 } = options;
    const messages = this.readSession(session.path);

    if (!messages || messages.length === 0) {
      return 'ğŸ“­ ä¼šè¯ä¸ºç©ºæˆ–æ— æ³•è¯»å–';
    }

    const messageList = Array.isArray(messages) ? messages : 
                       (messages.messages && Array.isArray(messages.messages)) ? messages.messages : [];

    if (messageList.length === 0) {
      return 'ğŸ“­ ä¼šè¯æ²¡æœ‰æ¶ˆæ¯';
    }

    const output = [];

    if (format === 'summary') {
      output.push('ğŸ“‹ OpenCode ä¼šè¯æ‘˜è¦');
      output.push('');
      output.push('ğŸ†” ä¼šè¯ ID: ' + session.id);
      output.push('ğŸ“… æœ€åä¿®æ”¹: ' + session.modified.toLocaleString());
      output.push('ğŸ“ æ¶ˆæ¯æ•°é‡: ' + messageList.length);
      output.push('');
      
      const recentMessages = messageList.slice(-limit);
      output.push('æœ€è¿‘æ¶ˆæ¯:');
      recentMessages.forEach((msg, index) => {
        const role = msg.type || msg.role || 'unknown';
        const prefix = role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–';
        const content = this.extractContent(msg);
        const preview = content ? content.substring(0, 100) + (content.length > 100 ? '...' : '') : '(æ— å†…å®¹)';
        output.push('  ' + prefix + ' ' + preview);
      });

    } else if (format === 'detailed') {
      output.push('ğŸ“‹ OpenCode å®Œæ•´ä¼šè¯');
      output.push('');
      output.push('ğŸ†” ä¼šè¯ ID: ' + session.id);
      output.push('ğŸ“… æœ€åä¿®æ”¹: ' + session.modified.toLocaleString());
      output.push('ğŸ“ æ–‡ä»¶: ' + session.file);
      output.push('');
      output.push('---');
      output.push('');
      output.push('ğŸ“ å®Œæ•´å¯¹è¯å†…å®¹:');
      output.push('');

      messageList.forEach((msg, index) => {
        const role = msg.type || msg.role || 'unknown';
        const prefix = role === 'user' ? 'ğŸ‘¤ ç”¨æˆ·' : 'ğŸ¤– åŠ©æ‰‹';
        const content = this.extractContent(msg);

        if (content && content.trim()) {
          output.push(prefix + ':');
          output.push(content);
          output.push('');
        }
      });
    }

    return output.join('\\n');
  }

  extractContent(msg) {
    if (msg.message && typeof msg.message === 'object') {
      const content = msg.message.content || msg.message.text || '';
      return this.extractTextFromContent(content);
    }

    const content = msg.content || msg.text || '';
    return this.extractTextFromContent(content);
  }

  extractTextFromContent(content) {
    if (typeof content === 'string') {
      return content;
    }

    if (Array.isArray(content)) {
      return content
        .map(item => {
          if (typeof item === 'string') return item;
          if (item && typeof item === 'object') {
            return item.text || item.content || '';
          }
          return '';
        })
        .filter(text => text && typeof text === 'string')
        .join(' ');
    }

    if (content && typeof content === 'object') {
      return content.text || content.content || '';
    }

    return '';
  }

  execute(options = {}) {
    const { format = 'summary', sessionId = null, limit = 5 } = options;
    const projectPath = process.cwd();
    const sessions = this.findOpenCodeSessions(projectPath);

    if (sessions.length === 0) {
      return 'ğŸ“­ æœªæ‰¾åˆ° OpenCode ä¼šè¯\\nğŸ’¡ é¡¹ç›®è·¯å¾„: ' + projectPath;
    }

    if (sessionId) {
      const session = sessions.find(s => s.id === sessionId);
      if (!session) {
        return 'âŒ æœªæ‰¾åˆ°ä¼šè¯ ID: ' + sessionId + '\\nğŸ’¡ å¯ç”¨ä¼šè¯: ' + sessions.map(s => s.id).join(', ');
      }
      return this.formatSession(session, { format, limit });
    } else {
      const latestSession = sessions[0];
      let result = this.formatSession(latestSession, { format, limit });

      if (sessions.length > 1) {
        result += '\\n\\nğŸ’¡ è¿˜æœ‰ ' + (sessions.length - 1) + ' ä¸ªå…¶ä»–ä¼šè¯å¯ç”¨';
        result += '\\nğŸ’¡ ä½¿ç”¨ --session <id> æŸ¥çœ‹å…¶ä»–ä¼šè¯';
      }

      return result;
    }
  }

  listSessions() {
    const projectPath = process.cwd();
    const sessions = this.findOpenCodeSessions(projectPath);

    if (sessions.length === 0) {
      return 'ğŸ“­ æœªæ‰¾åˆ° OpenCode ä¼šè¯';
    }

    let output = 'ğŸ“‹ OpenCode ä¼šè¯åˆ—è¡¨\\n\\n';
    output += 'ğŸ“Š å…±æ‰¾åˆ° ' + sessions.length + ' ä¸ªä¼šè¯\\n\\n';

    sessions.forEach((session, index) => {
      output += (index + 1) + '. ' + session.id + '\\n';
      output += '   ğŸ“… ' + session.modified.toLocaleString() + '\\n';
      output += '   ğŸ“ ' + session.file + '\\n\\n';
    });

    return output;
  }
}

// Main handler
function handleHistoryCommand(input) {
  if (!input || typeof input !== 'string') {
    return {
      response: 'Usage: ' + commandName + ' [options]\\n' +
                'Options:\\n' +
                '  --detailed, -d  æ˜¾ç¤ºè¯¦ç»†è¾“å‡º\\n' +
                '  --list, -l     åˆ—å‡ºæ‰€æœ‰ä¼šè¯\\n' +
                '  --session, -s <id>  æŒ‡å®šä¼šè¯ID\\n' +
                '  --limit <num>  æ˜¾ç¤ºæ¶ˆæ¯æ•°é‡ï¼ˆé»˜è®¤: 5ï¼‰',
      suggestions: []
    };
  }

  try {
    const resumeSession = new OpenCodeResumeSession();
    const options = {
      format: 'summary',
      sessionId: null,
      limit: 5
    };

    const parts = input.trim().split(/\\s+/);
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      if (part === '--detailed' || part === '-d') {
        options.format = 'detailed';
      } else if (part === '--list' || part === '-l') {
        return {
          response: resumeSession.listSessions(),
          suggestions: []
        };
      } else if ((part === '--session' || part === '-s') && i + 1 < parts.length) {
        options.sessionId = parts[++i];
      } else if (part === '--limit' && i + 1 < parts.length) {
        options.limit = parseInt(parts[++i]);
      } else if (!part.startsWith('--')) {
        options.sessionId = part;
      }
    }

    return {
      response: resumeSession.execute(options),
      suggestions: []
    };
  } catch (error) {
    return {
      response: 'Error: ' + error.message,
      suggestions: []
    };
  }
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    handleHistoryCommand,
    OpenCodeResumeSession
  };
}`;
    }
  }

  getFileName(cliName) {
    switch (cliName.toLowerCase()) {
      case 'claude':
      case 'gemini':
      case 'qwen':
      case 'codebuddy':
      case 'codex':
      case 'kode':
      case 'resumesession':
        return 'resumesession-history.js';
      case 'qodercli':
        return 'history.js';
      case 'opencode':
        return 'opencode-resume.js';
      default:
        return 'resumesession-history.js';
    }
  }
}

module.exports = ResumeSessionGenerator;