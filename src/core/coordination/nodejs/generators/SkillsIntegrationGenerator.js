// Skills Integration Generator
// 专门负责生成各CLI的Skills集成文件

const path = require('path');
const os = require('os');

class SkillsIntegrationGenerator {
  constructor() {
    this.supportedCLIs = [
      'claude', 'gemini', 'qwen', 'codebuddy', 'codex',
      'iflow', 'qodercli', 'copilot', 'kode'
    ];
  }

  generateForCLI(cliName) {
    const currentProjectPath = process.cwd();
    const skillsDir = path.join(os.homedir(), '.stigmergy', 'skills');

    switch (cliName.toLowerCase()) {
      case 'claude':
        return {
          fileName: 'claude_skills_hook.py',
          content: this.generateClaudeSkillsIntegration(currentProjectPath, skillsDir)
        };
      case 'gemini':
        return {
          fileName: 'skills-extension.js',
          content: this.generateGeminiSkillsIntegration(currentProjectPath, skillsDir)
        };
      case 'qwen':
        return {
          fileName: 'skills-hook.js',
          content: this.generateQwenSkillsIntegration(currentProjectPath, skillsDir)
        };
      case 'codebuddy':
        return {
          fileName: 'skills-integration.js',
          content: this.generateCodeBuddySkillsIntegration(currentProjectPath, skillsDir)
        };
      case 'codex':
        return {
          fileName: 'skills-handler.js',
          content: this.generateCodexSkillsIntegration(currentProjectPath, skillsDir)
        };
      case 'qodercli':
        return {
          fileName: 'skills-extension.js',
          content: this.generateQoderCliSkillsIntegration(currentProjectPath, skillsDir)
        };
      default:
        return {
          fileName: 'skills-hook.js',
          content: this.generateGenericSkillsIntegration(cliName, currentProjectPath, skillsDir)
        };
    }
  }

  generateClaudeSkillsIntegration(projectPath, skillsDir) {
    return `"""
Claude CLI Skills Integration Hook
Auto-generated by Stigmergy CLI v1.2.1
Project: ${projectPath}
Skills Directory: ${skillsDir}

This hook provides skills integration for Claude CLI with dynamic loading
and execution of skills from the centralized skills directory.
"""

import sys
import os
import json
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any

class ClaudeSkillsHook:
    def __init__(self):
        self.skills_dir = Path("${skillsDir.replace(/\\/g, '\\\\')}")
        self.loaded_skills = {}
        self.skill_metadata = {}

    def initialize(self):
        """Initialize the skills hook"""
        print("[CLAUDE_SKILLS] Initializing skills integration...")
        self.load_skills()
        print(f"[CLAUDE_SKILLS] Loaded {len(self.loaded_skills)} skills")

    def load_skills(self):
        """Dynamically load all available skills"""
        if not self.skills_dir.exists():
            print(f"[CLAUDE_SKILLS] Skills directory not found: {self.skills_dir}")
            return

        try:
            for skill_dir in self.skills_dir.iterdir():
                if skill_dir.is_dir() and (skill_dir / 'SKILL.md').exists():
                    skill = self.load_skill(skill_dir)
                    if skill:
                        self.loaded_skills[skill_dir.name] = skill
                        self.skill_metadata[skill_dir.name] = self.parse_skill_metadata(skill_dir)
                        print(f"[CLAUDE_SKILLS] Loaded skill: {skill_dir.name}")
        except Exception as e:
            print(f"[CLAUDE_SKILLS] Failed to load skills: {e}")

    def load_skill(self, skill_dir):
        """Load a single skill from directory"""
        try:
            # Check for skill implementation files
            for py_file in skill_dir.glob("*.py"):
                if py_file.name != "test_skill.py":  # Skip test files
                    spec = importlib.util.spec_from_file_location(
                        skill_dir.name, py_file
                    )
                    if spec and spec.loader:
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        return module
        except Exception as e:
            print(f"[CLAUDE_SKILLS] Failed to load skill {skill_dir.name}: {e}")
        return None

    def parse_skill_metadata(self, skill_dir):
        """Parse skill metadata from SKILL.md"""
        try:
            skill_md = skill_dir / 'SKILL.md'
            if skill_md.exists():
                content = skill_md.read_text(encoding='utf-8')
                metadata = {}

                for line in content.split('\\n'):
                    if line.startswith('## Description:'):
                        metadata['description'] = line.replace('## Description:', '').strip()
                    elif line.startswith('## Usage:'):
                        metadata['usage'] = line.replace('## Usage:', '').strip()
                    elif line.startswith('## Location:'):
                        metadata['location'] = line.replace('## Location:', '').strip()

                return metadata
        except Exception as e:
            print(f"[CLAUDE_SKILLS] Failed to parse metadata for {skill_dir.name}: {e}")

        return {}

    def find_relevant_skills(self, prompt: str) -> List[str]:
        """Find skills relevant to the given prompt"""
        relevant_skills = []
        prompt_lower = prompt.lower()

        for skill_name, metadata in self.skill_metadata.items():
            if self.is_skill_relevant(metadata, prompt_lower):
                relevant_skills.append(skill_name)

        return relevant_skills

    def is_skill_relevant(self, metadata: Dict, prompt: str) -> bool:
        """Check if a skill is relevant to the prompt"""
        description = metadata.get('description', '').lower()
        usage = metadata.get('usage', '').lower()

        # Simple keyword matching - can be enhanced with more sophisticated NLP
        keywords = ['create', 'design', 'build', 'generate', 'analyze', 'process', 'document', 'code']

        # Check if any keywords from the skill match the prompt
        skill_text = f"{description} {usage}"

        # Look for matches between skill description and prompt
        for word in skill_text.split():
            if len(word) > 3 and word in prompt:
                return True

        return False

    def execute_skill(self, skill_name: str, prompt: str, context: Dict = None) -> Optional[str]:
        """Execute a specific skill"""
        if skill_name not in self.loaded_skills:
            print(f"[CLAUDE_SKILLS] Skill not found: {skill_name}")
            return None

        try:
            skill_module = self.loaded_skills[skill_name]
            metadata = self.skill_metadata[skill_name]

            # Call the skill if it has a main function
            if hasattr(skill_module, 'main') or hasattr(skill_module, 'execute'):
                execute_func = getattr(skill_module, 'main') or getattr(skill_module, 'execute')
                result = execute_func(prompt, context or {})
                return result
            else:
                return f"[SKILL: {skill_name}] Available but no execution function found"

        except Exception as e:
            print(f"[CLAUDE_SKILLS] Error executing skill {skill_name}: {e}")
            return f"[SKILL: {skill_name}] Error: {str(e)}"

    def on_prompt(self, prompt: str, context: Dict = None) -> List[str]:
        """Handle prompt and execute relevant skills"""
        if not self.loaded_skills:
            self.initialize()

        relevant_skills = self.find_relevant_skills(prompt)
        results = []

        for skill_name in relevant_skills:
            result = self.execute_skill(skill_name, prompt, context)
            if result:
                results.append(result)

        return results

# Global hook instance
hook = ClaudeSkillsHook()

def on_prompt(prompt, context=None):
    """Main hook function called by Claude CLI"""
    return hook.on_prompt(prompt, context)

def initialize():
    """Initialize the hook"""
    return hook.initialize()

# Export functions for Claude's hook system
__all__ = ['on_prompt', 'initialize']
`;
  }

  generateGeminiSkillsIntegration(projectPath, skillsDir) {
    return `// Gemini CLI Skills Integration Extension
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');
const os = require('os');

class GeminiSkillsExtension {
  constructor() {
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
    this.skillMetadata = new Map();
  }

  async initialize() {
    console.log('[GEMINI_SKILLS] Initializing skills extension...');
    await this.loadSkills();
    console.log(\`[GEMINI_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[GEMINI_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const metadata = this.parseSkillMetadata(skillMdPath);
          this.skillMetadata.set(skillName, metadata);

          // Load skill implementation if available
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[GEMINI_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error('[GEMINI_SKILLS] Failed to load skills:', error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const jsFiles = fs.readdirSync(skillPath).filter(file => file.endsWith('.js'));

      for (const jsFile of jsFiles) {
        if (!jsFile.includes('test')) {
          const skillModulePath = path.join(skillPath, jsFile);
          try {
            delete require.cache[require.resolve(skillModulePath)];
            const skillModule = require(skillModulePath);
            return skillModule;
          } catch (moduleError) {
            console.warn(\`[GEMINI_SKILLS] Could not load module \${jsFile}: \${moduleError.message}\`);
          }
        }
      }
    } catch (error) {
      console.error(\`[GEMINI_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  parseSkillMetadata(skillMdPath) {
    try {
      const content = fs.readFileSync(skillMdPath, 'utf8');
      const metadata = {};

      for (const line of content.split('\\n')) {
        if (line.startsWith('## Description:')) {
          metadata.description = line.replace('## Description:', '').trim();
        } else if (line.startsWith('## Usage:')) {
          metadata.usage = line.replace('## Usage:', '').trim();
        } else if (line.startsWith('## Location:')) {
          metadata.location = line.replace('## Location:', '').trim();
        }
      }

      return metadata;
    } catch (error) {
      console.error(\`[GEMINI_SKILLS] Failed to parse metadata from \${skillMdPath}:\`, error);
      return {};
    }
  }

  async findRelevantSkills(prompt) {
    const relevant = new Map();
    const promptLower = prompt.toLowerCase();

    for (const [skillName, metadata] of this.skillMetadata) {
      if (this.isSkillRelevant(metadata, promptLower)) {
        relevant.set(skillName, metadata);
      }
    }
    return relevant;
  }

  isSkillRelevant(metadata, prompt) {
    const description = (metadata.description || '').toLowerCase();
    const usage = (metadata.usage || '').toLowerCase();
    const skillText = \`\${description} \${usage}\`;

    // Enhanced relevance checking
    const promptWords = prompt.split(' ').filter(word => word.length > 3);
    const skillWords = skillText.split(' ').filter(word => word.length > 3);

    return promptWords.some(promptWord =>
      skillWords.some(skillWord =>
        promptWord.includes(skillWord) || skillWord.includes(promptWord)
      )
    );
  }

  async executeSkill(skillName, input, session) {
    if (!this.loadedSkills.has(skillName)) {
      return \`[SKILL: \${skillName}] Skill not available\`;
    }

    try {
      const skill = this.loadedSkills.get(skillName);
      const metadata = this.skillMetadata.get(skillName);

      // Try different execution patterns
      if (typeof skill === 'function') {
        const result = await skill(input, { session, metadata });
        return result;
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          const result = await skill.execute(input, { session, metadata });
          return result;
        } else if (skill.main && typeof skill.main === 'function') {
          const result = await skill.main(input, { session, metadata });
          return result;
        }
      }

      return \`[SKILL: \${skillName}] Available but no execution function found\`;
    } catch (error) {
      console.error(\`[GEMINI_SKILLS] Error executing skill \${skillName}:\`, error);
      return \`[SKILL: \${skillName}] Error: \${error.message}\`;
    }
  }

  async handleCommand(input, session) {
    if (!this.shouldHandleSkillCommand(input)) {
      return null;
    }

    try {
      if (this.loadedSkills.size === 0) {
        await this.initialize();
      }

      const relevantSkills = await this.findRelevantSkills(input);
      const results = [];

      for (const [skillName, metadata] of relevantSkills) {
        const result = await this.executeSkill(skillName, input, session);
        if (result) {
          results.push(result);
        }
      }

      if (results.length === 0) {
        return {
          text: 'No relevant skills found for your request.',
          continue: true,
          suggestions: ['Try "skills list" to see available skills']
        };
      }

      return {
        text: results.join('\\n\\n'),
        continue: true,
        suggestions: this.generateSkillSuggestions(Array.from(relevantSkills.keys()))
      };
    } catch (error) {
      console.error('[GEMINI_SKILLS] Error handling skill command:', error);
      return {
        text: \`Error executing skills: \${error.message}\`,
        continue: true
      };
    }
  }

  shouldHandleSkillCommand(input) {
    // Handle skill-related commands
    const skillKeywords = ['create', 'design', 'build', 'generate', 'analyze', 'skill use'];
    const inputLower = input.toLowerCase();

    return skillKeywords.some(keyword => inputLower.includes(keyword)) ||
           inputLower.startsWith('skill') ||
           this.loadedSkills.size > 0; // If skills are loaded, try to handle any input
  }

  generateSkillSuggestions(skillNames) {
    return skillNames.map(name => \`Try skill: \${name}\`);
  }
}

// Gemini CLI integration
const extension = new GeminiSkillsExtension();

if (typeof module !== 'undefined' && module.exports) {
  module.exports = { GeminiSkillsExtension, extension };
}

if (typeof geminiCLI !== 'undefined') {
  extension.initialize();
  geminiCLI.addCommandHandler('skills', extension.handleCommand.bind(extension));
}
`;
  }

  generateQwenSkillsIntegration(projectPath, skillsDir) {
    return `// Qwen CLI Skills Integration Hook
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');

class QwenSkillsHook {
  constructor() {
    this.toolName = 'qwen';
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
  }

  async initialize() {
    console.log('[QWEN_SKILLS] Initializing skills hook...');
    await this.loadSkills();
    console.log(\`[QWEN_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[QWEN_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[QWEN_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error('[QWEN_SKILLS] Failed to load skills:', error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const files = fs.readdirSync(skillPath);
      const jsFiles = files.filter(file => file.endsWith('.js') && !file.includes('test'));

      for (const jsFile of jsFiles) {
        const skillModulePath = path.join(skillPath, jsFile);
        try {
          const skillModule = require(skillModulePath);
          return skillModule;
        } catch (moduleError) {
          console.warn(\`[QWEN_SKILLS] Could not load \${jsFile}: \${moduleError.message}\`);
        }
      }
    } catch (error) {
      console.error(\`[QWEN_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  async findRelevantSkills(prompt) {
    const relevant = new Map();
    const promptLower = prompt.toLowerCase();

    // Chinese keywords for better Qwen integration
    const chineseKeywords = ['创建', '设计', '生成', '分析', '处理', '构建', '制作'];

    for (const [skillName, skill] of this.loadedSkills) {
      const skillDesc = (skill.description || '').toLowerCase();

      if (this.isSkillRelevant(skillDesc, promptLower, chineseKeywords)) {
        relevant.set(skillName, skill);
      }
    }
    return relevant;
  }

  isSkillRelevant(skillDesc, prompt, chineseKeywords) {
    const promptWords = prompt.split(' ');
    const skillWords = skillDesc.split(' ');

    return promptWords.some(promptWord =>
      skillWords.some(skillWord =>
        promptWord.includes(skillWord) || skillWord.includes(promptWord) ||
        chineseKeywords.some(keyword =>
          prompt.includes(keyword) && skillDesc.includes(keyword)
        )
      )
    );
  }

  async executeSkill(skillName, prompt) {
    if (!this.loadedSkills.has(skillName)) {
      return \`[技能: \${skillName}] 未找到该技能\`;
    }

    try {
      const skill = this.loadedSkills.get(skillName);

      if (typeof skill === 'function') {
        const result = await skill(prompt);
        return result;
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          const result = await skill.execute(prompt);
          return result;
        }
      }

      return \`[技能: \${skillName}] 可用但无执行函数\`;
    } catch (error) {
      console.error(\`[QWEN_SKILLS] 执行技能 \${skillName} 出错:\`, error);
      return \`[技能: \${skillName}] 错误: \${error.message}\`;
    }
  }

  async onPrompt(prompt) {
    try {
      if (this.loadedSkills.size === 0) {
        await this.initialize();
      }

      const relevantSkills = await this.findRelevantSkills(prompt);
      const results = [];

      for (const [skillName, skill] of relevantSkills) {
        const result = await this.executeSkill(skillName, prompt);
        if (result) {
          results.push(result);
        }
      }

      if (results.length > 0) {
        return {
          handled: true,
          response: results.join('\\n\\n')
        };
      }

      return { handled: false };
    } catch (error) {
      console.error('[QWEN_SKILLS] Error processing prompt:', error);
      return {
        handled: true,
        response: \`技能处理错误: \${error.message}\`
      };
    }
  }
}

module.exports = QwenSkillsHook;
`;
  }

  generateCodeBuddySkillsIntegration(projectPath, skillsDir) {
    return `// CodeBuddy CLI Skills Integration
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');

class CodeBuddySkillsIntegration {
  constructor() {
    this.toolName = 'codebuddy';
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
  }

  async initialize() {
    console.log('[CODEBUDDY_SKILLS] Initializing skills integration...');
    await this.loadSkills();
    console.log(\`[CODEBUDDY_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[CODEBUDDY_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[CODEBUDDY_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error('[CODEBUDDY_SKILLS] Failed to load skills:', error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const files = fs.readdirSync(skillPath);
      const jsFiles = files.filter(file => file.endsWith('.js') && !file.includes('test'));

      for (const jsFile of jsFiles) {
        const skillModulePath = path.join(skillPath, jsFile);
        try {
          const skillModule = require(skillModulePath);
          return skillModule;
        } catch (moduleError) {
          console.warn(\`[CODEBUDDY_SKILLS] Could not load \${jsFile}: \${moduleError.message}\`);
        }
      }
    } catch (error) {
      console.error(\`[CODEBUDDY_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  async findRelevantSkills(prompt) {
    const relevant = new Map();
    const promptLower = prompt.toLowerCase();

    // CodeBuddy-specific keywords
    const codeKeywords = ['code', 'function', 'class', 'algorithm', 'debug', 'refactor', 'test'];

    for (const [skillName, skill] of this.loadedSkills) {
      if (this.isSkillRelevant(skill, promptLower, codeKeywords)) {
        relevant.set(skillName, skill);
      }
    }
    return relevant;
  }

  isSkillRelevant(skill, prompt, codeKeywords) {
    const description = (skill.description || '').toLowerCase();

    return codeKeywords.some(keyword =>
      prompt.includes(keyword) && description.includes(keyword)
    );
  }

  async executeSkill(skillName, prompt) {
    if (!this.loadedSkills.has(skillName)) {
      return \`[SKILL: \${skillName}] Skill not found\`;
    }

    try {
      const skill = this.loadedSkills.get(skillName);

      if (typeof skill === 'function') {
        const result = await skill(prompt);
        return result;
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          const result = await skill.execute(prompt);
          return result;
        }
      }

      return \`[SKILL: \${skillName}] Available but no execution function\`;
    } catch (error) {
      console.error(\`[CODEBUDDY_SKILLS] Error executing skill \${skillName}:\`, error);
      return \`[SKILL: \${skillName}] Error: \${error.message}\`;
    }
  }

  async onPrompt(prompt) {
    try {
      if (this.loadedSkills.size === 0) {
        await this.initialize();
      }

      const relevantSkills = await this.findRelevantSkills(prompt);
      const results = [];

      for (const [skillName, skill] of relevantSkills) {
        const result = await this.executeSkill(skillName, prompt);
        if (result) {
          results.push(result);
        }
      }

      if (results.length > 0) {
        return {
          handled: true,
          response: results.join('\\n\\n')
        };
      }

      return { handled: false };
    } catch (error) {
      console.error('[CODEBUDDY_SKILLS] Error processing prompt:', error);
      return {
        handled: true,
        response: \`Skill processing error: \${error.message}\`
      };
    }
  }
}

// CodeBuddy CLI integration
const skillsIntegration = new CodeBuddySkillsIntegration();

if (typeof codebuddy !== 'undefined' && codebuddy.addIntegration) {
  codebuddy.addIntegration('skills', skillsIntegration.onPrompt.bind(skillsIntegration));
}

module.exports = CodeBuddySkillsIntegration;
`;
  }

  generateCodexSkillsIntegration(projectPath, skillsDir) {
    return `// Codex CLI Skills Integration Handler
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');

class CodexSkillsHandler {
  constructor() {
    this.toolName = 'codex';
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
  }

  async initialize() {
    console.log('[CODEX_SKILLS] Initializing skills handler...');
    await this.loadSkills();
    console.log(\`[CODEX_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[CODEX_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[CODEX_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error('[CODEX_SKILLS] Failed to load skills:', error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const files = fs.readdirSync(skillPath);
      const jsFiles = files.filter(file => file.endsWith('.js') && !file.includes('test'));

      for (const jsFile of jsFiles) {
        const skillModulePath = path.join(skillPath, jsFile);
        try {
          const skillModule = require(skillModulePath);
          return skillModule;
        } catch (moduleError) {
          console.warn(\`[CODEX_SKILLS] Could not load \${jsFile}: \${moduleError.message}\`);
        }
      }
    } catch (error) {
      console.error(\`[CODEX_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  async handleSkillRequest(input) {
    try {
      if (this.loadedSkills.size === 0) {
        await this.initialize();
      }

      // Find relevant skills for the input
      const relevantSkill = await this.findMostRelevantSkill(input);

      if (relevantSkill) {
        const result = await this.executeSkill(relevantSkill, input);
        return {
          success: true,
          result: result,
          skillName: relevantSkill
        };
      }

      return {
        success: false,
        message: 'No relevant skills found for the request'
      };
    } catch (error) {
      console.error('[CODEX_SKILLS] Error handling skill request:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async findMostRelevantSkill(prompt) {
    const promptLower = prompt.toLowerCase();
    let bestMatch = null;
    let bestScore = 0;

    for (const [skillName, skill] of this.loadedSkills) {
      const score = this.calculateRelevanceScore(skill, promptLower);
      if (score > bestScore) {
        bestScore = score;
        bestMatch = skillName;
      }
    }

    return bestScore > 0.3 ? bestMatch : null;
  }

  calculateRelevanceScore(skill, prompt) {
    const description = (skill.description || '').toLowerCase();
    const keywords = ['code', 'function', 'api', 'data', 'process', 'generate'];

    let score = 0;
    for (const keyword of keywords) {
      if (prompt.includes(keyword) && description.includes(keyword)) {
        score += 0.2;
      }
    }

    return Math.min(score, 1.0);
  }

  async executeSkill(skillName, input) {
    if (!this.loadedSkills.has(skillName)) {
      return \`[SKILL: \${skillName}] Skill not found\`;
    }

    try {
      const skill = this.loadedSkills.get(skillName);

      if (typeof skill === 'function') {
        const result = await skill(input);
        return result;
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          const result = await skill.execute(input);
          return result;
        }
      }

      return \`[SKILL: \${skillName}] Available but no execution function\`;
    } catch (error) {
      console.error(\`[CODEX_SKILLS] Error executing skill \${skillName}:\`, error);
      return \`[SKILL: \${skillName}] Error: \${error.message}\`;
    }
  }
}

// Codex CLI integration
const skillsHandler = new CodexSkillsHandler();

module.exports = CodexSkillsHandler;
`;
  }

  generateQoderCliSkillsIntegration(projectPath, skillsDir) {
    return `// QoderCLI Skills Integration Extension
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');

class QoderCliSkillsExtension {
  constructor() {
    this.toolName = 'qodercli';
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
  }

  async initialize() {
    console.log('[QODERCLI_SKILLS] Initializing skills extension...');
    await this.loadSkills();
    console.log(\`[QODERCLI_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[QODERCLI_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[QODERCLI_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error('[QODERCLI_SKILLS] Failed to load skills:', error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const files = fs.readdirSync(skillPath);
      const jsFiles = files.filter(file => file.endsWith('.js') && !file.includes('test'));

      for (const jsFile of jsFiles) {
        const skillModulePath = path.join(skillPath, jsFile);
        try {
          const skillModule = require(skillModulePath);
          return skillModule;
        } catch (moduleError) {
          console.warn(\`[QODERCLI_SKILLS] Could not load \${jsFile}: \${moduleError.message}\`);
        }
      }
    } catch (error) {
      console.error(\`[QODERCLI_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  async handleSkillCommand(command, args) {
    try {
      if (this.loadedSkills.size === 0) {
        await this.initialize();
      }

      if (command === 'list') {
        return this.listSkills();
      }

      if (command === 'use' && args.length > 0) {
        return this.useSkill(args[0], args.slice(1));
      }

      return {
        success: false,
        message: 'Usage: skill list | skill use <skill-name> [args...]'
      };
    } catch (error) {
      console.error('[QODERCLI_SKILLS] Error handling skill command:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async listSkills() {
    const skillList = Array.from(this.loadedSkills.keys()).map(name => {
      const skill = this.loadedSkills.get(name);
      return {
        name,
        description: skill.description || 'No description available'
      };
    });

    return {
      success: true,
      skills: skillList,
      message: \`Found \${skillList.length} available skills\`
    };
  }

  async useSkill(skillName, args) {
    if (!this.loadedSkills.has(skillName)) {
      return {
        success: false,
        message: \`Skill '\${skillName}' not found\`
      };
    }

    try {
      const skill = this.loadedSkills.get(skillName);
      const input = args.join(' ');

      let result;
      if (typeof skill === 'function') {
        result = await skill(input);
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          result = await skill.execute(input);
        } else if (skill.main && typeof skill.main === 'function') {
          result = await skill.main(input);
        }
      }

      return {
        success: true,
        result: result || \`Skill '\${skillName}' executed\`,
        skillName
      };
    } catch (error) {
      console.error(\`[QODERCLI_SKILLS] Error using skill \${skillName}:\`, error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

// QoderCLI integration
const skillsExtension = new QoderCliSkillsExtension();

if (typeof qodercli !== 'undefined' && qodercli.addExtension) {
  qodercli.addExtension('skills', skillsExtension.handleSkillCommand.bind(skillsExtension));
}

module.exports = QoderCliSkillsExtension;
`;
  }

  generateGenericSkillsIntegration(cliName, projectPath, skillsDir) {
    const className = `${cliName.charAt(0).toUpperCase() + cliName.slice(1)}SkillsHook`;

    return `// ${className}
// Auto-generated by Stigmergy CLI v1.2.1
// Project: ${projectPath}
// Skills Directory: ${skillsDir}

const fs = require('fs');
const path = require('path');

class ${className} {
  constructor() {
    this.toolName = '${cliName}';
    this.skillsDir = path.join('${skillsDir.replace(/\\/g, '\\\\')}');
    this.loadedSkills = new Map();
  }

  async initialize() {
    console.log(\`[\${this.toolName.toUpperCase()}_SKILLS] Initializing skills hook...\`);
    await this.loadSkills();
    console.log(\`[\${this.toolName.toUpperCase()}_SKILLS] Loaded \${this.loadedSkills.size} skills\`);
  }

  async loadSkills() {
    try {
      if (!fs.existsSync(this.skillsDir)) {
        console.log(\`[\${this.toolName.toUpperCase()}_SKILLS] Skills directory not found: \${this.skillsDir}\`);
        return;
      }

      const skillDirs = fs.readdirSync(this.skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);

      for (const skillName of skillDirs) {
        const skillPath = path.join(this.skillsDir, skillName);
        const skillMdPath = path.join(skillPath, 'SKILL.md');

        if (fs.existsSync(skillMdPath)) {
          const skill = await this.loadSkill(skillPath);
          if (skill) {
            this.loadedSkills.set(skillName, skill);
            console.log(\`[\${this.toolName.toUpperCase()}_SKILLS] Loaded skill: \${skillName}\`);
          }
        }
      }
    } catch (error) {
      console.error(\`[\${this.toolName.toUpperCase()}_SKILLS] Failed to load skills:\`, error);
    }
  }

  async loadSkill(skillPath) {
    try {
      const files = fs.readdirSync(skillPath);
      const jsFiles = files.filter(file => file.endsWith('.js') && !file.includes('test'));

      for (const jsFile of jsFiles) {
        const skillModulePath = path.join(skillPath, jsFile);
        try {
          const skillModule = require(skillModulePath);
          return skillModule;
        } catch (moduleError) {
          console.warn(\`[\${this.toolName.toUpperCase()}_SKILLS] Could not load \${jsFile}: \${moduleError.message}\`);
        }
      }
    } catch (error) {
      console.error(\`[\${this.toolName.toUpperCase()}_SKILLS] Failed to load skill from \${skillPath}:\`, error);
    }
    return null;
  }

  async executeSkill(skillName, prompt) {
    if (!this.loadedSkills.has(skillName)) {
      return \`[SKILL: \${skillName}] Skill not found\`;
    }

    try {
      const skill = this.loadedSkills.get(skillName);

      if (typeof skill === 'function') {
        const result = await skill(prompt);
        return result;
      } else if (skill && typeof skill === 'object') {
        if (skill.execute && typeof skill.execute === 'function') {
          const result = await skill.execute(prompt);
          return result;
        }
      }

      return \`[SKILL: \${skillName}] Available but no execution function\`;
    } catch (error) {
      console.error(\`[\${this.toolName.toUpperCase()}_SKILLS] Error executing skill \${skillName}:\`, error);
      return \`[SKILL: \${skillName}] Error: \${error.message}\`;
    }
  }
}

module.exports = ${className};
`;
  }
}

module.exports = SkillsIntegrationGenerator;