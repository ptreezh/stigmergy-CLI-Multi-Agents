// src/core/coordination/nodejs/CLIIntegrationManager.js
const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn, spawnSync } = require('child_process');

class CLIIntegrationManager {
  constructor() {
    this.supportedCLIs = {
      claude: {
        name: 'Claude CLI',
        executable: 'claude',
        hooks: [
          'user_prompt_submit',
          'tool_use_pre',
          'tool_use_post',
          'response_generated',
        ],
      },
      gemini: {
        name: 'Gemini CLI',
        executable: 'gemini',
        extensions: [
          'on_user_input',
          'on_response_generated',
          'on_tool_execution',
        ],
      },
      qwencode: {
        name: 'QwenCode CLI',
        executable: 'qwencode',
        inheritance: [
          'on_code_generation',
          'on_analysis_request',
          'on_refactor_request',
        ],
      },
      iflow: {
        name: 'iFlow CLI',
        executable: 'iflow',
        workflows: [
          'on_workflow_start',
          'on_stage_complete',
          'on_workflow_success',
        ],
      },
      qoder: {
        name: 'Qoder CLI',
        executable: 'qoder',
        notifications: [
          'on_user_notification',
          'on_system_alert',
          'on_task_completion',
        ],
      },
      codebuddy: {
        name: 'CodeBuddy CLI',
        executable: 'codebuddy',
        skills: [
          'on_skill_invocation',
          'on_buddy_request',
          'on_cross_cli_task',
        ],
      },
      codex: {
        name: 'Codex CLI',
        executable: 'codex',
        slashCommands: ['/x', '/cross-cli', '/delegate'],
      },
      copilot: {
        name: 'Copilot CLI',
        executable: 'copilot',
        mcp: ['cross_cli_execute'],
      },
      opencode: {
        name: 'OpenCode AI CLI',
        executable: 'opencode',
        skills: [
          'on_skill_invocation',
          'on_code_generation',
          'on_cross_cli_task',
        ],
      },
      'oh-my-opencode': {
        name: 'Oh-My-OpenCode Plugin Manager',
        executable: 'oh-my-opencode',
        plugins: [
          'on_plugin_install',
          'on_plugin_load',
          'on_cross_cli_integration',
        ],
      },
    };
  }

  async checkCLIAvailability(cliName) {
    console.log(`[CLI_INTEGRATION] Checking availability of ${cliName}...`);

    const cliInfo = this.supportedCLIs[cliName.toLowerCase()];
    if (!cliInfo) {
      return { available: false, error: `Unsupported CLI: ${cliName}` };
    }

    try {
      // Check if CLI executable is available
      const result = spawnSync(cliInfo.executable, ['--version'], {
        timeout: 5000,
        stdio: ['pipe', 'pipe', 'pipe'],
      });

      if (result.status === 0) {
        const version = result.stdout
          ? result.stdout.toString().trim()
          : 'Unknown';
        return {
          available: true,
          version: version,
          name: cliInfo.name,
        };
      } else {
        return {
          available: false,
          error: `CLI returned non-zero exit code: ${result.status}`,
          stderr: result.stderr ? result.stderr.toString() : '',
        };
      }
    } catch (error) {
      return {
        available: false,
        error: `Failed to execute CLI: ${error.message}`,
      };
    }
  }

  async listAvailableCLIs() {
    console.log('[CLI_INTEGRATION] Listing available CLIs...');

    const results = {};
    for (const [cliName, cliInfo] of Object.entries(this.supportedCLIs)) {
      results[cliName] = await this.checkCLIAvailability(cliName);
    }

    return results;
  }

  async getNodeJsIntegrationScript(cliName) {
    console.log(
      `[CLI_INTEGRATION] Generating Node.js integration script for ${cliName}...`,
    );

    const cliInfo = this.supportedCLIs[cliName.toLowerCase()];
    if (!cliInfo) {
      throw new Error(`Unsupported CLI: ${cliName}`);
    }

    // Generate a Node.js integration script
    const script = `#!/usr/bin/env node

/**
 * Node.js Integration Script for ${cliInfo.name}
 * Auto-generated by Stigmergy CLI Integration Manager
 */

const { spawn } = require('child_process');

class ${this.capitalize(cliName)}NodeJsIntegration {
  constructor() {
    this.cliName = '${cliName}';
    this.executable = '${cliInfo.executable}';
  }

  async executeCommand(command, args = [], options = {}) {
    return new Promise((resolve, reject) => {
      const cliProcess = spawn(this.executable, [command, ...args], {
        timeout: options.timeout || 30000,
        ...options
      });

      let stdout = '';
      let stderr = '';

      cliProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      cliProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      cliProcess.on('close', (code) => {
        if (code === 0) {
          resolve(stdout.trim());
        } else {
          reject(new Error(\`CLI process exited with code \${code}: \${stderr}\`));
        }
      });

      cliProcess.on('error', (error) => {
        reject(new Error(\`Failed to start CLI process: \${error.message}\`));
      });
    });
  }

  async getVersion() {
    try {
      const version = await this.executeCommand('--version');
      return version;
    } catch (error) {
      throw new Error(\`Failed to get ${cliName} version: \${error.message}\`);
    }
  }

  async executeTask(task, context = {}) {
    // This would depend on the specific CLI's interface
    // For demonstration, we'll simulate execution
    return \`[NODE.JS INTEGRATION] Simulated execution of task: \${task}\`;
  }

  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

module.exports = ${this.capitalize(cliName)}NodeJsIntegration;

// If run directly, test the integration
if (require.main === module) {
  const integration = new ${this.capitalize(cliName)}NodeJsIntegration();
  
  integration.getVersion()
    .then(version => {
      console.log('${cliInfo.name} version:', version);
    })
    .catch(error => {
      console.error('Failed to get version:', error.message);
    });
}
`;

    return script;
  }

  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  async deployNodeJsIntegration(cliName, targetDir) {
    console.log(
      `[CLI_INTEGRATION] Deploying Node.js integration for ${cliName}...`,
    );

    if (!fs.existsSync(targetDir)) {
      fs.mkdirSync(targetDir, { recursive: true });
    }

    const script = await this.getNodeJsIntegrationScript(cliName);
    const scriptPath = path.join(targetDir, `${cliName}_nodejs_integration.js`);

    fs.writeFileSync(scriptPath, script);

    // Make executable
    try {
      fs.chmodSync(scriptPath, 0o755);
    } catch (error) {
      console.warn(
        '[CLI_INTEGRATION] Failed to make script executable:',
        error.message,
      );
    }

    return scriptPath;
  }

  async getSupportedFeatures(cliName) {
    const cliInfo = this.supportedCLIs[cliName.toLowerCase()];
    if (!cliInfo) {
      return null;
    }

    return {
      name: cliInfo.name,
      executable: cliInfo.executable,
      features: Object.keys(cliInfo).filter(
        (key) => key !== 'name' && key !== 'executable',
      ),
    };
  }
}

module.exports = CLIIntegrationManager;
