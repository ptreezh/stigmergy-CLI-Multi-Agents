#!/usr/bin/env node
/**
 * OpenCode Integration Installer
 * ä¸º OpenCode CLI å®‰è£… Stigmergy é›†æˆ
 */

const fs = require('fs');
const path = require('path');
const os = require('os');

class OpenCodeIntegrationInstaller {
  constructor() {
    this.homeDir = os.homedir();
    this.opencodeConfigPath = path.join(this.homeDir, '.opencode');
    this.hooksDir = path.join(this.opencodeConfigPath, 'hooks');
    this.skillsDir = path.join(this.opencodeConfigPath, 'skills');
  }

  /**
   * å®‰è£… OpenCode é›†æˆ
   */
  async install() {
    console.log('ðŸ”§ å¼€å§‹å®‰è£… OpenCode é›†æˆ...\n');

    try {
      // 1. åˆ›å»ºå¿…è¦çš„ç›®å½•
      this.createDirectories();

      // 2. éƒ¨ç½² hooks
      this.deployHooks();

      // 3. éƒ¨ç½² skills
      this.deploySkills();

      // 4. æ›´æ–°é…ç½®
      this.updateConfig();

      console.log('\nâœ… OpenCode é›†æˆå®‰è£…å®Œæˆï¼');
      console.log('ðŸ“ é…ç½®ç›®å½•: ' + this.opencodeConfigPath);
      console.log('ðŸ’¡ çŽ°åœ¨å¯ä»¥åœ¨ OpenCode ä¸­ä½¿ç”¨ /resumesession å‘½ä»¤');

      return { success: true };
    } catch (error) {
      console.error('\nâŒ å®‰è£…å¤±è´¥:', error.message);
      return { success: false, error: error.message };
    }
  }

  /**
   * åˆ›å»ºå¿…è¦çš„ç›®å½•
   */
  createDirectories() {
    console.log('ðŸ“ åˆ›å»ºç›®å½•ç»“æž„...');

    const directories = [
      this.opencodeConfigPath,
      this.hooksDir,
      this.skillsDir
    ];

    for (const dir of directories) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log('  âœ… åˆ›å»º: ' + dir);
      } else {
        console.log('  â„¹ï¸  å·²å­˜åœ¨: ' + dir);
      }
    }
  }

  /**
   * éƒ¨ç½² hooks
   */
  deployHooks() {
    console.log('\nðŸ”— éƒ¨ç½² hooks...');

    const hookContent = `#!/usr/bin/env node
/**
 * OpenCode AI CLI Integration Hook
 * Generated by Stigmergy CLI v${require('../../../package.json').version}
 */

const fs = require('fs');
const path = require('path');

class OpencodeHook {
  constructor() {
    this.toolName = 'opencode';
    this.configPath = path.join(os.homedir(), '.opencode', 'config.json');
    this.hooksDir = path.join(os.homedir(), '.opencode', 'hooks');
  }

  async onPrompt(prompt) {
    // Handle incoming prompts from other CLI tools
    console.log('[' + this.toolName.toUpperCase() + '] Received cross-CLI prompt: ' + prompt);
    return { handled: true, response: 'Prompt processed by ' + this.toolName };
  }

  async onResponse(response) {
    // Handle responses to be sent to other CLI tools
    console.log('[' + this.toolName.toUpperCase() + '] Sending cross-CLI response');
    return response;
  }
}

module.exports = OpencodeHook;
`;

    const hookFilePath = path.join(this.hooksDir, 'opencode_hook.js');

    if (!fs.existsSync(hookFilePath)) {
      fs.writeFileSync(hookFilePath, hookContent, 'utf8');
      console.log('  âœ… åˆ›å»º: opencode_hook.js');
    } else {
      console.log('  â„¹ï¸  å·²å­˜åœ¨: opencode_hook.js');
    }
  }

  /**
   * éƒ¨ç½² skills
   */
  deploySkills() {
    console.log('\nâš¡ éƒ¨ç½² skills...');

    // å¤åˆ¶ resumesession æŠ€èƒ½
    const sourceSkillPath = path.join(__dirname, '../../../skills/resumesession/opencode-resume.js');
    const targetSkillPath = path.join(this.skillsDir, 'resumesession.js');

    if (fs.existsSync(sourceSkillPath)) {
      const skillContent = fs.readFileSync(sourceSkillPath, 'utf8');
      fs.writeFileSync(targetSkillPath, skillContent, 'utf8');
      console.log('  âœ… éƒ¨ç½²: resumesession.js');
    } else {
      console.log('  âš ï¸  æœªæ‰¾åˆ°: opencode-resume.js');
    }
  }

  /**
   * æ›´æ–°é…ç½®
   */
  updateConfig() {
    console.log('\nâš™ï¸  æ›´æ–°é…ç½®...');

    const configPath = path.join(this.opencodeConfigPath, 'config.json');
    const hooksJsonPath = path.join(this.opencodeConfigPath, 'hooks.json');

    // æ›´æ–° hooks.json
    const hooksConfig = {
      "cross_cli_adapter": {
        "enabled": true,
        "supported_tools": [
          "claude",
          "gemini",
          "qwen",
          "iflow",
          "qodercli",
          "codebuddy",
          "copilot",
          "codex"
        ],
        "trigger_patterns": [
          "use\\s+(\\w+)\\s+to\\s+(.+)$",
          "call\\s+(\\w+)\\s+(.+)$",
          "ask\\s+(\\w+)\\s+(.+)$",
          "stigmergy\\s+(\\w+)\\s+(.+)$"
        ]
      }
    };

    fs.writeFileSync(hooksJsonPath, JSON.stringify(hooksConfig, null, 2), 'utf8');
    console.log('  âœ… æ›´æ–°: hooks.json');

    // æ›´æ–° config.json
    let config = {};
    if (fs.existsSync(configPath)) {
      try {
        config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      } catch (error) {
        console.log('  âš ï¸  æ— æ³•è¯»å–çŽ°æœ‰é…ç½®ï¼Œå°†åˆ›å»ºæ–°é…ç½®');
      }
    }

    // æ·»åŠ  Stigmergy é…ç½®
    config.stigmergy = {
      "enabled": true,
      "version": require('../../../package.json').version,
      "skills": ["resumesession"]
    };

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');
    console.log('  âœ… æ›´æ–°: config.json');
  }

  /**
   * å¸è½½ OpenCode é›†æˆ
   */
  async uninstall() {
    console.log('ðŸ—‘ï¸  å¼€å§‹å¸è½½ OpenCode é›†æˆ...\n');

    try {
      // åˆ é™¤æŠ€èƒ½æ–‡ä»¶
      const skillPath = path.join(this.skillsDir, 'resumesession.js');
      if (fs.existsSync(skillPath)) {
        fs.unlinkSync(skillPath);
        console.log('  âœ… åˆ é™¤: resumesession.js');
      }

      console.log('\nâœ… OpenCode é›†æˆå¸è½½å®Œæˆï¼');
      return { success: true };
    } catch (error) {
      console.error('\nâŒ å¸è½½å¤±è´¥:', error.message);
      return { success: false, error: error.message };
    }
  }
}

// å¦‚æžœç›´æŽ¥è¿è¡Œæ­¤è„šæœ¬
if (require.main === module) {
  const installer = new OpenCodeIntegrationInstaller();
  const args = process.argv.slice(2);

  if (args.includes('--uninstall')) {
    installer.uninstall().then(result => {
      process.exit(result.success ? 0 : 1);
    });
  } else {
    installer.install().then(result => {
      process.exit(result.success ? 0 : 1);
    });
  }
}

module.exports = OpenCodeIntegrationInstaller;