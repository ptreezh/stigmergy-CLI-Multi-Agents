# å¹³å°å®¡æ ¸å‘å¸ƒæœºåˆ¶è®¾è®¡

## ğŸ¯ æœºåˆ¶æ¦‚è¿°
ç¡®ä¿æŠ€èƒ½è´¨é‡ã€å®‰å…¨æ€§å’Œå¯ç”¨æ€§çš„å®Œæ•´å®¡æ ¸å‘å¸ƒæµç¨‹ï¼Œä»ç”¨æˆ·æäº¤åˆ°æœ€ç»ˆä¸Šçº¿ã€‚

## ğŸ”„ å®¡æ ¸æµç¨‹æ¶æ„

### å®¡æ ¸é˜¶æ®µåˆ’åˆ†
```
ç”¨æˆ·æäº¤ â†’ è‡ªåŠ¨æ£€æµ‹ â†’ äººå·¥å®¡æ ¸ â†’ æµ‹è¯•éªŒè¯ â†’ å‘å¸ƒå†³ç­– â†’ ä¸Šçº¿ç›‘æ§
```

### å®¡æ ¸å†³ç­–æ ‘
```mermaid
graph TD
    A[æŠ€èƒ½æäº¤] --> B[è‡ªåŠ¨æ£€æµ‹]
    B --> C{é€šè¿‡è‡ªåŠ¨æ£€æµ‹?}
    C -->|æ˜¯| D[è¿›å…¥äººå·¥å®¡æ ¸é˜Ÿåˆ—]
    C -->|å¦| E[æ‹’ç»å¹¶åé¦ˆ]
    
    D --> F[äººå·¥åˆå®¡]
    F --> G{åˆå®¡é€šè¿‡?}
    G -->|æ˜¯| H[æ·±åº¦æµ‹è¯•]
    G -->|å¦| I[åé¦ˆä¿®æ”¹å»ºè®®]
    
    H --> J{æµ‹è¯•é€šè¿‡?}
    J -->|æ˜¯| K[ç»ˆå®¡å†³ç­–]
    J -->|å¦| L[è¯¦ç»†åé¦ˆé—®é¢˜]
    
    K --> M{æ‰¹å‡†å‘å¸ƒ?}
    M -->|æ˜¯| N[å‘å¸ƒä¸Šçº¿]
    M -->|å¦| O[æ‹’ç»å¹¶è¯´æ˜åŸå› ]
    
    I --> P[ç”¨æˆ·ä¿®æ”¹]
    L --> P
    P --> A
```

## ğŸ” è‡ªåŠ¨æ£€æµ‹ç³»ç»Ÿ

### 1. ä»£ç è´¨é‡æ£€æµ‹
```javascript
class CodeQualityChecker {
  constructor() {
    this.linters = {
      javascript: new ESLintChecker(),
      python: new PylintChecker(),
      typescript: new TSLintChecker()
    };
    this.analyzers = {
      complexity: new ComplexityAnalyzer(),
      maintainability: new MaintainabilityAnalyzer(),
      duplication: new DuplicationAnalyzer()
    };
  }
  
  async checkCodeQuality(skillCode, language) {
    const results = {
      overall: 0,
      details: {},
      issues: [],
      suggestions: []
    };
    
    try {
      // 1. ä»£ç è§„èŒƒæ£€æŸ¥
      const linter = this.linters[language];
      if (linter) {
        const lintResult = await linter.check(skillCode);
        results.details.linting = lintResult;
        results.issues.push(...lintResult.errors);
        results.suggestions.push(...lintResult.warnings);
      }
      
      // 2. å¤æ‚åº¦åˆ†æ
      const complexityResult = await this.analyzers.complexity.analyze(skillCode);
      results.details.complexity = complexityResult;
      
      if (complexityResult.score < 0.7) {
        results.issues.push({
          type: 'complexity',
          message: 'ä»£ç å¤æ‚åº¦è¿‡é«˜ï¼Œå»ºè®®é‡æ„',
          details: complexityResult
        });
      }
      
      // 3. å¯ç»´æŠ¤æ€§åˆ†æ
      const maintainabilityResult = await this.analyzers.maintainability.analyze(skillCode);
      results.details.maintainability = maintainabilityResult;
      
      // 4. é‡å¤ä»£ç æ£€æµ‹
      const duplicationResult = await this.analyzers.duplication.analyze(skillCode);
      results.details.duplication = duplicationResult;
      
      if (duplicationResult.ratio > 0.3) {
        results.suggestions.push({
          type: 'duplication',
          message: 'å­˜åœ¨é‡å¤ä»£ç ï¼Œå»ºè®®æå–å…¬å…±å‡½æ•°',
          details: duplicationResult
        });
      }
      
      // è®¡ç®—æ€»ä½“è¯„åˆ†
      results.overall = this.calculateOverallScore(results);
      
      return results;
      
    } catch (error) {
      console.error('ä»£ç è´¨é‡æ£€æµ‹å¤±è´¥:', error);
      throw new Error('ä»£ç è´¨é‡æ£€æµ‹è¿‡ç¨‹å‡ºé”™');
    }
  }
  
  calculateOverallScore(results) {
    const weights = {
      linting: 0.3,
      complexity: 0.3,
      maintainability: 0.2,
      duplication: 0.2
    };
    
    let totalScore = 0;
    let totalWeight = 0;
    
    for (const [category, weight] of Object.entries(weights)) {
      if (results.details[category]) {
        const score = results.details[category].score || 0;
        totalScore += score * weight;
        totalWeight += weight;
      }
    }
    
    return totalWeight > 0 ? totalScore / totalWeight : 0;
  }
}
```

### 2. å®‰å…¨æ‰«æç³»ç»Ÿ
```javascript
class SecurityScanner {
  constructor() {
    this.vulnerabilityScanner = new VulnerabilityScanner();
    this.dependencyChecker = new DependencyChecker();
    this.codeAnalyzer = new SecurityCodeAnalyzer();
  }
  
  async scanSecurity(skillCode, dependencies = []) {
    const scanResult = {
      overall: 0,
      criticalIssues: [],
      warnings: [],
      recommendations: [],
      details: {}
    };
    
    try {
      // 1. ä»£ç å®‰å…¨åˆ†æ
      const codeAnalysis = await this.codeAnalyzer.analyze(skillCode);
      scanResult.details.codeAnalysis = codeAnalysis;
      
      // æ£€æŸ¥å¸¸è§å®‰å…¨é—®é¢˜
      const securityIssues = this.detectSecurityIssues(skillCode);
      scanResult.criticalIssues.push(...securityIssues.critical);
      scanResult.warnings.push(...securityIssues.warnings);
      
      // 2. ä¾èµ–æ¼æ´æ‰«æ
      if (dependencies.length > 0) {
        const dependencyScan = await this.dependencyChecker.check(dependencies);
        scanResult.details.dependencies = dependencyScan;
        
        if (dependencyScan.vulnerabilities.length > 0) {
          scanResult.criticalIssues.push(...dependencyScan.vulnerabilities.filter(v => v.severity === 'high'));
          scanResult.warnings.push(...dependencyScan.vulnerabilities.filter(v => v.severity === 'medium'));
        }
      }
      
      // 3. æ¶æ„ä»£ç æ£€æµ‹
      const malwareScan = await this.vulnerabilityScanner.scanForMalware(skillCode);
      scanResult.details.malwareScan = malwareScan;
      
      if (malwareScan.suspicious) {
        scanResult.criticalIssues.push({
          type: 'malware',
          message: 'æ£€æµ‹åˆ°å¯ç–‘ä»£ç æ¨¡å¼',
          details: malwareScan
        });
      }
      
      // è®¡ç®—å®‰å…¨è¯„åˆ†
      scanResult.overall = this.calculateSecurityScore(scanResult);
      
      return scanResult;
      
    } catch (error) {
      console.error('å®‰å…¨æ‰«æå¤±è´¥:', error);
      throw new Error('å®‰å…¨æ‰«æè¿‡ç¨‹å‡ºé”™');
    }
  }
  
  detectSecurityIssues(code) {
    const issues = {
      critical: [],
      warnings: []
    };
    
    // å±é™©å‡½æ•°æ£€æµ‹
    const dangerousFunctions = [
      'eval', 'Function', 'setTimeout', 'setInterval',
      'require', 'import', 'exec', 'spawn'
    ];
    
    dangerousFunctions.forEach(func => {
      const regex = new RegExp(`\\b${func}\\s*\\(`, 'g');
      if (regex.test(code)) {
        issues.warnings.push({
          type: 'dangerous_function',
          message: `ä½¿ç”¨äº†å±é™©å‡½æ•°: ${func}`,
          suggestion: 'è¯·è€ƒè™‘ä½¿ç”¨æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ'
        });
      }
    });
    
    // ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯æ£€æµ‹
    const sensitivePatterns = [
      /password\s*=\s*['"][^'"]+['"]/gi,
      /api[_ -]?key\s*=\s*['"][^'"]+['"]/gi,
      /secret\s*=\s*['"][^'"]+['"]/gi
    ];
    
    sensitivePatterns.forEach(pattern => {
      if (pattern.test(code)) {
        issues.critical.push({
          type: 'hardcoded_secrets',
          message: 'æ£€æµ‹åˆ°ç¡¬ç¼–ç çš„æ•æ„Ÿä¿¡æ¯',
          suggestion: 'è¯·ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶å­˜å‚¨æ•æ„Ÿä¿¡æ¯'
        });
      }
    });
    
    return issues;
  }
  
  calculateSecurityScore(scanResult) {
    const criticalPenalty = scanResult.criticalIssues.length * 20;
    const warningPenalty = scanResult.warnings.length * 5;
    
    return Math.max(0, 100 - criticalPenalty - warningPenalty);
  }
}
```

### 3. æ€§èƒ½è¯„ä¼°ç³»ç»Ÿ
```javascript
class PerformanceEvaluator {
  constructor() {
    this.benchmarkRunner = new BenchmarkRunner();
    this.resourceMonitor = new ResourceMonitor();
    this.scalabilityTester = new ScalabilityTester();
  }
  
  async evaluatePerformance(skillCode, testCases) {
    const evaluation = {
      overall: 0,
      metrics: {},
      benchmarks: {},
      issues: [],
      recommendations: []
    };
    
    try {
      // 1. åŸºå‡†æ€§èƒ½æµ‹è¯•
      const benchmarks = await this.benchmarkRunner.run(skillCode, testCases);
      evaluation.benchmarks = benchmarks;
      
      // 2. èµ„æºä½¿ç”¨ç›‘æ§
      const resourceUsage = await this.resourceMonitor.monitor(skillCode, testCases);
      evaluation.metrics.resourceUsage = resourceUsage;
      
      // 3. å¯æ‰©å±•æ€§æµ‹è¯•
      const scalability = await this.scalabilityTester.test(skillCode);
      evaluation.metrics.scalability = scalability;
      
      // 4. æ€§èƒ½é—®é¢˜æ£€æµ‹
      const performanceIssues = this.detectPerformanceIssues(benchmarks, resourceUsage);
      evaluation.issues.push(...performanceIssues);
      
      // 5. ç”Ÿæˆä¼˜åŒ–å»ºè®®
      const recommendations = this.generateOptimizationRecommendations(evaluation);
      evaluation.recommendations.push(...recommendations);
      
      // è®¡ç®—æ€»ä½“è¯„åˆ†
      evaluation.overall = this.calculatePerformanceScore(evaluation);
      
      return evaluation;
      
    } catch (error) {
      console.error('æ€§èƒ½è¯„ä¼°å¤±è´¥:', error);
      throw new Error('æ€§èƒ½è¯„ä¼°è¿‡ç¨‹å‡ºé”™');
    }
  }
  
  detectPerformanceIssues(benchmarks, resourceUsage) {
    const issues = [];
    
    // æ£€æŸ¥æ‰§è¡Œæ—¶é—´
    if (benchmarks.averageExecutionTime > 5000) {
      issues.push({
        type: 'slow_execution',
        message: 'å¹³å‡æ‰§è¡Œæ—¶é—´è¿‡é•¿',
        details: `å¹³å‡æ‰§è¡Œæ—¶é—´: ${benchmarks.averageExecutionTime}ms`,
        suggestion: 'è€ƒè™‘ä¼˜åŒ–ç®—æ³•æˆ–ä½¿ç”¨ç¼“å­˜'
      });
    }
    
    // æ£€æŸ¥å†…å­˜ä½¿ç”¨
    if (resourceUsage.peakMemoryUsage > 100) {
      issues.push({
        type: 'high_memory_usage',
        message: 'å†…å­˜ä½¿ç”¨é‡è¿‡é«˜',
        details: `å³°å€¼å†…å­˜ä½¿ç”¨: ${resourceUsage.peakMemoryUsage}MB`,
        suggestion: 'ä¼˜åŒ–å†…å­˜ç®¡ç†ï¼Œé¿å…å†…å­˜æ³„æ¼'
      });
    }
    
    // æ£€æŸ¥CPUä½¿ç”¨ç‡
    if (resourceUsage.peakCpuUsage > 80) {
      issues.push({
        type: 'high_cpu_usage',
        message: 'CPUä½¿ç”¨ç‡è¿‡é«˜',
        details: `å³°å€¼CPUä½¿ç”¨ç‡: ${resourceUsage.peakCpuUsage}%`,
        suggestion: 'ä¼˜åŒ–è®¡ç®—å¯†é›†å‹æ“ä½œ'
      });
    }
    
    return issues;
  }
  
  calculatePerformanceScore(evaluation) {
    const weights = {
      executionTime: 0.4,
      memoryUsage: 0.3,
      cpuUsage: 0.2,
      scalability: 0.1
    };
    
    let totalScore = 0;
    
    // æ‰§è¡Œæ—¶é—´è¯„åˆ† (0-100)
    const timeScore = Math.max(0, 100 - (evaluation.benchmarks.averageExecutionTime / 100));
    totalScore += timeScore * weights.executionTime;
    
    // å†…å­˜ä½¿ç”¨è¯„åˆ† (0-100)
    const memoryScore = Math.max(0, 100 - evaluation.metrics.resourceUsage.peakMemoryUsage);
    totalScore += memoryScore * weights.memoryUsage;
    
    // CPUä½¿ç”¨è¯„åˆ† (0-100)
    const cpuScore = Math.max(0, 100 - evaluation.metrics.resourceUsage.peakCpuUsage);
    totalScore += cpuScore * weights.cpuUsage;
    
    // å¯æ‰©å±•æ€§è¯„åˆ† (0-100)
    const scalabilityScore = evaluation.metrics.scalability.score || 50;
    totalScore += scalabilityScore * weights.scalability;
    
    return Math.round(totalScore);
  }
}
```

## ğŸ‘¥ äººå·¥å®¡æ ¸ç³»ç»Ÿ

### 1. å®¡æ ¸å·¥ä½œå°
```html
<div class="review-dashboard">
  <!-- å®¡æ ¸é˜Ÿåˆ— -->
  <div class="review-queue">
    <h2>å¾…å®¡æ ¸æŠ€èƒ½</h2>
    <div class="queue-filters">
      <select v-model="filterStatus">
        <option value="pending">å¾…å®¡æ ¸</option>
        <option value="in_review">å®¡æ ¸ä¸­</option>
        <option value="approved">å·²é€šè¿‡</option>
        <option value="rejected">å·²æ‹’ç»</option>
      </select>
      
      <input 
        type="text" 
        v-model="searchQuery" 
        placeholder="æœç´¢æŠ€èƒ½åç§°æˆ–ä½œè€…..."
      >
    </div>
    
    <div class="queue-list">
      <div 
        v-for="skill in filteredSkills" 
        :key="skill.id"
        class="queue-item"
        :class="{ 'selected': selectedSkill?.id === skill.id }"
        @click="selectSkill(skill)"
      >
        <div class="skill-info">
          <h4>{{ skill.name }}</h4>
          <p class="skill-author">ä½œè€…: {{ skill.author }}</p>
          <p class="skill-date">æäº¤æ—¶é—´: {{ formatDate(skill.submittedAt) }}</p>
        </div>
        
        <div class="skill-status">
          <span class="status-badge" :class="skill.status">
            {{ getStatusText(skill.status) }}
          </span>
        </div>
        
        <div class="skill-priority">
          <span class="priority-badge" :class="skill.priority">
            {{ getPriorityText(skill.priority) }}
          </span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- å®¡æ ¸è¯¦æƒ… -->
  <div class="review-details" v-if="selectedSkill">
    <div class="review-header">
      <h2>{{ selectedSkill.name }}</h2>
      <div class="review-actions">
        <button @click="approveSkill" class="btn-approve">æ‰¹å‡†</button>
        <button @click="rejectSkill" class="btn-reject">æ‹’ç»</button>
        <button @click="requestChanges" class="btn-changes">è¦æ±‚ä¿®æ”¹</button>
        <button @click="assignReviewer" class="btn-assign">æŒ‡æ´¾å®¡æ ¸å‘˜</button>
      </div>
    </div>
    
    <!-- è‡ªåŠ¨æ£€æµ‹ç»“æœ -->
    <div class="auto-review-results">
      <h3>è‡ªåŠ¨æ£€æµ‹ç»“æœ</h3>
      
      <div class="result-section">
        <h4>ä»£ç è´¨é‡</h4>
        <div class="score-display">
          <div class="score-circle" :style="{ 'border-color': getScoreColor(autoResults.codeQuality.overall) }">
            {{ Math.round(autoResults.codeQuality.overall) }}%
          </div>
        </div>
        <div class="issues-list">
          <div v-for="issue in autoResults.codeQuality.issues" :key="issue.id" class="issue-item">
            <span class="issue-type">{{ issue.type }}</span>
            <span class="issue-message">{{ issue.message }}</span>
          </div>
        </div>
      </div>
      
      <div class="result-section">
        <h4>å®‰å…¨æ‰«æ</h4>
        <div class="score-display">
          <div class="score-circle" :style="{ 'border-color': getScoreColor(autoResults.security.overall) }">
            {{ Math.round(autoResults.security.overall) }}%
          </div>
        </div>
        <div class="security-issues">
          <div v-for="issue in autoResults.security.criticalIssues" :key="issue.id" class="critical-issue">
            <span class="issue-type">ğŸš¨ {{ issue.type }}</span>
            <span class="issue-message">{{ issue.message }}</span>
          </div>
        </div>
      </div>
      
      <div class="result-section">
        <h4>æ€§èƒ½è¯„ä¼°</h4>
        <div class="score-display">
          <div class="score-circle" :style="{ 'border-color': getScoreColor(autoResults.performance.overall) }">
            {{ Math.round(autoResults.performance.overall) }}%
          </div>
        </div>
        <div class="performance-metrics">
          <div class="metric">
            <span class="metric-label">æ‰§è¡Œæ—¶é—´:</span>
            <span class="metric-value">{{ autoResults.performance.benchmarks.averageExecutionTime }}ms</span>
          </div>
          <div class="metric">
            <span class="metric-label">å†…å­˜ä½¿ç”¨:</span>
            <span class="metric-value">{{ autoResults.performance.metrics.resourceUsage.peakMemoryUsage }}MB</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ä»£ç é¢„è§ˆ -->
    <div class="code-preview">
      <h3>ä»£ç é¢„è§ˆ</h3>
      <div class="code-tabs">
        <button 
          v-for="lang in ['stigmergy', 'claude']" 
          :key="lang"
          @click="activeCodeTab = lang"
          :class="{ 'active': activeCodeTab === lang }"
        >
          {{ lang }}
        </button>
      </div>
      
      <div class="code-content">
        <pre><code>{{ selectedSkill.code[activeCodeTab] }}</code></pre>
      </div>
    </div>
    
    <!-- äººå·¥å®¡æ ¸æ„è§ -->
    <div class="human-review">
      <h3>äººå·¥å®¡æ ¸æ„è§</h3>
      <textarea 
        v-model="reviewComments"
        placeholder="è¯·è¾“å…¥å®¡æ ¸æ„è§..."
        rows="6"
      ></textarea>
      
      <div class="review-checklist">
        <h4>å®¡æ ¸æ£€æŸ¥æ¸…å•</h4>
        <label v-for="item in reviewChecklist" :key="item.id">
          <input 
            type="checkbox" 
            v-model="item.checked"
            @change="updateChecklistProgress"
          >
          {{ item.text }}
        </label>
      </div>
      
      <div class="review-rating">
        <h4>ç»¼åˆè¯„åˆ†</h4>
        <div class="rating-stars">
          <span 
            v-for="star in 5" 
            :key="star"
            @click="setRating(star)"
            :class="{ 'active': star <= overallRating }"
          >
            â­
          </span>
        </div>
      </div>
    </div>
  </div>
</div>
```

### 2. å®¡æ ¸æµç¨‹ç®¡ç†
```javascript
class ReviewProcessManager {
  constructor() {
    this.reviewQueue = new ReviewQueue();
    this.notificationService = new NotificationService();
    this.escalationManager = new EscalationManager();
  }
  
  async submitForReview(skillSubmission) {
    try {
      // 1. åˆ›å»ºå®¡æ ¸è®°å½•
      const reviewRecord = {
        skillId: skillSubmission.id,
        status: 'pending',
        submittedAt: new Date(),
        submitter: skillSubmission.author,
        autoResults: skillSubmission.autoResults,
        assignedReviewer: null,
        reviewHistory: []
      };
      
      // 2. åŠ å…¥å®¡æ ¸é˜Ÿåˆ—
      await this.reviewQueue.enqueue(reviewRecord);
      
      // 3. è‡ªåŠ¨åˆ†é…å®¡æ ¸å‘˜
      const reviewer = await this.assignReviewer(reviewRecord);
      
      // 4. é€šçŸ¥å®¡æ ¸å‘˜
      await this.notificationService.notifyReviewer(reviewer, reviewRecord);
      
      // 5. è®¾ç½®å®¡æ ¸è¶…æ—¶
      this.setReviewTimeout(reviewRecord);
      
      return reviewRecord;
      
    } catch (error) {
      console.error('æäº¤å®¡æ ¸å¤±è´¥:', error);
      throw new Error('æ— æ³•å°†æŠ€èƒ½æäº¤å®¡æ ¸');
    }
  }
  
  async assignReviewer(reviewRecord) {
    // æ ¹æ®æŠ€èƒ½ç±»å‹å’Œå®¡æ ¸å‘˜ä¸“é•¿åŒ¹é…
    const availableReviewers = await this.getAvailableReviewers();
    
    const bestReviewer = this.selectBestReviewer(
      availableReviewers,
      reviewRecord.skillType,
      reviewRecord.priority
    );
    
    if (bestReviewer) {
      reviewRecord.assignedReviewer = bestReviewer.id;
      reviewRecord.status = 'in_review';
      reviewRecord.assignedAt = new Date();
      
      await this.updateReviewRecord(reviewRecord);
      
      return bestReviewer;
    } else {
      // æ²¡æœ‰å¯ç”¨çš„å®¡æ ¸å‘˜ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—
      await this.escalationManager.addToWaitingList(reviewRecord);
      return null;
    }
  }
  
  async completeReview(reviewId, reviewResult) {
    try {
      const reviewRecord = await this.getReviewRecord(reviewId);
      
      // æ›´æ–°å®¡æ ¸è®°å½•
      reviewRecord.reviewHistory.push({
        reviewer: reviewRecord.assignedReviewer,
        result: reviewResult,
        completedAt: new Date()
      });
      
      reviewRecord.status = reviewResult.decision;
      reviewRecord.completedAt = new Date();
      
      // æ ¹æ®å®¡æ ¸ç»“æœå¤„ç†
      switch (reviewResult.decision) {
        case 'approved':
          await this.approveSkill(reviewRecord);
          break;
        case 'rejected':
          await this.rejectSkill(reviewRecord, reviewResult.reasons);
          break;
        case 'needs_revision':
          await this.requestRevision(reviewRecord, reviewResult.feedback);
          break;
      }
      
      // é€šçŸ¥æäº¤è€…
      await this.notificationService.notifySubmitter(reviewRecord);
      
      // é‡Šæ”¾å®¡æ ¸å‘˜
      await this.releaseReviewer(reviewRecord.assignedReviewer);
      
      return reviewRecord;
      
    } catch (error) {
      console.error('å®Œæˆå®¡æ ¸å¤±è´¥:', error);
      throw new Error('å®¡æ ¸å®Œæˆå¤„ç†å¤±è´¥');
    }
  }
  
  async approveSkill(reviewRecord) {
    // æ›´æ–°æŠ€èƒ½çŠ¶æ€
    await SkillModel.findByIdAndUpdate(reviewRecord.skillId, {
      status: 'approved',
      approvedAt: new Date(),
      approvedBy: reviewRecord.assignedReviewer
    });
    
    // åˆ›å»ºå‘å¸ƒä»»åŠ¡
    const publicationTask = {
      skillId: reviewRecord.skillId,
      scheduledAt: new Date(),
      status: 'scheduled'
    };
    
    await this.schedulePublication(publicationTask);
  }
  
  async rejectSkill(reviewRecord, reasons) {
    // æ›´æ–°æŠ€èƒ½çŠ¶æ€
    await SkillModel.findByIdAndUpdate(reviewRecord.skillId, {
      status: 'rejected',
      rejectedAt: new Date(),
      rejectedBy: reviewRecord.assignedReviewer,
      rejectionReasons: reasons
    });
    
    // è®°å½•æ‹’ç»ç»Ÿè®¡
    await this.recordRejectionStats(reviewRecord, reasons);
  }
  
  async requestRevision(reviewRecord, feedback) {
    // æ›´æ–°æŠ€èƒ½çŠ¶æ€
    await SkillModel.findByIdAndUpdate(reviewRecord.skillId, {
      status: 'needs_revision',
      revisionRequestedAt: new Date(),
      revisionFeedback: feedback
    });
    
    // è®¾ç½®ä¿®æ”¹æœŸé™
    const revisionDeadline = new Date();
    revisionDeadline.setDate(revisionDeadline.getDate() + 7); // 7å¤©æœŸé™
    
    await SkillModel.findByIdAndUpdate(reviewRecord.skillId, {
      revisionDeadline
    });
    
    // è®¾ç½®ä¿®æ”¹æé†’
    this.scheduleRevisionReminder(reviewRecord.skillId, revisionDeadline);
  }
}
```

## ğŸ“Š å‘å¸ƒç®¡ç†ç³»ç»Ÿ

### 1. å‘å¸ƒè°ƒåº¦å™¨
```javascript
class PublicationScheduler {
  constructor() {
    this.publicationQueue = new PublicationQueue();
    this.deploymentManager = new DeploymentManager();
    this.monitoringService = new MonitoringService();
  }
  
  async schedulePublication(skillId, scheduledTime = new Date()) {
    const publicationTask = {
      skillId,
      scheduledTime,
      status: 'scheduled',
      createdAt: new Date(),
      retryCount: 0,
      maxRetries: 3
    };
    
    await this.publicationQueue.enqueue(publicationTask);
    
    // è®¾ç½®å‘å¸ƒæé†’
    this.schedulePublicationReminder(publicationTask);
    
    return publicationTask;
  }
  
  async executePublication(taskId) {
    const task = await this.publicationQueue.getTask(taskId);
    
    try {
      // 1. é¢„å‘å¸ƒæ£€æŸ¥
      const prePublicationCheck = await this.performPrePublicationCheck(task.skillId);
      
      if (!prePublicationCheck.passed) {
        throw new Error(`é¢„å‘å¸ƒæ£€æŸ¥å¤±è´¥: ${prePublicationCheck.issues.join(', ')}`);
      }
      
      // 2. åˆ›å»ºå‘å¸ƒç‰ˆæœ¬
      const releaseVersion = await this.createReleaseVersion(task.skillId);
      
      // 3. éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
      const deploymentResult = await this.deploymentManager.deploy(
        task.skillId,
        releaseVersion
      );
      
      if (!deploymentResult.success) {
        throw new Error(`éƒ¨ç½²å¤±è´¥: ${deploymentResult.error}`);
      }
      
      // 4. æ›´æ–°æŠ€èƒ½çŠ¶æ€
      await this.updateSkillStatus(task.skillId, 'published', {
        publishedAt: new Date(),
        version: releaseVersion,
        deploymentId: deploymentResult.deploymentId
      });
      
      // 5. å¯åŠ¨ç›‘æ§
      await this.monitoringService.startMonitoring(task.skillId);
      
      // 6. æ ‡è®°ä»»åŠ¡å®Œæˆ
      task.status = 'completed';
      task.completedAt = new Date();
      
      await this.publicationQueue.updateTask(task);
      
      // 7. å‘é€å‘å¸ƒé€šçŸ¥
      await this.sendPublicationNotification(task.skillId, releaseVersion);
      
      return {
        success: true,
        skillId: task.skillId,
        version: releaseVersion,
        publishedAt: new Date()
      };
      
    } catch (error) {
      console.error('å‘å¸ƒå¤±è´¥:', error);
      
      // å¤„ç†å‘å¸ƒå¤±è´¥
      await this.handlePublicationFailure(task, error);
      
      throw error;
    }
  }
  
  async handlePublicationFailure(task, error) {
    task.retryCount++;
    
    if (task.retryCount <= task.maxRetries) {
      // é‡è¯•å‘å¸ƒ
      task.status = 'retrying';
      task.nextRetryAt = new Date(Date.now() + 5 * 60 * 1000); // 5åˆ†é’Ÿåé‡è¯•
      
      await this.publicationQueue.updateTask(task);
      
      // å‘é€å¤±è´¥é€šçŸ¥
      await this.sendFailureNotification(task, error);
      
    } else {
      // å‘å¸ƒå¤±è´¥ï¼Œæ ‡è®°ä¸ºå¤±è´¥
      task.status = 'failed';
      task.failedAt = new Date();
      task.error = error.message;
      
      await this.publicationQueue.updateTask(task);
      
      // é€šçŸ¥ç®¡ç†å‘˜
      await this.notifyAdmin(task, error);
    }
  }
  
  async performPrePublicationCheck(skillId) {
    const check = {
      passed: true,
      issues: []
    };
    
    // 1. æ£€æŸ¥æŠ€èƒ½çŠ¶æ€
    const skill = await SkillModel.findById(skillId);
    
    if (skill.status !== 'approved') {
      check.passed = false;
      check.issues.push('æŠ€èƒ½çŠ¶æ€ä¸æ˜¯å·²æ‰¹å‡†');
    }
    
    // 2. æ£€æŸ¥ä¾èµ–é¡¹
    const dependencyCheck = await this.checkDependencies(skill);
    if (!dependencyCheck.available) {
      check.passed = false;
      check.issues.push('ä¾èµ–é¡¹ä¸å¯ç”¨');
    }
    
    // 3. æ£€æŸ¥èµ„æºé…é¢
    const quotaCheck = await this.checkResourceQuota(skill.author);
    if (!quotaCheck.sufficient) {
      check.passed = false;
      check.issues.push('èµ„æºé…é¢ä¸è¶³');
    }
    
    // 4. æ£€æŸ¥å‘å¸ƒçª—å£
    const windowCheck = this.checkPublicationWindow();
    if (!windowCheck.allowed) {
      check.passed = false;
      check.issues.push('ä¸åœ¨å‘å¸ƒæ—¶é—´çª—å£å†…');
    }
    
    return check;
  }
}
```

### 2. ç›‘æ§ä¸å›æ»šæœºåˆ¶
```javascript
class PostPublicationMonitor {
  constructor() {
    this.metricsCollector = new MetricsCollector();
    this.alertManager = new AlertManager();
    this.rollbackManager = new RollbackManager();
  }
  
  async startMonitoring(skillId) {
    const monitoringConfig = {
      skillId,
      startTime: new Date(),
      metrics: {
        errorRate: { threshold: 0.05, window: '5m' },
        responseTime: { threshold: 2000, window: '5m' },
        memoryUsage: { threshold: 80, window: '1m' },
        cpuUsage: { threshold: 70, window: '1m' }
      },
      alerts: [],
      status: 'monitoring'
    };
    
    // å¯åŠ¨æŒ‡æ ‡æ”¶é›†
    await this.metricsCollector.startCollection(skillId, monitoringConfig.metrics);
    
    // è®¾ç½®ç›‘æ§æ£€æŸ¥
    this.monitoringInterval = setInterval(() => {
      this.checkSkillHealth(skillId, monitoringConfig);
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    
    return monitoringConfig;
  }
  
  async checkSkillHealth(skillId, config) {
    try {
      const metrics = await this.metricsCollector.getMetrics(skillId);
      const issues = [];
      
      // æ£€æŸ¥é”™è¯¯ç‡
      if (metrics.errorRate > config.metrics.errorRate.threshold) {
        issues.push({
          type: 'high_error_rate',
          current: metrics.errorRate,
          threshold: config.metrics.errorRate.threshold,
          severity: 'critical'
        });
      }
      
      // æ£€æŸ¥å“åº”æ—¶é—´
      if (metrics.responseTime > config.metrics.responseTime.threshold) {
        issues.push({
          type: 'slow_response',
          current: metrics.responseTime,
          threshold: config.metrics.responseTime.threshold,
          severity: 'warning'
        });
      }
      
      // æ£€æŸ¥èµ„æºä½¿ç”¨
      if (metrics.memoryUsage > config.metrics.memoryUsage.threshold) {
        issues.push({
          type: 'high_memory_usage',
          current: metrics.memoryUsage,
          threshold: config.metrics.memoryUsage.threshold,
          severity: 'warning'
        });
      }
      
      // å¤„ç†å‘ç°çš„é—®é¢˜
      if (issues.length > 0) {
        await this.handleHealthIssues(skillId, issues);
      }
      
    } catch (error) {
      console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
      await this.alertManager.sendAlert({
        type: 'monitoring_failure',
        skillId,
        error: error.message,
        severity: 'warning'
      });
    }
  }
  
  async handleHealthIssues(skillId, issues) {
    const criticalIssues = issues.filter(i => i.severity === 'critical');
    
    if (criticalIssues.length > 0) {
      // æœ‰å…³é”®é—®é¢˜ï¼Œè€ƒè™‘è‡ªåŠ¨å›æ»š
      const shouldRollback = await this.evaluateRollbackDecision(skillId, criticalIssues);
      
      if (shouldRollback) {
        await this.initiateRollback(skillId, criticalIssues);
      } else {
        // å‘é€ç´§æ€¥è­¦æŠ¥
        await this.alertManager.sendAlert({
          type: 'critical_health_issues',
          skillId,
          issues: criticalIssues,
          severity: 'critical'
        });
      }
    }
    
    // å‘é€ä¸€èˆ¬è­¦æŠ¥
    const warningIssues = issues.filter(i => i.severity === 'warning');
    if (warningIssues.length > 0) {
      await this.alertManager.sendAlert({
        type: 'health_warnings',
        skillId,
        issues: warningIssues,
        severity: 'warning'
      });
    }
  }
  
  async initiateRollback(skillId, reasons) {
    try {
      // 1. è®°å½•å›æ»šåŸå› 
      await this.recordRollbackReason(skillId, reasons);
      
      // 2. æ‰§è¡Œå›æ»š
      const rollbackResult = await this.rollbackManager.rollback(skillId);
      
      if (rollbackResult.success) {
        // 3. æ›´æ–°æŠ€èƒ½çŠ¶æ€
        await SkillModel.findByIdAndUpdate(skillId, {
          status: 'rolled_back',
          rolledBackAt: new Date(),
          rollbackReasons: reasons
        });
        
        // 4. åœæ­¢ç›‘æ§
        await this.stopMonitoring(skillId);
        
        // 5. å‘é€å›æ»šé€šçŸ¥
        await this.sendRollbackNotification(skillId, reasons);
        
      } else {
        throw new Error(`å›æ»šå¤±è´¥: ${rollbackResult.error}`);
      }
      
    } catch (error) {
      console.error('å›æ»šå¤„ç†å¤±è´¥:', error);
      await this.alertManager.sendAlert({
        type: 'rollback_failure',
        skillId,
        error: error.message,
        severity: 'critical'
      });
    }
  }
}
```

## ğŸ“ˆ å®¡æ ¸ç»Ÿè®¡ä¸åˆ†æ

### 1. å®¡æ ¸æ•ˆç‡åˆ†æ
```javascript
class ReviewAnalytics {
  constructor() {
    this.metricsStore = new MetricsStore();
    this.reportGenerator = new ReportGenerator();
  }
  
  async generateReviewReport(timeRange) {
    const report = {
      period: timeRange,
      summary: {},
      details: {},
      trends: {}
    };
    
    try {
      // 1. åŸºç¡€ç»Ÿè®¡
      const basicStats = await this.getBasicStats(timeRange);
      report.summary = basicStats;
      
      // 2. å®¡æ ¸æ•ˆç‡åˆ†æ
      const efficiencyAnalysis = await this.analyzeEfficiency(timeRange);
      report.details.efficiency = efficiencyAnalysis;
      
      // 3. è´¨é‡è¶‹åŠ¿åˆ†æ
      const qualityTrends = await this.analyzeQualityTrends(timeRange);
      report.trends.quality = qualityTrends;
      
      // 4. å®¡æ ¸å‘˜è¡¨ç°
      const reviewerPerformance = await this.analyzeReviewerPerformance(timeRange);
      report.details.reviewers = reviewerPerformance;
      
      // 5. æŠ€èƒ½ç±»å‹åˆ†æ
      const skillTypeAnalysis = await this.analyzeSkillTypes(timeRange);
      report.details.skillTypes = skillTypeAnalysis;
      
      return report;
      
    } catch (error) {
      console.error('ç”Ÿæˆå®¡æ ¸æŠ¥å‘Šå¤±è´¥:', error);
      throw new Error('æ— æ³•ç”Ÿæˆå®¡æ ¸æŠ¥å‘Š');
    }
  }
  
  async analyzeEfficiency(timeRange) {
    const efficiency = {
      averageReviewTime: 0,
      reviewThroughput: 0,
      backlogTrend: [],
      bottlenecks: []
    };
    
    // è®¡ç®—å¹³å‡å®¡æ ¸æ—¶é—´
    const reviewTimes = await this.getReviewTimes(timeRange);
    efficiency.averageReviewTime = reviewTimes.reduce((a, b) => a + b, 0) / reviewTimes.length;
    
    // è®¡ç®—å®¡æ ¸ååé‡
    const completedReviews = await this.getCompletedReviews(timeRange);
    efficiency.reviewThroughput = completedReviews.length / this.getDaysInRange(timeRange);
    
    // åˆ†æç§¯å‹è¶‹åŠ¿
    const backlogData = await this.getBacklogData(timeRange);
    efficiency.backlogTrend = backlogData;
    
    // è¯†åˆ«ç“¶é¢ˆ
    efficiency.bottlenecks = await this.identifyBottlenecks(timeRange);
    
    return efficiency;
  }
  
  async analyzeQualityTrends(timeRange) {
    const trends = {
      codeQualityScore: [],
      securityScore: [],
      performanceScore: [],
      approvalRate: []
    };
    
    // æŒ‰å‘¨åˆ†æè¶‹åŠ¿
    const weeks = this.getWeeksInRange(timeRange);
    
    for (const week of weeks) {
      const weekData = await this.getWeekReviewData(week);
      
      trends.codeQualityScore.push({
        week: week.start,
        score: weekData.averageCodeQuality
      });
      
      trends.securityScore.push({
        week: week.start,
        score: weekData.averageSecurityScore
      });
      
      trends.performanceScore.push({
        week: week.start,
        score: weekData.averagePerformanceScore
      });
      
      trends.approvalRate.push({
        week: week.start,
        rate: weekData.approvalRate
      });
    }
    
    return trends;
  }
}
```

---

**è®¾è®¡å›¢é˜Ÿ**ï¼šå¹³å°å®¡æ ¸å‘å¸ƒæœºåˆ¶è®¾è®¡å›¢é˜Ÿ  
**è®¾è®¡æ—¥æœŸ**ï¼š2025å¹´12æœˆ14æ—¥  
**ç‰ˆæœ¬**ï¼šv1.0