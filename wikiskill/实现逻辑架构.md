# WikiSkill å®ç°é€»è¾‘æ¶æ„

## ğŸ¯ æ ¸å¿ƒå®ç°é€»è¾‘

### 1. çº¦æŸå¯¹é½ä¸é€»è¾‘ä¸€è‡´æ€§å®ç°

#### 1.1 çº¦æŸè¯†åˆ«é€»è¾‘
```javascript
class ConstraintIdentifier {
  constructor() {
    this.patterns = {
      input_constraints: [
        /è¾“å…¥.*?(æ ¼å¼|ç±»å‹|è¦æ±‚)/gi,
        /éœ€è¦.*?(æ–‡ä»¶|æ•°æ®|å‚æ•°)/gi,
        /æ”¯æŒ.*?(æ ¼å¼|æ ¼å¼|åè®®)/gi
      ],
      output_constraints: [
        /è¾“å‡º.*?(æ ¼å¼|ç±»å‹|è¦æ±‚)/gi,
        /ç”Ÿæˆ.*?(æ–‡ä»¶|æŠ¥å‘Š|ç»“æœ)/gi,
        /è¿”å›.*?(æ ¼å¼|ç»“æ„)/gi
      ],
      process_constraints: [
        /å¤„ç†.*?(æ­¥éª¤|æµç¨‹|æ–¹æ³•)/gi,
        /éµå¾ª.*?(è§„åˆ™|æ ‡å‡†|åè®®)/gi,
        /é™åˆ¶.*?(æ¡ä»¶|èŒƒå›´)/gi
      ]
    };
  }
  
  // è¯†åˆ«çº¦æŸæ¡ä»¶
  identifyConstraints(prompt) {
    const constraints = {
      input: [],
      output: [],
      process: [],
      context: [],
      quality: []
    };
    
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
    for (const [category, patterns] of Object.entries(this.patterns)) {
      for (const pattern of patterns) {
        const matches = prompt.match(pattern);
        if (matches) {
          constraints[category].push(...matches);
        }
      }
    }
    
    // ä½¿ç”¨NLPæ¨¡å‹è¿›è¡Œæ·±åº¦è¯†åˆ«
    const nlpConstraints = await this.nlpIdentifyConstraints(prompt);
    
    // åˆå¹¶ç»“æœ
    return this.mergeConstraints(constraints, nlpConstraints);
  }
  
  // NLPæ·±åº¦è¯†åˆ«
  async nlpIdentifyConstraints(prompt) {
    // è°ƒç”¨å¤§è¯­è¨€æ¨¡å‹è¿›è¡Œçº¦æŸè¯†åˆ«
    const response = await this.llmClient.complete({
      prompt: `è¯·è¯†åˆ«ä»¥ä¸‹æç¤ºè¯ä¸­çš„çº¦æŸæ¡ä»¶ï¼š${prompt}`,
      max_tokens: 500,
      temperature: 0.1
    });
    
    return this.parseNLPResponse(response.choices[0].text);
  }
}
```

#### 1.2 é€»è¾‘ä¸€è‡´æ€§æ£€æŸ¥
```javascript
class ConsistencyChecker {
  constructor() {
    this.logicRules = new LogicRules();
    this.conflictDetector = new ConflictDetector();
  }
  
  // æ£€æŸ¥é€»è¾‘ä¸€è‡´æ€§
  async checkConsistency(constraints) {
    const issues = [];
    
    // æ£€æŸ¥è¾“å…¥è¾“å‡ºä¸€è‡´æ€§
    const ioConsistency = await this.checkIOConsistency(constraints);
    issues.push(...ioConsistency);
    
    // æ£€æŸ¥æµç¨‹é€»è¾‘ä¸€è‡´æ€§
    const processConsistency = await this.checkProcessConsistency(constraints);
    issues.push(...processConsistency);
    
    // æ£€æŸ¥ä¸Šä¸‹æ–‡ä¸€è‡´æ€§
    const contextConsistency = await this.checkContextConsistency(constraints);
    issues.push(...contextConsistency);
    
    return {
      consistent: issues.length === 0,
      issues: issues,
      score: this.calculateConsistencyScore(issues)
    };
  }
  
  // æ£€æŸ¥è¾“å…¥è¾“å‡ºä¸€è‡´æ€§
  async checkIOConsistency(constraints) {
    const issues = [];
    
    // æ£€æŸ¥è¾“å…¥è¾“å‡ºç±»å‹åŒ¹é…
    const inputTypes = this.extractTypes(constraints.input);
    const outputTypes = this.extractTypes(constraints.output);
    
    for (const inputType of inputTypes) {
      const compatibleOutputs = this.getCompatibleOutputs(inputType);
      const hasCompatible = outputTypes.some(output => 
        compatibleOutputs.includes(output)
      );
      
      if (!hasCompatible) {
        issues.push({
          type: 'io_inconsistency',
          message: `è¾“å…¥ç±»å‹ ${inputType} æ²¡æœ‰å…¼å®¹çš„è¾“å‡ºç±»å‹`,
          severity: 'error'
        });
      }
    }
    
    return issues;
  }
}
```

### 2. ä¸Šä¸‹æ–‡ç»“æ„åŒ–å®ç°

#### 2.1 ä¸Šä¸‹æ–‡è¦ç´ æå–
```javascript
class ContextExtractor {
  constructor() {
    this.domainClassifier = new DomainClassifier();
    this.scopeAnalyzer = new ScopeAnalyzer();
    this.requirementExtractor = new RequirementExtractor();
  }
  
  // æå–ä¸Šä¸‹æ–‡è¦ç´ 
  async extractContextElements(prompt) {
    const elements = {
      domain: await this.domainClassifier.classify(prompt),
      scope: await this.scopeAnalyzer.analyze(prompt),
      stakeholders: await this.extractStakeholders(prompt),
      requirements: await this.requirementExtractor.extract(prompt),
      constraints: await this.extractConstraints(prompt),
      assumptions: await this.extractAssumptions(prompt)
    };
    
    // æ„å»ºä¸Šä¸‹æ–‡å±‚æ¬¡
    return this.buildContextHierarchy(elements);
  }
  
  // æ„å»ºä¸Šä¸‹æ–‡å±‚æ¬¡
  buildContextHierarchy(elements) {
    return {
      level1: {
        domain: elements.domain,
        scope: elements.scope
      },
      level2: {
        stakeholders: elements.stakeholders,
        requirements: elements.requirements
      },
      level3: {
        constraints: elements.constraints,
        assumptions: elements.assumptions
      },
      metadata: {
        extracted_at: new Date().toISOString(),
        confidence: this.calculateExtractionConfidence(elements)
      }
    };
  }
}
```

#### 2.2 æ¸è¿›å¼æŠ«éœ²ç­–ç•¥
```javascript
class ProgressiveDiscloser {
  constructor() {
    this.disclosureRules = new DisclosureRules();
    this.userRoleManager = new UserRoleManager();
  }
  
  // è®¾è®¡æŠ«éœ²ç­–ç•¥
  async designDisclosureStrategy(context) {
    const strategy = {
      phases: [],
      triggers: [],
      content: {}
    };
    
    // æ ¹æ®ç”¨æˆ·è§’è‰²è®¾è®¡æŠ«éœ²
    for (const role of this.userRoleManager.getAllRoles()) {
      const phase = await this.createDisclosurePhase(context, role);
      strategy.phases.push(phase);
    }
    
    // è®¾è®¡è§¦å‘æ¡ä»¶
    strategy.triggers = await this.designTriggers(context);
    
    return strategy;
  }
  
  // åˆ›å»ºæŠ«éœ²é˜¶æ®µ
  async createDisclosurePhase(context, role) {
    const rules = this.disclosureRules.getRules(role);
    
    return {
      role: role,
      level: rules.level,
      content: this.filterContent(context, rules),
      conditions: rules.conditions,
      timing: rules.timing
    };
  }
}
```

### 3. è§£è€¦åˆ†æå®ç°

#### 3.1 å¯ç¡¬åŒ–éƒ¨åˆ†è¯†åˆ«
```javascript
class HardenablePartIdentifier {
  constructor() {
    this.confidenceCalculator = new ConfidenceCalculator();
    this.codeGenerator = new CodeGenerator();
  }
  
  // è¯†åˆ«å¯ç¡¬åŒ–éƒ¨åˆ†
  async identifyHardenableParts(skillDefinition) {
    const hardenableParts = [];
    
    // æ•°æ®å¤„ç†é€»è¾‘
    if (skillDefinition.data_processing) {
      const confidence = await this.confidenceCalculator.calculate(
        skillDefinition.data_processing,
        'data_processing'
      );
      
      if (confidence > 0.8) {
        hardenableParts.push({
          type: 'data_processing',
          logic: skillDefinition.data_processing,
          confidence: confidence,
          implementation: await this.codeGenerator.generateImplementation(
            skillDefinition.data_processing
          )
        });
      }
    }
    
    // éªŒè¯è§„åˆ™
    if (skillDefinition.validation_rules) {
      const confidence = await this.confidenceCalculator.calculate(
        skillDefinition.validation_rules,
        'validation'
      );
      
      if (confidence > 0.9) {
        hardenableParts.push({
          type: 'validation',
          logic: skillDefinition.validation_rules,
          confidence: confidence,
          implementation: await this.codeGenerator.generateImplementation(
            skillDefinition.validation_rules
          )
        });
      }
    }
    
    return hardenableParts;
  }
  
  // ç½®ä¿¡åº¦è®¡ç®—
  async calculateConfidence(logic, category) {
    const factors = {
      specificity: this.calculateSpecificity(logic),
      completeness: this.calculateCompleteness(logic),
      determinism: this.calculateDeterminism(logic),
      testability: this.calculateTestability(logic)
    };
    
    // åŠ æƒè®¡ç®—
    const weights = {
      specificity: 0.3,
      completeness: 0.3,
      determinism: 0.2,
      testability: 0.2
    };
    
    let score = 0;
    for (const [factor, weight] of Object.entries(factors)) {
      score += factors[factor] * weight;
    }
    
    return Math.min(score, 1.0);
  }
}
```

#### 3.2 æŸ”æ€§å¤„ç†ç­–ç•¥
```javascript
class FlexibleHandler {
  constructor() {
    this.aiProcessor = new AIProcessor();
    this.humanInTheLoop = new HumanInTheLoop();
  }
  
  // è®¾è®¡æŸ”æ€§å¤„ç†ç­–ç•¥
  async designStrategy(flexibleParts) {
    const strategies = [];
    
    for (const part of flexibleParts) {
      const strategy = await this.analyzePart(part);
      strategies.push(strategy);
    }
    
    return strategies;
  }
  
  // åˆ†ææŸ”æ€§éƒ¨åˆ†
  async analyzePart(part) {
    const analysis = {
      type: part.type,
      complexity: await this.assessComplexity(part),
      ambiguity: await this.assessAmbiguity(part),
      aiCapability: await this.assessAICapability(part)
    };
    
    // æ ¹æ®åˆ†æç»“æœç¡®å®šå¤„ç†ç­–ç•¥
    if (analysis.aiCapability > 0.8 && analysis.ambiguity < 0.5) {
      return {
        type: 'ai_primary',
        confidence: analysis.aiCapability,
        implementation: 'ai_processing'
      };
    } else if (analysis.aiCapability > 0.6) {
      return {
        type: 'ai_assisted',
        confidence: analysis.aiCapability,
        implementation: 'ai_with_human_review'
      };
    } else {
      return {
        type: 'human_primary',
        confidence: 0.5,
        implementation: 'human_expert'
      };
    }
  }
}
```

### 4. è‡ªé¡¶å‘ä¸‹ä»»åŠ¡åˆ†è§£å®ç°

#### 4.1 ä»»åŠ¡åˆ†è§£å™¨
```javascript
class TaskDecomposer {
  constructor() {
    this.taskAnalyzer = new TaskAnalyzer();
    this.decompositionRules = new DecompositionRules();
    this.dependencyAnalyzer = new DependencyAnalyzer();
  }
  
  // é€’å½’åˆ†è§£ä»»åŠ¡
  async decomposeTask(task, level = 0) {
    // æ£€æŸ¥æ˜¯å¦ä¸ºåŸå­ä»»åŠ¡
    if (await this.isAtomicTask(task)) {
      return {
        id: task.id,
        type: 'atomic',
        level: level,
        task: task,
        children: [],
        estimation: await this.estimateEffort(task)
      };
    }
    
    // åˆ†è§£å­ä»»åŠ¡
    const subtasks = await this.decomposeIntoSubtasks(task);
    
    // åˆ†æä¾èµ–å…³ç³»
    const dependencies = await this.dependencyAnalyzer.analyze(subtasks);
    
    // é€’å½’å¤„ç†å­ä»»åŠ¡
    const children = [];
    for (const subtask of subtasks) {
      const childTree = await this.decomposeTask(subtask, level + 1);
      children.push(childTree);
    }
    
    return {
      id: task.id,
      type: 'composite',
      level: level,
      task: task,
      children: children,
      dependencies: dependencies,
      estimation: await this.calculateTotalEffort(children)
    };
  }
  
  // åˆ¤æ–­æ˜¯å¦ä¸ºåŸå­ä»»åŠ¡
  async isAtomicTask(task) {
    const criteria = {
      complexity: await this.assessComplexity(task),
      clarity: await this.assessClarity(task),
      atomicity: await this.assessAtomicity(task)
    };
    
    return criteria.complexity < 0.3 && 
           criteria.clarity > 0.8 && 
           criteria.atomicity > 0.9;
  }
}
```

#### 4.2 ç»“æœèšåˆå™¨
```javascript
class ResultAggregator {
  constructor() {
    this.alignmentChecker = new AlignmentChecker();
    this.conflictResolver = new ConflictResolver();
  }
  
  // èšåˆç»“æœ
  async aggregateResults(results, decompositionTree) {
    const aggregatedResults = new Map();
    
    // ä»å¶å­èŠ‚ç‚¹å¼€å§‹èšåˆ
    const leafNodes = this.getLeafNodes(decompositionTree);
    for (const leaf of leafNodes) {
      aggregatedResults.set(leaf.id, results[leaf.id]);
    }
    
    // é€çº§å‘ä¸Šèšåˆ
    const levels = this.getLevels(decompositionTree).reverse();
    for (const level of levels) {
      for (const node of level) {
        if (node.type === 'composite') {
          const childResults = node.children.map(child => 
            aggregatedResults.get(child.id)
          );
          
          const aggregated = await this.aggregateChildResults(
            childResults, 
            node.task
          );
          
          aggregatedResults.set(node.id, aggregated);
          
          // æ£€æŸ¥å¯¹é½
          const alignment = await this.alignmentChecker.checkAlignment(
            aggregated, 
            node.task
          );
          
          if (!alignment.aligned) {
            const resolved = await this.conflictResolver.resolve(
              aggregated,
              alignment.conflicts
            );
            aggregatedResults.set(node.id, resolved);
          }
        }
      }
    }
    
    return aggregatedResults.get(decompositionTree.id);
  }
  
  // èšåˆå­ç»“æœ
  async aggregateChildResults(childResults, parentTask) {
    const aggregation = {
      status: 'completed',
      results: childResults,
      quality: await this.calculateQuality(childResults),
      timestamp: new Date().toISOString()
    };
    
    // æ ¹æ®çˆ¶ä»»åŠ¡è¦æ±‚èšåˆ
    if (parentTask.aggregation_type === 'merge') {
      return await this.mergeResults(childResults);
    } else if (parentTask.aggregation_type === 'filter') {
      return await this.filterResults(childResults, parentTask.filter_criteria);
    } else if (parentTask.aggregation_type === 'transform') {
      return await this.transformResults(childResults, parentTask.transformation);
    } else {
      return aggregation;
    }
  }
}
```

### 5. å®¡æ ¸åé¦ˆæµç¨‹å®ç°

#### 5.1 å®¡æ ¸çŠ¶æ€æœº
```javascript
class AuditStateMachine {
  constructor() {
    this.states = {
      PENDING: 'pending',
      PROCESSING: 'processing',
      APPROVED: 'approved',
      REJECTED: 'rejected',
      REVIEW_NEEDED: 'review_needed'
    };
    
    this.transitions = {
      [this.states.PENDING]: [this.states.PROCESSING],
      [this.states.PROCESSING]: [
        this.states.APPROVED,
        this.states.REJECTED,
        this.states.REVIEW_NEEDED
      ],
      [this.states.REVIEW_NEEDED]: [
        this.states.APPROVED,
        this.states.REJECTED
      ]
    };
  }
  
  // çŠ¶æ€è½¬æ¢
  transition(currentState, event) {
    const allowedTransitions = this.transitions[currentState];
    
    if (allowedTransitions && allowedTransitions.includes(event)) {
      return event;
    }
    
    throw new Error(`Invalid transition from ${currentState} to ${event}`);
  }
  
  // å®¡æ ¸æç¤ºè¯
  async auditPrompt(prompt) {
    let currentState = this.states.PENDING;
    
    try {
      currentState = this.transition(currentState, this.states.PROCESSING);
      
      // æ‰§è¡Œå®¡æ ¸æµç¨‹
      const auditResult = await this.performAudit(prompt);
      
      if (auditResult.confidence.overall > 0.9) {
        currentState = this.transition(currentState, this.states.APPROVED);
      } else if (auditResult.confidence.overall > 0.7) {
        currentState = this.transition(currentState, this.states.REVIEW_NEEDED);
      } else {
        currentState = this.transition(currentState, this.states.REJECTED);
      }
      
      return {
        state: currentState,
        result: auditResult,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      currentState = this.transition(currentState, this.states.REJECTED);
      return {
        state: currentState,
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
}
```

#### 5.2 åé¦ˆç”Ÿæˆå™¨
```javascript
class FeedbackGenerator {
  constructor() {
    this.templateEngine = new TemplateEngine();
    this.suggestionEngine = new SuggestionEngine();
  }
  
  // ç”Ÿæˆåé¦ˆ
  async generateFeedback(prompt, auditResult) {
    const feedback = {
      overall_score: auditResult.confidence.overall,
      status: auditResult.state,
      issues: [],
      suggestions: [],
      next_steps: []
    };
    
    // ç”Ÿæˆé—®é¢˜åé¦ˆ
    feedback.issues = await this.generateIssueFeedback(auditResult);
    
    // ç”Ÿæˆæ”¹è¿›å»ºè®®
    feedback.suggestions = await this.generateSuggestions(prompt, auditResult);
    
    // ç”Ÿæˆä¸‹ä¸€æ­¥æŒ‡ç¤º
    feedback.next_steps = await this.generateNextSteps(auditResult);
    
    return feedback;
  }
  
  // ç”Ÿæˆé—®é¢˜åé¦ˆ
  async generateIssueFeedback(auditResult) {
    const issues = [];
    
    if (auditResult.alignment.constraints.missing.length > 0) {
      issues.push({
        type: 'missing_constraints',
        severity: 'error',
        message: 'ç¼ºå°‘å¿…è¦çš„çº¦æŸæ¡ä»¶',
        details: auditResult.alignment.constraints.missing,
        suggestions: [
          'æ·»åŠ è¾“å…¥æ ¼å¼è¦æ±‚',
          'æ˜ç¡®è¾“å‡ºæ ¼å¼è§„èŒƒ',
          'å®šä¹‰å¤„ç†æµç¨‹çº¦æŸ'
        ]
      });
    }
    
    if (auditResult.alignment.logic.inconsistencies.length > 0) {
      issues.push({
        type: 'logic_inconsistency',
        severity: 'warning',
        message: 'å­˜åœ¨é€»è¾‘ä¸ä¸€è‡´',
        details: auditResult.alignment.logic.inconsistencies,
        suggestions: [
          'æ£€æŸ¥é€»è¾‘å…³ç³»',
          'ä¿®æ­£çŸ›ç›¾æ¡ä»¶',
          'ç»Ÿä¸€å¤„ç†æ ‡å‡†'
        ]
      });
    }
    
    return issues;
  }
  
  // ç”Ÿæˆæ”¹è¿›å»ºè®®
  async generateSuggestions(prompt, auditResult) {
    const suggestions = [];
    
    // åŸºäºçº¦æŸç¼ºå¤±ç”Ÿæˆå»ºè®®
    for (const missing of auditResult.alignment.constraints.missing) {
      suggestions.push({
        id: `constraint_${missing.id}`,
        type: 'add_constraint',
        text: `æ·»åŠ çº¦æŸæ¡ä»¶ï¼š${missing.description}`,
        code: this.generateConstraintCode(missing),
        auto_applicable: true
      });
    }
    
    // åŸºäºé€»è¾‘ä¸ä¸€è‡´ç”Ÿæˆå»ºè®®
    for (const inconsistency of auditResult.alignment.logic.inconsistencies) {
      suggestions.push({
        id: `logic_${inconsistency.id}`,
        type: 'fix_logic',
        text: `ä¿®å¤é€»è¾‘ä¸ä¸€è‡´ï¼š${inconsistency.description}`,
        code: this.generateLogicFixCode(inconsistency),
        auto_applicable: inconsistency.confidence > 0.7
      });
    }
    
    return suggestions;
  }
}
```

## ğŸ”„ å®Œæ•´å®ç°æµç¨‹

### ç³»ç»Ÿä¸»æµç¨‹
```javascript
class WikiSkillSystem {
  constructor() {
    this.constraintAligner = new ConstraintAlignmentEngine();
    this.contextStructurer = new ContextStructuringSystem();
    this.decouplingAnalyzer = new DecouplingAnalyzer();
    this.taskDecomposer = new TaskDecomposer();
    this.auditEngine = new AuditEngine();
    this.codeGenerator = new SkillCodeGenerator();
    this.uncertaintyHandler = new UncertaintyHandler();
  }
  
  // ä¸»å¤„ç†æµç¨‹
  async processSkillPrompt(prompt, context = {}) {
    try {
      // é˜¶æ®µ1ï¼šçº¦æŸå¯¹é½ä¸é€»è¾‘ä¸€è‡´æ€§
      const alignedPrompt = await this.constraintAligner.alignConstraints(prompt);
      
      // é˜¶æ®µ2ï¼šä¸Šä¸‹æ–‡ç»“æ„åŒ–
      const structuredContext = await this.contextStructurer.structureContext(alignedPrompt);
      
      // é˜¶æ®µ3ï¼šè§£è€¦åˆ†æ
      const decoupledAnalysis = await this.decouplingAnalyzer.analyzeAndDecouple(
        structuredContext
      );
      
      // é˜¶æ®µ4ï¼šä»»åŠ¡åˆ†è§£
      const taskDecomposition = await this.taskDecomposer.executeHierarchicalDecomposition(
        this.createRootTask(structuredContext, decoupledAnalysis)
      );
      
      // é˜¶æ®µ5ï¼šå®¡æ ¸å’Œåé¦ˆ
      const auditResult = await this.auditEngine.audit(prompt, {
        alignedPrompt,
        structuredContext,
        decoupledAnalysis,
        taskDecomposition
      });
      
      // é˜¶æ®µ6ï¼šå¤„ç†ä¸ç¡®å®šæ€§
      if (auditResult.state === 'review_needed') {
        const userFeedback = await this.uncertaintyHandler.handleUncertainty(auditResult);
        return await this.processSkillPrompt(userFeedback.updatedPrompt, context);
      }
      
      // é˜¶æ®µ7ï¼šä»£ç ç”Ÿæˆï¼ˆé«˜ç½®ä¿¡åº¦ï¼‰
      if (auditResult.state === 'approved') {
        const generatedCode = await this.codeGenerator.generateSkill(
          prompt,
          auditResult
        );
        
        return {
          success: true,
          prompt: prompt,
          alignedPrompt: alignedPrompt,
          structuredContext: structuredContext,
          decoupledAnalysis: decoupledAnalysis,
          taskDecomposition: taskDecomposition,
          auditResult: auditResult,
          generatedCode: generatedCode
        };
      }
      
      return {
        success: false,
        prompt: prompt,
        auditResult: auditResult,
        suggestions: auditResult.feedback.suggestions
      };
      
    } catch (error) {
      return {
        success: false,
        error: error.message,
        suggestions: this.generateErrorSuggestions(error)
      };
    }
  }
}
```

---

**å®ç°å›¢é˜Ÿ**ï¼šWikiSkillæŠ€æœ¯å›¢é˜Ÿ  
**å®ç°æ—¥æœŸ**ï¼š2025å¹´12æœˆ  
**ç‰ˆæœ¬**ï¼šv1.0