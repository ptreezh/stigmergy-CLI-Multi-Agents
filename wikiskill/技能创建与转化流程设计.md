# æŠ€èƒ½åˆ›å»ºä¸è½¬åŒ–æµç¨‹è®¾è®¡

## ğŸ¯ æµç¨‹æ¦‚è¿°
ç”¨æˆ·è¾“å…¥è®¾æƒ³ â†’ äº¤äº’å¼æç‚¼ â†’ ç”ŸæˆæŠ€èƒ½ä»£ç  â†’ ç”¨æˆ·æµ‹è¯• â†’ å¹³å°å®¡æ ¸ â†’ å‘å¸ƒ

## ğŸ”„ è¯¦ç»†æµç¨‹è®¾è®¡

### ç¬¬ä¸€é˜¶æ®µï¼šç”¨æˆ·è®¾æƒ³è¾“å…¥ä¸åˆæ­¥åˆ†æ

```
ç”¨æˆ·è¾“å…¥ â†’ è‡ªç„¶è¯­è¨€ç†è§£ â†’ éœ€æ±‚æå– â†’ å¯è¡Œæ€§è¯„ä¼°
```

#### 1.1 è¾“å…¥ç•Œé¢è®¾è®¡
```html
<div class="skill-creator">
  <div class="input-section">
    <h2>æè¿°æ‚¨çš„æŠ€èƒ½è®¾æƒ³</h2>
    <textarea 
      v-model="userIdea"
      placeholder="è¯·ç”¨è‡ªç„¶è¯­è¨€æè¿°æ‚¨æƒ³è¦åˆ›å»ºçš„æŠ€èƒ½ï¼Œä¾‹å¦‚ï¼šæˆ‘æƒ³åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿè‡ªåŠ¨åˆ†æä»£ç æ€§èƒ½ç“¶é¢ˆçš„æŠ€èƒ½..."
      @input="analyzeInput"
    ></textarea>
    
    <div class="analysis-results" v-if="analysisResult">
      <div class="analysis-item">
        <span class="label">æŠ€èƒ½ç±»å‹ï¼š</span>
        <span class="value">{{ analysisResult.skillType }}</span>
      </div>
      <div class="analysis-item">
        <span class="label">å¤æ‚åº¦ï¼š</span>
        <span class="value">{{ analysisResult.complexity }}</span>
      </div>
      <div class="analysis-item">
        <span class="label">é¢„ä¼°å®ç°æ—¶é—´ï¼š</span>
        <span class="value">{{ analysisResult.estimatedTime }}</span>
      </div>
    </div>
    
    <button class="btn-next" @click="startRefinement" :disabled="!canProceed">
      å¼€å§‹æç‚¼
    </button>
  </div>
</div>
```

#### 1.2 åˆæ­¥åˆ†æé€»è¾‘
```javascript
class IdeaAnalyzer {
  constructor() {
    this.nlpService = new NLPService();
    this.patternMatcher = new PatternMatcher();
  }
  
  async analyzeIdea(userInput) {
    // 1. æ„å›¾è¯†åˆ«
    const intent = await this.nlpService.extractIntent(userInput);
    
    // 2. å®ä½“æå–
    const entities = await this.nlpService.extractEntities(userInput);
    
    // 3. æŠ€èƒ½ç±»å‹åˆ¤æ–­
    const skillType = this.determineSkillType(intent, entities);
    
    // 4. å¤æ‚åº¦è¯„ä¼°
    const complexity = this.assessComplexity(userInput, entities);
    
    // 5. å¯è¡Œæ€§è¯„ä¼°
    const feasibility = await this.assessFeasibility(skillType, complexity);
    
    return {
      intent,
      entities,
      skillType,
      complexity,
      feasibility,
      estimatedTime: this.estimateTime(complexity),
      suggestions: await this.generateSuggestions(userInput)
    };
  }
  
  determineSkillType(intent, entities) {
    const typeMapping = {
      'code_analysis': 'ä»£ç åˆ†ææŠ€èƒ½',
      'data_processing': 'æ•°æ®å¤„ç†æŠ€èƒ½',
      'text_generation': 'æ–‡æœ¬ç”ŸæˆæŠ€èƒ½',
      'automation': 'è‡ªåŠ¨åŒ–æŠ€èƒ½',
      'translation': 'ç¿»è¯‘æŠ€èƒ½',
      'api_integration': 'APIé›†æˆæŠ€èƒ½'
    };
    
    return typeMapping[intent.primary] || 'é€šç”¨æŠ€èƒ½';
  }
  
  assessComplexity(input, entities) {
    const complexityFactors = {
      inputLength: input.length,
      entityCount: entities.length,
      technicalTerms: this.countTechnicalTerms(input),
      conditionalLogic: this.countConditionalLogic(input),
      apiReferences: this.countApiReferences(input)
    };
    
    const score = Object.values(complexityFactors).reduce((a, b) => a + b, 0);
    
    if (score < 10) return 'ç®€å•';
    if (score < 20) return 'ä¸­ç­‰';
    return 'å¤æ‚';
  }
}
```

### ç¬¬äºŒé˜¶æ®µï¼šäº¤äº’å¼éœ€æ±‚æç‚¼

```
éœ€æ±‚æ¾„æ¸… â†’ çº¦æŸå¯¹é½ â†’ åŠŸèƒ½ç»†åŒ– â†’ ä¸ç¡®å®šæ€§ç¡®è®¤
```

#### 2.1 äº¤äº’å¼æç‚¼ç•Œé¢
```html
<div class="refinement-section">
  <div class="conversation-panel">
    <div class="messages">
      <div v-for="message in messages" :key="message.id" class="message" :class="message.type">
        <div class="message-content">{{ message.content }}</div>
        <div class="message-time">{{ formatTime(message.timestamp) }}</div>
      </div>
    </div>
    
    <div class="input-area">
      <div v-if="currentQuestion" class="question-panel">
        <h3>{{ currentQuestion.title }}</h3>
        <p>{{ currentQuestion.description }}</p>
        
        <div v-if="currentQuestion.type === 'options'" class="options">
          <label v-for="option in currentQuestion.options" :key="option.value">
            <input 
              type="radio" 
              v-model="currentAnswer" 
              :value="option.value"
              @change="submitAnswer"
            >
            {{ option.label }}
            <span class="option-description">{{ option.description }}</span>
          </label>
        </div>
        
        <div v-if="currentQuestion.type === 'text'" class="text-input">
          <textarea 
            v-model="currentAnswer"
            placeholder="è¯·è¾“å…¥æ‚¨çš„å›ç­”..."
            @blur="submitAnswer"
          ></textarea>
        </div>
        
        <div v-if="currentQuestion.type === 'confirmation'" class="confirmation">
          <p>ç¡®è®¤ä»¥ä¸‹ä¿¡æ¯ï¼š</p>
          <div class="confirmation-details">
            <div v-for="detail in currentQuestion.details" :key="detail.key">
              <strong>{{ detail.key }}:</strong> {{ detail.value }}
            </div>
          </div>
          <div class="confirmation-buttons">
            <button @click="confirm" class="btn-confirm">ç¡®è®¤</button>
            <button @click="revise" class="btn-revise">ä¿®æ”¹</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="requirements-panel">
    <h3>æç‚¼çš„éœ€æ±‚</h3>
    <div class="requirement-item" v-for="req in refinedRequirements" :key="req.id">
      <span class="req-category">{{ req.category }}</span>
      <span class="req-content">{{ req.content }}</span>
      <button @click="editRequirement(req)" class="btn-edit">ç¼–è¾‘</button>
    </div>
  </div>
</div>
```

#### 2.2 éœ€æ±‚æç‚¼å¼•æ“
```javascript
class RequirementRefiner {
  constructor() {
    this.questionGenerator = new QuestionGenerator();
    this.constraintAligner = new ConstraintAligner();
    this.uncertaintyHandler = new UncertaintyHandler();
  }
  
  async startRefinement(initialIdea) {
    this.currentRequirements = {
      input: [],
      output: [],
      process: [],
      constraints: []
    };
    
    this.conversationHistory = [];
    
    // ç”Ÿæˆç¬¬ä¸€ä¸ªé—®é¢˜
    const firstQuestion = await this.questionGenerator.generateFirstQuestion(initialIdea);
    this.askQuestion(firstQuestion);
  }
  
  async processAnswer(answer) {
    // è®°å½•å¯¹è¯
    this.conversationHistory.push({
      type: 'user',
      content: answer,
      timestamp: new Date()
    });
    
    // åˆ†æç­”æ¡ˆ
    const analysis = await this.analyzeAnswer(answer);
    
    // æ›´æ–°éœ€æ±‚
    this.updateRequirements(analysis);
    
    // æ£€æŸ¥ä¸ç¡®å®šæ€§
    const uncertainties = await this.identifyUncertainties();
    
    if (uncertainties.length > 0) {
      // å¤„ç†ä¸ç¡®å®šæ€§
      await this.handleUncertainties(uncertainties);
    } else {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´å¤šä¿¡æ¯
      const nextQuestion = await this.decideNextQuestion();
      
      if (nextQuestion) {
        this.askQuestion(nextQuestion);
      } else {
        // æç‚¼å®Œæˆ
        await this.finalizeRequirements();
      }
    }
  }
  
  async identifyUncertainties() {
    const uncertainties = [];
    
    // æ£€æŸ¥çº¦æŸå®Œæ•´æ€§
    const missingConstraints = await this.constraintAligner.findMissingConstraints(
      this.currentRequirements
    );
    
    if (missingConstraints.length > 0) {
      uncertainties.push({
        type: 'missing_constraints',
        description: 'ç¼ºå°‘å¿…è¦çš„çº¦æŸæ¡ä»¶',
        details: missingConstraints,
        priority: 'high'
      });
    }
    
    // æ£€æŸ¥é€»è¾‘ä¸€è‡´æ€§
    const inconsistencies = await this.constraintAligner.checkConsistency(
      this.currentRequirements
    );
    
    if (inconsistencies.length > 0) {
      uncertainties.push({
        type: 'logic_inconsistency',
        description: 'å­˜åœ¨é€»è¾‘ä¸ä¸€è‡´',
        details: inconsistencies,
        priority: 'medium'
      });
    }
    
    // æ£€æŸ¥å®ç°å¯è¡Œæ€§
    const feasibilityIssues = await this.assessFeasibility(
      this.currentRequirements
    );
    
    if (feasibilityIssues.length > 0) {
      uncertainties.push({
        type: 'feasibility_issue',
        description: 'å®ç°å¯è¡Œæ€§å­˜åœ¨é—®é¢˜',
        details: feasibilityIssues,
        priority: 'high'
      });
    }
    
    return uncertainties;
  }
  
  async handleUncertainties(uncertainties) {
    for (const uncertainty of uncertainties) {
      const question = await this.uncertaintyHandler.generateClarificationQuestion(
        uncertainty
      );
      
      this.askQuestion(question);
      
      // ç­‰å¾…ç”¨æˆ·å›ç­”
      const answer = await this.waitForAnswer();
      
      // å¤„ç†å›ç­”
      await this.processUncertaintyAnswer(uncertainty, answer);
    }
  }
}
```

### ç¬¬ä¸‰é˜¶æ®µï¼šæŠ€èƒ½ä»£ç ç”Ÿæˆ

```
éœ€æ±‚ç»“æ„åŒ– â†’ ä»£ç æ¨¡æ¿é€‰æ‹© â†’ å‚æ•°å¡«å…… â†’ ä»£ç ç”Ÿæˆ â†’ å®‰å…¨æ£€æŸ¥
```

#### 3.1 ä»£ç ç”Ÿæˆå™¨
```javascript
class SkillCodeGenerator {
  constructor() {
    this.templateEngine = new TemplateEngine();
    this.codeValidator = new CodeValidator();
    this.securityChecker = new SecurityChecker();
  }
  
  async generateSkill(requirements) {
    try {
      // 1. ç»“æ„åŒ–éœ€æ±‚
      const structuredRequirements = await this.structureRequirements(requirements);
      
      // 2. é€‰æ‹©æ¨¡æ¿
      const template = await this.selectTemplate(structuredRequirements);
      
      // 3. ç”ŸæˆStigmergyæŠ€èƒ½ä»£ç 
      const stigmergyCode = await this.generateStigmergySkill(
        structuredRequirements,
        template
      );
      
      // 4. ç”ŸæˆClaudeæŠ€èƒ½ä»£ç 
      const claudeCode = await this.generateClaudeSkill(
        structuredRequirements,
        template
      );
      
      // 5. å®‰å…¨æ£€æŸ¥
      const securityCheck = await this.securityChecker.check([
        stigmergyCode,
        claudeCode
      ]);
      
      if (!securityCheck.safe) {
        throw new Error('ç”Ÿæˆçš„ä»£ç å­˜åœ¨å®‰å…¨é£é™©');
      }
      
      // 6. ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
      const testCases = await this.generateTestCases(structuredRequirements);
      
      return {
        stigmergy: {
          code: stigmergyCode,
          metadata: this.generateMetadata(structuredRequirements, 'stigmergy')
        },
        claude: {
          code: claudeCode,
          metadata: this.generateMetadata(structuredRequirements, 'claude')
        },
        tests: testCases,
        requirements: structuredRequirements,
        security: securityCheck
      };
      
    } catch (error) {
      console.error('æŠ€èƒ½ç”Ÿæˆå¤±è´¥:', error);
      throw error;
    }
  }
  
  async generateStigmergySkill(requirements, template) {
    const skillTemplate = `
// è‡ªåŠ¨ç”Ÿæˆçš„StigmergyæŠ€èƒ½
// ç”Ÿæˆæ—¶é—´: {{ timestamp }}
// æŠ€èƒ½ç±»å‹: {{ skillType }}

const {{ skillName }} = {
  name: '{{ skillName }}',
  description: '{{ description }}',
  version: '1.0.0',
  
  // æŠ€èƒ½é…ç½®
  config: {
    {{#each config}}
    {{ key }}: {{ value }},
    {{/each}}
  },
  
  // è¾“å…¥éªŒè¯
  validateInput: (input) => {
    {{#each inputValidation}}
    if ({{ condition }}) {
      throw new Error('{{ message }}');
    }
    {{/each}}
    return true;
  },
  
  // æ ¸å¿ƒé€»è¾‘
  execute: async (input, context) => {
    // éªŒè¯è¾“å…¥
    {{ skillName }}.validateInput(input);
    
    try {
      {{#each processSteps}}
      // {{ description }}
      const {{ variableName }} = await {{ functionCall }}({{ parameters }});
      {{/each}}
      
      return {
        success: true,
        result: {{ outputVariable }},
        metadata: {
          executionTime: Date.now() - startTime,
          version: '{{ version }}'
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        metadata: {
          executionTime: Date.now() - startTime,
          version: '{{ version }}'
        }
      };
    }
  },
  
  // è¾“å‡ºæ ¼å¼åŒ–
  formatOutput: (result) => {
    {{#each outputFormatting}}
    {{ code }}
    {{/each}}
    return result;
  }
};

module.exports = {{ skillName }};
`;
    
    return this.templateEngine.render(skillTemplate, {
      timestamp: new Date().toISOString(),
      skillType: requirements.skillType,
      skillName: this.generateSkillName(requirements),
      description: requirements.description,
      config: requirements.config,
      inputValidation: requirements.inputValidation,
      processSteps: requirements.processSteps,
      outputFormatting: requirements.outputFormatting,
      version: '1.0.0'
    });
  }
  
  async generateClaudeSkill(requirements, template) {
    const skillTemplate = `
# è‡ªåŠ¨ç”Ÿæˆçš„ClaudeæŠ€èƒ½
# ç”Ÿæˆæ—¶é—´: {{ timestamp }}
# æŠ€èƒ½ç±»å‹: {{ skillType }}

---
name: {{ skillName }}
description: {{ description }}
version: 1.0.0
author: {{ author }}
tags: [{{ tags }}]
---

## æŠ€èƒ½è¯´æ˜

{{ detailedDescription }}

## ä½¿ç”¨æ–¹æ³•

\`\`\`bash
# è°ƒç”¨æŠ€èƒ½
claude> {{ skillName }} [å‚æ•°]
\`\`\`

## å®ç°é€»è¾‘

{{#each processSteps}}
### {{ stepNumber }}. {{ title }}

{{ description }}

\`\`\`javascript
{{ implementation }}
\`\`\`

{{/each}}

## è¾“å…¥å‚æ•°

{{#each inputParameters}}
- **{{ name }}** ({{ type }}): {{ description }}
  - å¿…éœ€: {{ required }}
  - é»˜è®¤å€¼: {{ defaultValue }}
  - éªŒè¯è§„åˆ™: {{ validation }}

{{/each}}

## è¾“å‡ºæ ¼å¼

{{ outputFormat }}

## é”™è¯¯å¤„ç†

{{#each errorCases}}
- **{{ errorType }}**: {{ description }}
  - å¤„ç†æ–¹å¼: {{ handling }}

{{/each}}

## æµ‹è¯•ç”¨ä¾‹

{{#each testCases}}
### æµ‹è¯• {{ testNumber }}

**è¾“å…¥:**
\`\`\`
{{ input }}
\`\`\`

**é¢„æœŸè¾“å‡º:**
\`\`\`
{{ expectedOutput }}
\`\`\`

{{/each}}
`;
    
    return this.templateEngine.render(skillTemplate, {
      timestamp: new Date().toISOString(),
      skillType: requirements.skillType,
      skillName: this.generateSkillName(requirements),
      description: requirements.description,
      detailedDescription: requirements.detailedDescription,
      author: requirements.author,
      tags: requirements.tags.join(', '),
      processSteps: requirements.processSteps,
      inputParameters: requirements.inputParameters,
      outputFormat: requirements.outputFormat,
      errorCases: requirements.errorCases,
      testCases: requirements.testCases
    });
  }
}
```

### ç¬¬å››é˜¶æ®µï¼šç”¨æˆ·æµ‹è¯•ç¯å¢ƒ

```
æ²™ç®±ç¯å¢ƒ â†’ æµ‹è¯•ç”¨ä¾‹æ‰§è¡Œ â†’ ç»“æœéªŒè¯ â†’ ç”¨æˆ·åé¦ˆ
```

#### 4.1 æµ‹è¯•ç¯å¢ƒè®¾è®¡
```html
<div class="testing-environment">
  <div class="test-controls">
    <h3>æŠ€èƒ½æµ‹è¯•</h3>
    <div class="test-input">
      <label>æµ‹è¯•è¾“å…¥:</label>
      <textarea v-model="testInput" placeholder="è¾“å…¥æµ‹è¯•æ•°æ®..."></textarea>
    </div>
    
    <div class="test-actions">
      <button @click="runTest" :disabled="isTesting" class="btn-run-test">
        {{ isTesting ? 'æµ‹è¯•ä¸­...' : 'è¿è¡Œæµ‹è¯•' }}
      </button>
      <button @click="runAllTests" class="btn-run-all">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
      <button @click="resetTest" class="btn-reset">é‡ç½®</button>
    </div>
  </div>
  
  <div class="test-results">
    <h3>æµ‹è¯•ç»“æœ</h3>
    <div v-if="testResult" class="result-item">
      <div class="result-status" :class="testResult.success ? 'success' : 'error'">
        {{ testResult.success ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥' }}
      </div>
      
      <div class="result-details">
        <div class="result-input">
          <strong>è¾“å…¥:</strong>
          <pre>{{ testResult.input }}</pre>
        </div>
        
        <div class="result-output">
          <strong>è¾“å‡º:</strong>
          <pre>{{ testResult.output }}</pre>
        </div>
        
        <div v-if="testResult.error" class="result-error">
          <strong>é”™è¯¯:</strong>
          <pre>{{ testResult.error }}</pre>
        </div>
        
        <div class="result-performance">
          <strong>æ€§èƒ½:</strong>
          <span>æ‰§è¡Œæ—¶é—´: {{ testResult.executionTime }}ms</span>
          <span>å†…å­˜ä½¿ç”¨: {{ testResult.memoryUsage }}MB</span>
        </div>
      </div>
    </div>
    
    <div v-if="testResults.length > 1" class="all-results">
      <div v-for="result in testResults" :key="result.id" class="result-summary">
        <span class="test-name">{{ result.name }}</span>
        <span class="test-status" :class="result.success ? 'success' : 'error'">
          {{ result.success ? 'âœ…' : 'âŒ' }}
        </span>
        <span class="test-time">{{ result.executionTime }}ms</span>
      </div>
    </div>
  </div>
  
  <div class="test-feedback">
    <h3>æµ‹è¯•åé¦ˆ</h3>
    <textarea 
      v-model="userFeedback"
      placeholder="è¯·æè¿°æµ‹è¯•ä¸­å‘ç°çš„é—®é¢˜æˆ–æ”¹è¿›å»ºè®®..."
    ></textarea>
    
    <div class="feedback-actions">
      <button @click="submitFeedback" class="btn-submit">æäº¤åé¦ˆ</button>
      <button @click="requestRevision" class="btn-revision">è¦æ±‚ä¿®æ”¹</button>
      <button @click="approveSkill" class="btn-approve">æ‰¹å‡†å‘å¸ƒ</button>
    </div>
  </div>
</div>
```

#### 4.2 æµ‹è¯•å¼•æ“
```javascript
class SkillTestEngine {
  constructor() {
    this.sandbox = new SecureSandbox();
    this.testRunner = new TestRunner();
    this.performanceMonitor = new PerformanceMonitor();
  }
  
  async runSingleTest(skillCode, testInput) {
    const startTime = Date.now();
    const startMemory = process.memoryUsage().heapUsed;
    
    try {
      // åœ¨æ²™ç®±ä¸­æ‰§è¡ŒæŠ€èƒ½
      const result = await this.sandbox.execute(skillCode, testInput);
      
      const endTime = Date.now();
      const endMemory = process.memoryUsage().heapUsed;
      
      return {
        success: true,
        input: testInput,
        output: result,
        executionTime: endTime - startTime,
        memoryUsage: Math.round((endMemory - startMemory) / 1024 / 1024 * 100) / 100,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      const endTime = Date.now();
      const endMemory = process.memoryUsage().heapUsed;
      
      return {
        success: false,
        input: testInput,
        error: error.message,
        executionTime: endTime - startTime,
        memoryUsage: Math.round((endMemory - startMemory) / 1024 / 1024 * 100) / 100,
        timestamp: new Date().toISOString()
      };
    }
  }
  
  async runAllTests(skillCode, testCases) {
    const results = [];
    
    for (const testCase of testCases) {
      const result = await this.runSingleTest(skillCode, testCase.input);
      
      results.push({
        ...result,
        name: testCase.name,
        expected: testCase.expected,
        passed: this.validateResult(result, testCase.expected)
      });
    }
    
    return {
      results,
      summary: {
        total: testCases.length,
        passed: results.filter(r => r.passed).length,
        failed: results.filter(r => !r.passed).length,
        averageExecutionTime: results.reduce((sum, r) => sum + r.executionTime, 0) / results.length
      }
    };
  }
  
  validateResult(actualResult, expectedResult) {
    // å®ç°ç»“æœéªŒè¯é€»è¾‘
    if (typeof expectedResult === 'string') {
      return actualResult.output.includes(expectedResult);
    }
    
    if (typeof expectedResult === 'object') {
      return this.deepCompare(actualResult.output, expectedResult);
    }
    
    return actualResult.output === expectedResult;
  }
  
  deepCompare(obj1, obj2) {
    // æ·±åº¦æ¯”è¾ƒä¸¤ä¸ªå¯¹è±¡
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
}
```

### ç¬¬äº”é˜¶æ®µï¼šå¹³å°å®¡æ ¸ä¸å‘å¸ƒ

```
ä»£ç å®¡æ ¸ â†’ å®‰å…¨æ£€æŸ¥ â†’ æ€§èƒ½è¯„ä¼° â†’ äººå·¥å®¡æ ¸ â†’ å‘å¸ƒ
```

#### 5.1 å®¡æ ¸æµç¨‹è®¾è®¡
```javascript
class SkillReviewProcess {
  constructor() {
    this.codeReviewer = new CodeReviewer();
    this.securityScanner = new SecurityScanner();
    this.performanceAnalyzer = new PerformanceAnalyzer();
    this.humanReviewer = new HumanReviewer();
  }
  
  async reviewSkill(skillSubmission) {
    const reviewResult = {
      skillId: skillSubmission.id,
      stages: {},
      overallStatus: 'pending',
      issues: [],
      recommendations: []
    };
    
    try {
      // 1. è‡ªåŠ¨ä»£ç å®¡æ ¸
      reviewResult.stages.codeReview = await this.codeReviewer.review(
        skillSubmission.stigmergy.code,
        skillSubmission.claude.code
      );
      
      // 2. å®‰å…¨æ‰«æ
      reviewResult.stages.securityScan = await this.securityScanner.scan([
        skillSubmission.stigmergy.code,
        skillSubmission.claude.code
      ]);
      
      // 3. æ€§èƒ½åˆ†æ
      reviewResult.stages.performanceAnalysis = await this.performanceAnalyzer.analyze(
        skillSubmission.testResults
      );
      
      // 4. äººå·¥å®¡æ ¸
      if (this.requiresHumanReview(reviewResult)) {
        reviewResult.stages.humanReview = await this.humanReviewer.review(
          skillSubmission,
          reviewResult
        );
      }
      
      // 5. ç»¼åˆè¯„ä¼°
      reviewResult.overallStatus = this.calculateOverallStatus(reviewResult);
      reviewResult.issues = this.collectIssues(reviewResult);
      reviewResult.recommendations = this.generateRecommendations(reviewResult);
      
      return reviewResult;
      
    } catch (error) {
      console.error('å®¡æ ¸è¿‡ç¨‹å‡ºé”™:', error);
      throw new Error('æŠ€èƒ½å®¡æ ¸å¤±è´¥');
    }
  }
  
  requiresHumanReview(reviewResult) {
    // æ£€æŸ¥æ˜¯å¦éœ€è¦äººå·¥å®¡æ ¸
    const hasSecurityIssues = reviewResult.stages.securityScan.issues.length > 0;
    const hasCodeIssues = reviewResult.stages.codeReview.issues.length > 0;
    const hasPerformanceIssues = reviewResult.stages.performanceAnalysis.score < 0.8;
    
    return hasSecurityIssues || hasCodeIssues || hasPerformanceIssues;
  }
  
  calculateOverallStatus(reviewResult) {
    const stages = reviewResult.stages;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸¥é‡é—®é¢˜
    if (stages.securityScan.criticalIssues > 0) {
      return 'rejected';
    }
    
    // æ£€æŸ¥å„é˜¶æ®µè¯„åˆ†
    const scores = [
      stages.codeReview.score || 0,
      stages.securityScan.score || 0,
      stages.performanceAnalysis.score || 0
    ];
    
    const averageScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    
    if (averageScore >= 0.9) {
      return 'approved';
    } else if (averageScore >= 0.7) {
      return 'approved_with_suggestions';
    } else {
      return 'needs_revision';
    }
  }
  
  async publishSkill(skillId, reviewResult) {
    if (reviewResult.overallStatus === 'rejected') {
      throw new Error('æŠ€èƒ½æœªé€šè¿‡å®¡æ ¸ï¼Œæ— æ³•å‘å¸ƒ');
    }
    
    // åˆ›å»ºå‘å¸ƒè®°å½•
    const publication = {
      skillId,
      version: '1.0.0',
      reviewResult,
      publishedAt: new Date(),
      publishedBy: 'system',
      downloadUrl: `/api/skills/${skillId}/download`,
      documentation: `/api/skills/${skillId}/docs`
    };
    
    // æ›´æ–°æŠ€èƒ½çŠ¶æ€
    await SkillModel.findByIdAndUpdate(skillId, {
      status: 'published',
      publishedAt: new Date(),
      reviewResult
    });
    
    // é€šçŸ¥ç”¨æˆ·
    await this.notifyPublication(skillId, publication);
    
    return publication;
  }
}
```

## ğŸ“Š æµç¨‹çŠ¶æ€ç®¡ç†

```javascript
class SkillCreationWorkflow {
  constructor() {
    this.currentStage = 'input';
    this.workflowData = {};
    this.stageHistory = [];
  }
  
  async transitionToStage(stage, data) {
    // è®°å½•é˜¶æ®µè½¬æ¢
    this.stageHistory.push({
      from: this.currentStage,
      to: stage,
      timestamp: new Date(),
      data
    });
    
    // æ›´æ–°å½“å‰é˜¶æ®µ
    this.currentStage = stage;
    
    // ä¿å­˜å·¥ä½œæµæ•°æ®
    this.workflowData[stage] = data;
    
    // è§¦å‘é˜¶æ®µç‰¹å®šé€»è¾‘
    await this.handleStageTransition(stage, data);
  }
  
  async handleStageTransition(stage, data) {
    switch (stage) {
      case 'analysis':
        await this.handleAnalysisStage(data);
        break;
      case 'refinement':
        await this.handleRefinementStage(data);
        break;
      case 'generation':
        await this.handleGenerationStage(data);
        break;
      case 'testing':
        await this.handleTestingStage(data);
        break;
      case 'review':
        await this.handleReviewStage(data);
        break;
      case 'publication':
        await this.handlePublicationStage(data);
        break;
    }
  }
  
  getWorkflowProgress() {
    const stages = ['input', 'analysis', 'refinement', 'generation', 'testing', 'review', 'publication'];
    const currentIndex = stages.indexOf(this.currentStage);
    
    return {
      currentStage: this.currentStage,
      progress: (currentIndex + 1) / stages.length,
      completedStages: stages.slice(0, currentIndex),
      remainingStages: stages.slice(currentIndex + 1)
    };
  }
}
```

---

**è®¾è®¡å›¢é˜Ÿ**ï¼šæŠ€èƒ½åˆ›å»ºæµç¨‹è®¾è®¡å›¢é˜Ÿ  
**è®¾è®¡æ—¥æœŸ**ï¼š2025å¹´12æœˆ14æ—¥  
**ç‰ˆæœ¬**ï¼šv1.0