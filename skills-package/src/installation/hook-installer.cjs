#!/usr/bin/env node

/**
 * Hook Installer - TDD Implementation
 * Phase 3: Installation System - GREEN Phase (Minimal implementation to pass tests)
 */

const fs = require('fs');
const path = require('path');
const PlatformAdapter = require('./platform-adapter.cjs');

class HookInstaller {
    constructor() {
        this.platformAdapter = new PlatformAdapter();
        this.supportedCLIs = ['claude', 'gemini', 'qwen', 'qoder', 'iflow', 'codebuddy', 'copilot', 'codex'];
    }

    createHookDirectories(basePath) {
        const directories = [];

        for (const cliType of this.supportedCLIs) {
            const hookDir = path.join(basePath, cliType, 'hooks');
            directories.push(hookDir);

            try {
                if (!fs.existsSync(hookDir)) {
                    fs.mkdirSync(hookDir, { recursive: true });
                }
            } catch (error) {
                throw new Error(`Failed to create directory for ${cliType}: ${error.message}`);
            }
        }

        return directories;
    }

    installHook(cliType, basePath) {
        if (!this.supportedCLIs.includes(cliType)) {
            return {
                success: false,
                error: `Unsupported CLI type: ${cliType}`,
                cliType
            };
        }

        try {
            const hookDir = path.join(basePath, cliType, 'hooks');
            const hookFileName = `stigmergy-skill.cjs`;
            const hookPath = path.join(hookDir, hookFileName);

            // Ensure directory exists
            if (!fs.existsSync(hookDir)) {
                fs.mkdirSync(hookDir, { recursive: true });
            }

            // Generate hook content
            const hookContent = this.generateHookContent(cliType);

            // Write hook file
            fs.writeFileSync(hookPath, hookContent, 'utf8');

            // Make hook executable on Unix systems
            if (process.platform !== 'win32') {
                fs.chmodSync(hookPath, '755');
            }

            return {
                success: true,
                cliType,
                hookPath,
                hookFileName,
                size: Buffer.byteLength(hookContent, 'utf8'),
                createdAt: new Date().toISOString()
            };

        } catch (error) {
            return {
                success: false,
                error: error.message,
                cliType
            };
        }
    }

    generateHookContent(cliType) {
        const skillsDetectorPath = path.resolve(__dirname, '..', 'skills-engine', 'skills-detector.cjs');

        const hookTemplate = `#!/usr/bin/env node
/**
 * ${cliType.charAt(0).toUpperCase() + cliType.slice(1)} Hook for Stigmergy Skills
 * Auto-generated by stigmergy-skill package
 * Generated: ${new Date().toISOString()}
 */

const SkillsDetector = require('${skillsDetectorPath.replace(/\\/g, '/')}');
const detector = new SkillsDetector();

module.exports = {
    name: 'stigmergy-skill',
    description: 'Natural language skill detection and execution for ${cliType}',
    version: '1.0.0',
    cliType: '${cliType}',

    // Main hook execution function
    execute: async function(input, context = {}) {
        try {
            // Detect skill from natural language input
            const result = detector.detectSkill(input);

            if (result.skill && result.confidence > 5) {
                return {
                    handled: true,
                    skill: result.skill,
                    confidence: result.confidence,
                    parameters: result.parameters,
                    cliType: '${cliType}',
                    context: context
                };
            }

            return {
                handled: false,
                reason: 'No suitable skill detected or confidence too low'
            };
        } catch (error) {
            return {
                handled: false,
                error: error.message,
                cliType: '${cliType}'
            };
        }
    },

    // Skill validation function
    validateSkill: function(skillInput) {
        const result = detector.detectSkill(skillInput);
        return {
            valid: result.skill !== null,
            skill: result.skill,
            confidence: result.confidence
        };
    },

    // Configuration function
    getConfig: function() {
        return {
            enabled: true,
            skills: ['translation', 'code-analysis', 'code-generation', 'documentation'],
            minConfidence: 5,
            timeout: 30000
        };
    }
};

// Export for direct execution
if (require.main === module) {
    const input = process.argv.slice(2).join(' ');
    module.exports.execute(input, { fromCLI: true })
        .then(result => {
            console.log(JSON.stringify(result, null, 2));
            process.exit(result.handled ? 0 : 1);
        })
        .catch(error => {
            console.error('Hook execution failed:', error.message);
            process.exit(1);
        });
}
`;

        return hookTemplate;
    }

    uninstallHook(cliType, basePath) {
        const hookPath = path.join(basePath, cliType, 'hooks', 'stigmergy-skill.cjs');

        try {
            if (fs.existsSync(hookPath)) {
                fs.unlinkSync(hookPath);
                return {
                    success: true,
                    cliType,
                    uninstalled: true,
                    hookPath
                };
            } else {
                return {
                    success: true,
                    cliType,
                    uninstalled: false,
                    reason: 'Hook file does not exist'
                };
            }
        } catch (error) {
            return {
                success: false,
                error: error.message,
                cliType
            };
        }
    }

    installAllHooks(basePath) {
        const results = [];
        let successCount = 0;
        let failureCount = 0;

        for (const cliType of this.supportedCLIs) {
            const result = this.installHook(cliType, basePath);
            results.push(result);

            if (result.success) {
                successCount++;
            } else {
                failureCount++;
            }
        }

        return {
            success: failureCount === 0,
            results,
            summary: {
                total: this.supportedCLIs.length,
                successful: successCount,
                failed: failureCount
            }
        };
    }
}

module.exports = HookInstaller;